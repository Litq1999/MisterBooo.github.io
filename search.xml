<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>准备下次编程面试前你应该知道的数据结构</title>
      <link href="/2019/01/28/x-title-zhun-bei-xia-ci-bian-cheng-mian-shi-qian-ni-ying-gai-zhi-dao-de-shu-ju-jie-gou-date-2019-01-28-171655author-cheng-xu-yuan-wu-shi-xiong-top-truecategories-fen-xiang-tags-shu-ju-jie-gou-suan-fa-yaml/"/>
      <url>/2019/01/28/x-title-zhun-bei-xia-ci-bian-cheng-mian-shi-qian-ni-ying-gai-zhi-dao-de-shu-ju-jie-gou-date-2019-01-28-171655author-cheng-xu-yuan-wu-shi-xiong-top-truecategories-fen-xiang-tags-shu-ju-jie-gou-suan-fa-yaml/</url>
      
        <content type="html"><![CDATA[<blockquote><p>国外 IT 教育学院 Educative.io 创始人 Fahim ul Haq 写过一篇过万赞的文章<a href="https://medium.freecodecamp.org/the-top-data-structures-you-should-know-for-your-next-coding-interview-36af0831f5e3" target="_blank" rel="noopener">《The top data structures you should know for your next coding interview》</a>,总结了<strong>程序员面试中需要掌握的 8 种数据结构知识</strong>。</p></blockquote><blockquote><p>Fahim ul Haq 曾在 Facebook 和微软任职，面试过不少程序员，所以这篇文章还是值得参考的。以下内容编译自他的这篇《准备下次编程面试前你应该知道的数据结构》：</p></blockquote><p>瑞典计算机科学家 Niklaus Wirth 在 1976 年写了一本书，叫作《Algorithms + Data Structures = Programs》（算法+数据结构=程序）。</p><p>即便在 40 年后的今天，这条等式仍然成立。这也是为何程序员求职者应该向面试官展示出已经透彻理解了数据结构知识。</p><p>几乎所有的面试问题都要求求职者表现出已经熟练掌握数据结构，不管你是刚毕业的应届生还是工作了多年的老手，都是这样。</p><p>有时，面试问题会明确提到数据结构，比如“给定一个二叉树”；有时则比较含蓄，比如“我们想追踪和每位作者相关的书籍数量。”</p><p>学习数据结构知识很有必要，哪怕你只是想找份比现在的工作更好的一份差事。我们首先了解数据结构的基本知识。</p><p><strong>什么是数据结构？</strong></p><p>简单说，数据结构就是一个容器，以某种特定的布局存储数据。这个“布局”使得数据结构在某些操作上非常高效，在另一些操作上则不那么高效。你的目标就是理解数据结构，这样就能为手头的问题选择最优的数据结构。</p><p><strong>为什么我们需要数据结构？</strong></p><p>由于数据结构用来以有组织的形式存储数据，而且数据是计算机科学中最重要的实体，因此数据结构的真正价值显而易见。</p><p>无论你解决什么问题，你都必须以这种或那种方式处理数据比如员工的工资，股票价格，购物清单，甚至简单的电话簿等等。</p><p>根据不同的场景，数据需要以特定格式存储。目前有一些数据结构可以满足我们以不同格式存储数据的需求。</p><p><strong>常用的数据结构</strong></p><p>我们首先列出最常用的数据结构，然后再挨个讲解：</p><ul><li>数组</li><li>堆栈</li><li>队列</li><li>链表</li><li>树</li><li>图</li><li>字典树</li><li>哈希表</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是一种最简单和最广泛使用的数据结构，其它数据结构比如堆栈和队列都源自数组。</p><p>下图是一个大小为 4 的简单数组，包含几个元素（  1  ,  2  ,  3，4）。</p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/16a096ac9282164c94c642f8e8d68961.png" alt=""></p><p>每个数据元素会被分配一个正的数值，叫作“索引”，它对应该元素在数组中的位置。大部分编程语言都将初始索引定义为 0.</p><p>以下是两种数组：</p><ul><li>一维数组（如上所示）</li><li>多维数组（数组的数组）</li></ul><p>数组的基本操作：</p><ul><li>Insert——在给定索引位置插入一个元素</li><li>Get——返回给定索引位置的元素</li><li>Delete——删除给定索引位置的元素</li><li>Size——获取数组内所有元素的总数</li></ul><p><strong>常问的数组面试问题</strong>：</p><ul><li>找到数组中第二小的元素</li><li>找到数组中第一个没有重复的整数</li><li>合并两个分类数组</li><li>重新排列数组中的正值和负值</li></ul><h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><p>我们都熟悉很有名的撤销（Undo）选项，它几乎存在每个应用程序中。有没有想过它是如何工作的？其思路就是，按照最后的状态排列在先的顺序将工作的先前状态（限于特定数字）存储在内存中。这只用数组是无法实现的，因此堆栈就有了用武之地。</p><p>可以把堆栈看作一堆垂直排列的书籍。为了获得位于中间位置的书，你需要拿掉放在它上面的所有书籍。这就是 LIFO（后进先出）方法的工作原理。</p><p>这是一个包含三个数据元素（1,2 和 3）的堆栈图像，其中3位于顶部，首先把它删除：</p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/8418f560a659ff24cb90ded2ca238b59.png" alt=""></p><p><strong>堆栈的基本操作</strong>：</p><ul><li>Push——在顶部插入元素</li><li>Pop—— 从堆栈中删除后返回顶部元素</li><li>isEmpty——如果堆栈为空，则返回 true</li><li>Top ——返回顶部元素，但不从堆栈中删除</li></ul><p><strong>常见的堆栈面试问题</strong>：</p><ul><li>使用堆栈计算后缀表达式</li><li>对堆栈中的值进行排序</li><li>检查表达式中的括号是否平衡</li></ul><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>与堆栈类似，队列是另一种线性数据结构，以顺序方式存储元素。堆栈和队列之间唯一的显着区别是，队列不是使用 LIFO 方法，而是应用 FIFO 方法，这是 First in First Out（先入先出）的缩写。</p><p>队列的完美现实例子：一列人在售票亭等候。如果有新人来，他们是从末尾加入队列，而不是在开头——站在前面的人将先买到票然后离开队列。</p><p>下图是一个包含四个数据元素（1,2,3 和 4）的队列，其中 1 位于顶部，首先把它删除：</p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/f70ab2adc32c9d5c7468401231f60c87.png" alt=""></p><p><strong>队列的基本操作</strong>：</p><ul><li>Enqueue() —— 向队列末尾插入元素</li><li>Dequeue() —— 从队列头部移除元素</li><li>isEmpty() —— 如果队列为空，则返回 true</li><li>Top() —— 返回队列的第一个元素</li></ul><p><strong>常问的队列面试问题</strong>：</p><ul><li>使用队列来实现堆栈</li><li>颠倒队列中前 k 个元素的顺序</li><li>使用队列生成从 1 到 n 的二进制数</li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是另一个重要的线性数据结构，刚一看可能看起来像数组，但在内存分配，内部结构以及如何执行插入和删除的基本操作方面有所不同。</p><p>链表就像一个节点链，其中每个节点包含数据和指向链中后续节点的指针等信息。有一个头指针，指向链表的第一个元素，如果列表是空的，那么它只指向 null 或不指向任何内容。</p><p>链表用于实现文件系统，哈希表和邻接表。下图是链表内部结构的直观展示：<br><img src="https://diycode.b0.upaiyun.com/photo/2019/c9d4e6282fe39203b7743e22b3781db5.png" alt=""></p><p><strong>下面是几种类型的链表</strong>：</p><ul><li>单链表（单向）</li><li>双链表（双向）</li></ul><p><strong>链表的基本操作</strong>：</p><ul><li>InsertAtEnd —— 在链表末尾插入指定元素</li><li>InsertAtHead —— 在链表头部插入指定元素</li><li>Delete —— 从链表中删除指定元素</li><li>DeleteAtHead —— 删除链表的第一个元素</li><li>Search —— 返回链表中的指定元素</li><li>isEmpty —— 如果链表为空，返回 true</li></ul><p><strong>常问的链表面试问题</strong>：</p><ul><li>翻转列表</li><li>检测链表中的循环</li><li>返回链表中倒数第 n 个节点</li><li>移除链表中的重复值</li></ul><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>图就是一组节点，以网络的形式互相连接。节点也被称为顶点（vertices）。一对（x,y）就叫做一个边，表示顶点 x 和顶点 y 相连。一个边可能包含权重/成本，显示从顶点 x 到 y 所需的成本。</p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/6bb75406664d92441a25b97125a59379.png" alt=""></p><p><strong>图的类型</strong>：</p><ul><li>无向图</li><li>有向图</li></ul><p>在编程语言中，图可以表示为两种形式：</p><ul><li>邻接矩阵</li><li>邻接列表</li></ul><p>常见的图遍历算法：</p><ul><li>广度优先搜索</li><li>深度优先搜索</li></ul><p>常问的图面试问题：</p><ul><li>实现广度优先搜索和深度优先搜索</li><li>检查一个图是否为树</li><li>计算一张图中的边的数量</li><li>找到两个顶点之间的最短路径</li></ul><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树是一种层级数据结构，包含了连接它们的顶点（节点）和边。树和图很相似，但二者有个很大的不同点，即树中没有循环。</p><p>树广泛应用在人工智能和复杂的算法中，为解决各种问题提供高效的存储机制。</p><p>下图是一个简单的树，以及在树型数据结构中所用的基本术语：<br><img src="https://diycode.b0.upaiyun.com/photo/2019/c96436682691e8e6df6636b6ec47510a.png" alt=""></p><p>下面是几种类型的树：</p><ul><li>N 叉树</li><li>平衡树</li><li>二叉树</li><li>二叉搜索树</li><li>平衡二叉树</li><li>红黑树</li><li>2-3 树</li></ul><p>其中，二叉树和二叉搜索树是最常用的树。</p><p><strong>常问的树面试问题</strong>：</p><ul><li>找到一个二叉树的高度</li><li>找到一个二叉搜索树中第 k 个最大值</li><li>找到距离根部“k”个距离的节点</li><li>找到一个二叉树中给定节点的祖先（ancestors）</li></ul><h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><p>字典树，也叫“前缀树”，是一种树形结构，在解决字符串相关问题中非常高效。其提供非常快速的检索功能，常用于搜索字典中的单词，为搜索引擎提供自动搜索建议，甚至能用于IP路由选择。<br>下面展示了“top”“thus”和“their”这三个词是如何存储在字典树中的：</p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/ad4396ac395523f511669768cedb52cd.png" alt=""></p><p>这些单词以从上到下的方式存储，其中绿色节点“p”，“s”和“r”分别表示“top”，“thus”和“their”的末尾。</p><p><strong>常见的字典树面试问题</strong>：</p><ul><li>计算字典树中的总字数</li><li>打印存储在字典树中的所有单词</li><li>使用字典树对数组的元素进行排序</li><li>使用字典树从字典中形成单词</li><li>构建一个T9字典</li></ul><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>#### </p><p>散列是一个用于唯一标识对象并在一些预先计算的唯一索引（称为“密钥”）存储每个对象的过程。因此，对象以“键值”对的形式存储，这些项的集合被称为“字典”。可以使用该键值搜索每个对象。有多种不同的基于哈希的数据结构，但最常用的数据结构是哈希表。</p><p>哈希表通常使用数组实现。</p><p>哈希数据结构的性能取决于以下三个因素：</p><ul><li>哈希函数</li><li>哈希表的大小</li><li>碰撞处理方法</li></ul><p>下图展示了如何在数组中映射哈希。该数组的索引是通过哈希函数计算的。</p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/3d952413d8deb2bb715420c4848c1571.png" alt=""></p><p><strong>常问的哈希面试问题</strong>：</p><ul><li>找到数组中的对称对</li><li>追踪遍历的完整路径</li><li>查看一个数组是否为另一个数组的子集</li><li>检查给定数组是否不相交</li></ul><p>以上就是你在准备编程面试前需要掌握的8种数据结构。</p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第24号问题：Swap Nodes in Pairs</title>
      <link href="/2019/01/27/mei-tian-yi-suan-swap-nodes-in-pairs-15/"/>
      <url>/2019/01/27/mei-tian-yi-suan-swap-nodes-in-pairs-15/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第24号问题：<strong><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">Swap Nodes in Pairs</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p></blockquote><blockquote><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4></blockquote><blockquote><p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. </p><h4 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h4></blockquote><blockquote><ul><li>你的算法只能使用常数的额外空间。    </li><li>你<strong>不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</li></ul></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>该题属于基本的链表操作题。</p><ul><li>设置一个虚拟头结点<code>dummyHead</code></li><li>设置需要交换的两个节点分别为<code>node1</code>、<code>node2</code>，同时设置<code>node2</code>的下一个节点<code>next</code></li></ul><h5 id="在这一轮操作中"><a href="#在这一轮操作中" class="headerlink" title="在这一轮操作中"></a>在这一轮操作中</h5><ul><li>将<code>node2</code>节点的next设置为<code>node1</code>节点</li><li>将<code>node1</code>节点的next设置为<code>next</code>节点</li><li>将<code>dummyHead</code>节点的next设置为<code>node2</code></li><li>结束本轮操作</li></ul><p>接下来的每轮操作都按照上述进行。</p><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkzyet4u8g30qk0evqbw.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><pre><code>// 24. Swap Nodes in Pairs// https://leetcode.com/problems/swap-nodes-in-pairs/description/// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    ListNode* swapPairs(ListNode* head) {        ListNode* dummyHead = new ListNode(0);        dummyHead-&gt;next = head;        ListNode* p = dummyHead;        while(p-&gt;next &amp;&amp; p-&gt;next-&gt;next){            ListNode* node1 = p-&gt;next;            ListNode* node2 = node1-&gt;next;            ListNode* next = node2-&gt;next;            node2-&gt;next = node1;            node1-&gt;next = next;            p-&gt;next = node2;            p = node1;        }        ListNode* retHead = dummyHead-&gt;next;        delete dummyHead;        return retHead;    }};</code></pre><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkzyg6vkrj31ss0u0die.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 节点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 3 号问题：Longest Substring Without Repeating Characters</title>
      <link href="/2019/01/27/mei-tian-yi-suan-longest-substring-without-repeating-characters/"/>
      <url>/2019/01/27/mei-tian-yi-suan-longest-substring-without-repeating-characters/</url>
      
        <content type="html"><![CDATA[<p>leetcode上第3号问题：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">Longest Substring Without Repeating Characters</a></p><blockquote><p>给定一个字符串，找出不含有重复字符的最长子串的长度。</p></blockquote><blockquote><p>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 无重复字符的最长子串是 “abc”，其长度为 3。</p></blockquote><blockquote><p>示例 2:<br>输入: “bbbbb”<br>输出: 1.<br>解释: 无重复字符的最长子串是 “b”，其长度为 1。   </p></blockquote><blockquote><p>示例 3:<br>输入: “pwwkew”<br>输出: 3<br>解释: 无重复字符的最长子串是 “wke”，其长度为 3。<br>请注意，答案必须是一个子串，”pwke” 是一个子序列 而不是子串。</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>建立一个256位大小的整型数组freg，用来建立字符和其出现位置之间的映射。</p><p>维护一个滑动窗口，窗口内的都是没有重复的字符，去尽可能的扩大窗口的大小，窗口不停的向右滑动。</p><ul><li>（1）如果当前遍历到的字符从未出现过，那么直接扩大右边界；</li><li>（2）如果当前遍历到的字符出现过，则缩小窗口（左边索引向右移动），然后继续观察当前遍历到的字符；</li><li>（3）重复（1）（2），直到左边索引无法再移动；</li><li>（4）维护一个结果res，每次用出现过的窗口大小来更新结果res，最后返回res获取结果。</li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzpqfp11g30no0dbjvw.gif" alt="Longest"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 3. Longest Substring Without Repeating Characters// https://leetcode.com/problems/longest-substring-without-repeating-characters/description///// 滑动窗口// 时间复杂度: O(len(s))// 空间复杂度: O(len(charset))class Solution {public:    int lengthOfLongestSubstring(string s) {        int freq[256] = {0};        int l = 0, r = -1; //滑动窗口为s[l...r]        int res = 0;        // 整个循环从 l == 0; r == -1 这个空窗口开始        // 到l == s.size(); r == s.size()-1 这个空窗口截止        // 在每次循环里逐渐改变窗口, 维护freq, 并记录当前窗口中是否找到了一个新的最优值        while(l &lt; s.size()){            if(r + 1 &lt; s.size() &amp;&amp; freq[s[r+1]] == 0){                r++;                freq[s[r]]++;            }else {   //r已经到头 || freq[s[r+1]] == 1                freq[s[l]]--;                l++;            }            res = max(res, r-l+1);        }        return res;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 350 号问题：Intersection of Two Arrays II</title>
      <link href="/2019/01/27/mei-tian-yi-suan-intersection-of-two-arrays-ii/"/>
      <url>/2019/01/27/mei-tian-yi-suan-intersection-of-two-arrays-ii/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzmzoiovj31nk0lq76o.jpg" alt=""></p><p>leetcode上第350号问题：<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">Intersection of Two Arrays II</a></p><blockquote><p>给定两个数组，编写一个函数来计算它们的交集。</p></blockquote><blockquote><p>示例 1:<br>输入: nums1 = [1,2,2,1], nums2 = [2,2]<br>输出: [2,2]</p><p>示例 2:<br>输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>输出: [4,9]</p></blockquote><blockquote><p>说明：</p></blockquote><blockquote><ul><li>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。</li><li>我们可以不考虑输出结果的顺序。</li></ul></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>容器类<a href="https://zh.cppreference.com/w/cpp/container/map" target="_blank" rel="noopener">map</a>的使用。</p><ul><li>遍历num1，通过map容器record存储num1的元素与频率</li><li>遍历num2，在record中查找是否有相同的元素（该元素的存储频率大于0），如果有，用map容器resultVector进行存储，同时该元素的频率减一</li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzmwhgg2g30mi0cqac4.gif" alt=""></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 350. Intersection of Two Arrays II// https://leetcode.com/problems/intersection-of-two-arrays-ii/description/// 时间复杂度: O(nlogn)// 空间复杂度: O(n)class Solution {public:    vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        map&lt;int, int&gt; record;        for(int i = 0 ; i &lt; nums1.size() ; i ++){             record[nums1[i]] += 1;        }        vector&lt;int&gt; resultVector;        for(int i = 0 ; i &lt; nums2.size() ; i ++){            if(record[nums2[i]] &gt; 0){                resultVector.push_back(nums2[i]);                record[nums2[i]] --;            }        }        return resultVector;    }};</code></pre><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzmwek5eg30mi0cqac4.gif" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 219号问题：Contains Duplicate II</title>
      <link href="/2019/01/27/mei-tian-yi-suan-contains-duplicate-ii/"/>
      <url>/2019/01/27/mei-tian-yi-suan-contains-duplicate-ii/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzkn0d3cj316e0jywgm.jpg" alt="Contains Duplicate II"></p><p>leetcode上第219号问题：<a href="https://leetcode.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">Contains Duplicate II</a></p><blockquote><p>给出⼀个整形数组nums和⼀个整数k，是否存在索引i和j，使得nums[i] == nums[j] 且i和j之间的差不超过k</p><p>Example 1:<br>Input: nums = [1,2,3,1], k = 3<br>Output: true. </p><p>Example 2:<br>Input: nums = [1,0,1,1], k = 1<br>Output: true  </p><p>Example 3:<br>Input: nums = [1,2,3,1,2,3], k = 2<br>Output: false</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>考虑用滑动窗口与查找表来解决。</p><ul><li>设置查找表<code>record</code>，用来保存每次遍历时插入的元素，<code>record</code>的最大长度为<code>k</code></li><li>遍历数组<code>nums</code>，每次遍历的时候在<code>record</code>查找是否存在相同的元素，如果存在则返回<code>true</code>，遍历结束</li><li>如果此次遍历在<code>record</code>未查找到，则将该元素插入到<code>record</code>中，而后查看<code>record</code>的长度是否为<code>k + 1</code></li><li>如果此时<code>record</code>的长度是否为<code>k + 1</code>，则删减<code>record</code>的元素，该元素的值为<code>nums[i - k]</code></li><li>如果遍历完整个数组<code>nums</code>未查找到则返回<code>false</code></li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzkiqibwg30qn0er46k.gif" alt="动画演示"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 219. Contains Duplicate II// https://leetcode.com/problems/contains-duplicate-ii/description/// 时间复杂度: O(n)// 空间复杂度: O(k)class Solution {public:    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) {        if(nums.size() &lt;= 1)  return false;        if(k &lt;= 0)  return false;        unordered_set&lt;int&gt; record;        for(int i = 0 ; i &lt; nums.size() ; i ++){            if(record.find(nums[i]) != record.end()){                return true;            }            record.insert(nums[i]);            // 保持record中最多有k个元素            // 因为在下一次循环中会添加一个新元素,使得总共考虑k+1个元素            if(record.size() == k + 1){                record.erase(nums[i - k]);            }        }        return false;    }};</code></pre><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzkgtfhdj31sa0u0acp.jpg" alt="执行结果"></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 查找表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 199 号问题：二叉树的右视图</title>
      <link href="/2019/01/27/mei-tian-yi-suan-binary-tree-right-side-view-29/"/>
      <url>/2019/01/27/mei-tian-yi-suan-binary-tree-right-side-view-29/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第 199 号问题：<strong><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">二叉树的右视图</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p></blockquote><blockquote><p>示例:</p></blockquote><blockquote><p>输入: [1,2,3,null,5,null,4]<br>输出: [1, 3, 4]<br>解释:</p></blockquote><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181115113435.png" alt=""></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>与之前<a href="https://xiaozhuanlan.com/topic/8579460312" target="_blank" rel="noopener">二叉树的层次遍历</a>类似的，该问题需要用到<strong>队列</strong>,</p><ul><li>建立一个queue</li><li>遍历每层的节点时，把下一层的节点都存入到queue中</li><li>每当开始新一层节点的遍历之前，先把新一层最后一个节点值存到结果中</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzk3w6l8g30qg0esn4u.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkzk592lzj30y20u0dh3.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 144 号问题：二叉树的前序遍历</title>
      <link href="/2019/01/27/mei-tian-yi-suan-binary-tree-preorder-traversal-23/"/>
      <url>/2019/01/27/mei-tian-yi-suan-binary-tree-preorder-traversal-23/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第 144 号问题：<strong><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">二叉树的前序遍历</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个二叉树，返回它的 前序 遍历。</p></blockquote><blockquote><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4></blockquote><blockquote><p><strong>输入:</strong> [1,null,2,3]  </p></blockquote><p> <img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181109101353.png" alt="">   </p><blockquote><p><strong>输出:</strong> [1,2,3]<br><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用<strong>栈(Stack)</strong>的思路来处理问题。</p><p>前序遍历的顺序为<strong>根-左-右</strong>，具体算法为：</p><ul><li>把根节点push到栈中</li><li>循环检测栈是否为空，若不空，则取出栈顶元素，保存其值</li><li>看其右子节点是否存在，若存在则push到栈中</li><li>看其左子节点，若存在，则push到栈中。</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzj5lp54g30qp0ey48h.gif" alt="动画演示"></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkzj84jmxj30y20u0qc5.jpg" alt="参考代码"></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 102 号问题：二叉树的层次遍历</title>
      <link href="/2019/01/27/mei-tian-yi-suan-binary-tree-level-order-traversal-26/"/>
      <url>/2019/01/27/mei-tian-yi-suan-binary-tree-level-order-traversal-26/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第102 号问题：<strong><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层次遍历</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p></blockquote><blockquote><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p></blockquote><blockquote><p> <img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181112084143.png" alt=""></p><p>返回其层次遍历结果：</p></blockquote><blockquote><p>[<br>   [3],<br>   [9,20],<br>   [15,7]<br>]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>该问题需要用到<strong>队列</strong></p><ul><li>建立一个queue</li><li>先把根节点放进去，这时候找根节点的左右两个子节点</li><li>去掉根节点，此时queue里的元素就是下一层的所有节点</li><li>用for循环遍历，将结果存到一个一维向量里</li><li>遍历完之后再把这个一维向量存到二维向量里</li><li>以此类推，可以完成层序遍历</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzexxrigg30qp0ey12m.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzgwok70j30u0107whf.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 145 号问题：二叉树的后序遍历</title>
      <link href="/2019/01/27/mei-tian-yi-suan-binary-tree-postorder-traversal-25/"/>
      <url>/2019/01/27/mei-tian-yi-suan-binary-tree-postorder-traversal-25/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第145 号问题：<strong><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/description/" target="_blank" rel="noopener">二叉树的后序遍历</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个二叉树，返回它的 后序 遍历。</p></blockquote><blockquote><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4></blockquote><blockquote><p><strong>输入:</strong> [1,null,2,3]  </p></blockquote><p> <img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181109101353.png" alt="">   </p><blockquote><p><strong>输出:</strong> [3,2,1]<br><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用<strong>栈(Stack)</strong>的思路来处理问题。</p><p>后序遍历的顺序为<strong>左-右-根</strong>，具体算法为：</p><ul><li>先将根结点压入栈，然后定义一个辅助结点head</li><li>while循环的条件是栈不为空</li><li>在循环中，首先将栈顶结点t取出来</li><li>如果栈顶结点没有左右子结点，或者其左子结点是head，或者其右子结点是head的情况下。我们将栈顶结点值加入结果res中，并将栈顶元素移出栈，然后将head指向栈顶元素</li><li>否则的话就看如果右子结点不为空，将其加入栈</li><li>再看左子结点不为空的话，就加入栈</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong><br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzifir92g30qp0ey49p.gif" alt="后序遍历"></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkzigsvjaj31bf0u00yz.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 94 号问题：二叉树的中序遍历</title>
      <link href="/2019/01/27/mei-tian-yi-suan-binary-tree-inorder-traversal-24/"/>
      <url>/2019/01/27/mei-tian-yi-suan-binary-tree-inorder-traversal-24/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第 94 号问题：<strong><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个二叉树，返回它的 中序 遍历。</p></blockquote><blockquote><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4></blockquote><blockquote><p><strong>输入:</strong> [1,null,2,3]  </p></blockquote><p> <img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181109101353.png" alt="">   </p><blockquote><p><strong>输出:</strong> [1,3,2]<br><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用<strong>栈(Stack)</strong>的思路来处理问题。</p><p>中序遍历的顺序为<strong>左-根-右</strong>，具体算法为：</p><ul><li>从根节点开始，先将根节点压入栈</li><li>然后再将其所有左子结点压入栈，取出栈顶节点，保存节点值</li><li>再将当前指针移到其右子节点上，若存在右子节点，则在下次循环时又可将其所有左子结点压入栈中</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkxkmfacog30qp0eywoh.gif" alt="动画演示"></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkxkq7y97j30u00u17db.jpg" alt="参考代码"></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 中序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 2 号问题：两个数字相加</title>
      <link href="/2019/01/27/mei-tian-yi-suan-add-two-numbers-31/"/>
      <url>/2019/01/27/mei-tian-yi-suan-add-two-numbers-31/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第 2 号问题：<strong><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">两个数字相加</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p></blockquote><blockquote><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p></blockquote><blockquote><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5></blockquote><blockquote><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>设立一个表示进位的变量<code>carried</code>，建立一个新链表，把输入的两个链表从头往后同时处理，每两个相加，将结果加上<code>carried</code>后的值作为一个新节点到新链表后面。</p><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkxjfcatug30qh0eon5c.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkxjhpat9j30ub0u0n4r.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 上第 26 号问题：删除排序数组中的重复项</title>
      <link href="/2019/01/27/mei-tian-yi-suan-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang-30/"/>
      <url>/2019/01/27/mei-tian-yi-suan-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang-30/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第26 号问题：<strong><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">删除排序数组中的重复项</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><blockquote><p>给定数组 nums = [1,1,2], </p></blockquote><blockquote><p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p></blockquote><blockquote><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><blockquote><p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p></blockquote><blockquote><p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p></blockquote><blockquote><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用快慢指针来记录遍历的坐标。</p><ul><li>开始时这两个指针都指向第一个数字</li><li>如果两个指针指的数字相同，则快指针向前走一步</li><li>如果不同，则两个指针都向前走一步</li><li>当快指针走完整个数组后，慢指针当前的坐标加1就是数组中不同数字的个数</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkxjo8a76g30qg0esju1.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkxjmqk58j30xo0tktci.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 上第 454 号问题：4Sum II</title>
      <link href="/2019/01/27/mei-tian-yi-suan-4sum-ii-di-jiu-pian/"/>
      <url>/2019/01/27/mei-tian-yi-suan-4sum-ii-di-jiu-pian/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 上第 454 号问题：<strong><a href="https://leetcode-cn.com/problems/4sum-ii/" target="_blank" rel="noopener">4Sum II</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] &gt; + B[j] + C[k] + D[l] = 0。</p></blockquote><blockquote><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。</p></blockquote><blockquote><p><em>例如:</em></p></blockquote><blockquote><p>输入:<br>A = [ 1, 2]<br>B = [-2,-1]<br>C = [-1, 2]<br>D = [ 0, 2] </p></blockquote><blockquote><p>输出:<br>2 </p><p>解释:<br>两个元组如下:       </p><ol><li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0  </li><li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</li></ol></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>与<a href="https://xiaozhuanlan.com/topic/7923618450" target="_blank" rel="noopener">Two Sum</a>类似，需要用哈希表来解决问题。</p><ul><li>把A和B的两两之和都求出来，在哈希表中建立两数之和与其出现次数之间的映射</li><li>遍历C和D中任意两个数之和，只要看哈希表存不存在这两数之和的相反数就行了</li></ul><p>##动画演示</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkxffnjo7g30np0dbadt.gif" alt="4Sum II"></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><pre><code>// 454. 4Sum II// https://leetcode.com/problems/4sum-ii/description/// 时间复杂度: O(n^2)// 空间复杂度: O(n^2)class Solution {public:    int fourSumCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) {        unordered_map&lt;int,int&gt; hashtable;        for(int i = 0 ; i &lt; A.size() ; i ++){            for(int j = 0 ; j &lt; B.size() ; j ++){                 hashtable[A[i]+B[j]] += 1;            }        }        int res = 0;        for(int i = 0 ; i &lt; C.size() ; i ++){            for(int j = 0 ; j &lt; D.size() ; j ++){                if(hashtable.find(-C[i]-D[j]) != hashtable.end()){                    res += hashtable[-C[i]-D[j]];                }            }        }        return res;    }};</code></pre><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkxfhd78yj313c0i5wfd.jpg" alt="执行结果"></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 447 号问题：Number of Boomerangs</title>
      <link href="/2019/01/27/mei-tian-yi-suan-number-of-boomerangs/"/>
      <url>/2019/01/27/mei-tian-yi-suan-number-of-boomerangs/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第 447 号问题：<a href="https://leetcode-cn.com/problems/number-of-boomerangs/" target="_blank" rel="noopener">Number of Boomerangs</a></p><blockquote><p>给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 (i, j, k) ，其中 i 和 j 之间的距离和 &gt; i 和 k 之间的距离相等（需要考虑元组的顺序）。</p></blockquote><blockquote><p>找到所有回旋镖的数量。你可以假设 n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。</p></blockquote><blockquote><p>示例:</p></blockquote><blockquote><p>输入:<br>[[0,0],[1,0],[2,0]]   </p></blockquote><blockquote><p>输出:<br>2</p></blockquote><blockquote><p>解释:<br>两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>n最大为500，可以使用时间复杂度为 O(n^2)的算法。</p><ul><li>遍历所有的点，让每个点作为一个锚点</li><li>然后再遍历其他的点，统计和锚点距离相等的点有多少个</li><li>然后分别带入n(n-1)计算结果并累加到res中</li></ul><h5 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h5><h6 id="Tip1"><a href="#Tip1" class="headerlink" title="Tip1"></a>Tip1</h6><ul><li>如果有一个点a，还有两个点b和c，如果ab和ac之间的距离相等，那么就有两种排列方法abc和acb；</li><li>如果有三个点b，c，d都分别和a之间的距离相等，那么有六种排列方法，abc, acb, acd, adc, abd, adb；</li><li>如果有n个点和点a距离相等，那么排列方式为n(n-1)。</li></ul><h6 id="Tip2"><a href="#Tip2" class="headerlink" title="Tip2"></a>Tip2</h6><ul><li>计算距离时不进行开根运算, 以保证精度；</li><li>只有当n大于等于2时，res值才会真正增加，因为当n=1时，增加量为<code>1*(1-1)=0</code>。</li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkx8sx3zlg30qn0estfw.gif" alt=""></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 447. Number of Boomerangs// https://leetcode.com/problems/number-of-boomerangs/description/// 时间复杂度: O(n^2)// 空间复杂度: O(n)class Solution {public:    int numberOfBoomerangs(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) {        int res = 0;        for( int i = 0 ; i &lt; points.size() ; i ++ ){            // record中存储 点i 到所有其他点的距离出现的频次            unordered_map&lt;int, int&gt; record;            for(int j = 0 ; j &lt; points.size() ; j ++){                if(j != i){                    // 计算距离时不进行开根运算, 以保证精度                    record[dis(points[i], points[j])] += 1;                }            }            for(unordered_map&lt;int, int&gt;::iterator iter = record.begin() ; iter != record.end() ; iter ++){                res += (iter-&gt;second) * (iter-&gt;second - 1);            }        }        return res;    }private:    int dis(const pair&lt;int,int&gt; &amp;pa, const pair&lt;int,int&gt; &amp;pb){        return (pa.first - pb.first) * (pa.first - pb.first) +               (pa.second - pb.second) * (pa.second - pb.second);    }};</code></pre><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181030113403.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 元祖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 103 号问题：二叉树的锯齿形层次遍历</title>
      <link href="/2019/01/27/mei-tian-yi-suan-binary-tree-zigzag-level-order-traversal-28/"/>
      <url>/2019/01/27/mei-tian-yi-suan-binary-tree-zigzag-level-order-traversal-28/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第103 号问题：<strong><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">二叉树的锯齿形层次遍历</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p></blockquote><blockquote><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p></blockquote><blockquote><p> <img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181112084143.png" alt=""></p><p>返回其层次遍历结果：</p></blockquote><blockquote><p>[<br>   [3],<br>   [20,9],<br>   [15,7]<br>]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>该问题需要用到<strong>队列</strong>，与之前的<a href="https://xiaozhuanlan.com/topic/8579460312" target="_blank" rel="noopener">二叉树的层次遍历</a>类似，不同点在于在偶数层需要翻转一下。</p><ul><li>建立一个queue</li><li>先把根节点放进去，这时候找根节点的左右两个子节点</li><li>去掉根节点，此时queue里的元素就是下一层的所有节点</li><li>循环遍历，将结果存到一个一维向量里</li><li>遍历完之后再把这个一维向量存到二维向量里</li><li>如果该层为偶数层，则reverse翻转一下</li><li>以此类推，可以完成层序遍历</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkx5g05uxg30qg0esgy0.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkx56go9ij30xa0u0wgi.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建一个酷炫免费的个人博客</title>
      <link href="/2019/01/26/xin-shou-xiang-cong-ling-kai-shi-da-jian-yi-ge-ku-xuan-mian-fei-de-ge-ren-bo-ke/"/>
      <url>/2019/01/26/xin-shou-xiang-cong-ling-kai-shi-da-jian-yi-ge-ku-xuan-mian-fei-de-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="【新手向】从零开始搭建一个酷炫免费的个人博客"><a href="#【新手向】从零开始搭建一个酷炫免费的个人博客" class="headerlink" title="【新手向】从零开始搭建一个酷炫免费的个人博客"></a>【新手向】从零开始搭建一个酷炫免费的个人博客</h1><p>由于公众号的文章不易后续整理阅读，于是小吴昨天上午花了半个小时使用 GitHub + Hexo 搭建了一下个人博客，打算将公众号的文章搬过去，支持关键字搜索、分类标签功能。效果是下面这样子的👇</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk130ii6qg313l0ixx6q.gif" alt=""></p><p>结果后台好多小伙伴挺好奇博客是怎么搭建的，实际上这个挺简单的，小吴就从零开始分享一波如何搭建一个酷炫免费的个人博客吧，如果已经有博客的小伙伴可以留言一波网站地址：）</p><h3 id="GitHub创建个人仓库"><a href="#GitHub创建个人仓库" class="headerlink" title="GitHub创建个人仓库"></a>GitHub创建个人仓库</h3><p>登录到 GitHub ，如果没有 GitHub 帐号，请使用你的邮箱注册 GitHub 帐号：<a href="https://github.com/join?source=header-home">https://github.com/join?source=header-home</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk21xjx8gj31420myn1f.jpg" alt="注册"></p><p>登录成功之后，点击 GitHub 中的 New repository 创建新仓库，仓库名应该为：<strong>用户名</strong> .github.io 。这里<strong>用户名</strong>使用你的 GitHub 帐号名称代替，这是固定写法。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzk2601f8kg313l0ixqca.gif" alt="创建新仓库"></p><p>ps: 因为我已经注册了同名仓库，因此第二次创建时会报错。</p><p>我的仓库名为👇：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk29gwq48j30fu03igls.jpg" alt="仓库名"></p><h3 id="Git管理"><a href="#Git管理" class="headerlink" title="Git管理"></a>Git管理</h3><p>Git 是目前世界上最先进的分布式版本控制系统（没有之一）。这是使用 Git 的目的是为了将我们的网站从本地提交上服务器（GitHub）上面去。我认为 Git 操作是程序员应该具备的一个基本操作，具体的 Git 操作细节可以查看廖雪峰的教程，讲的十分详细 <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk2hsewy8j313r0k0n5i.jpg" alt=""></p><p>安装好 Git 后，只需要进行下面的配置即可。</p><h4 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h4><p>在终端进行操作，设置 user.name 和 user.email 配置信息，我这里设置为全局。</p><pre class=" language-java"><code class="language-java">git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>name <span class="token string">"你的GitHub用户名"</span>git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>email <span class="token string">"你的GitHub注册邮箱"</span></code></pre><h4 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h4><p>通过注册的邮箱生成 ssh 密钥文件：</p><pre class=" language-bash"><code class="language-bash">ssh-keygen -t rsa -C <span class="token string">"你的GitHub注册邮箱"</span></code></pre><p>然后直接三个回车即可，默认不需要设置密码。最后得到了两个文件：<code>id_rsa</code>和<code>id_rsa.pub</code>。</p><h4 id="拷贝密钥"><a href="#拷贝密钥" class="headerlink" title="拷贝密钥"></a>拷贝密钥</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk2vog35vj30mw0f2mzq.jpg" alt="拷贝密钥"></p><p>打开 <code>id_rsa.pub 文件</code>，将里面的内容全部复制。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzk2xjwnthj30tv0b5dh4.jpg" alt="内容全部复制"></p><h4 id="粘贴到GitHub"><a href="#粘贴到GitHub" class="headerlink" title="粘贴到GitHub"></a>粘贴到GitHub</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzk36z40lzj313s0k1n08.jpg" alt="GitHub SSh"></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk376rh7yj313r0ketbj.jpg" alt="添加新的 SSH"></p><h4 id="测试GitHub-SSH"><a href="#测试GitHub-SSH" class="headerlink" title="测试GitHub SSH"></a>测试GitHub SSH</h4><p>添加好 <code>SSH Key</code>后，进行测试。</p><pre><code>ssh -T git@github.com</code></pre><p>你将会看到：</p><pre><code>The authenticity of host &#39;github.com (207.97.227.239)&#39; can&#39;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)?</code></pre><p>选择 <code>yes</code></p><pre><code>Hi MisterBooo! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk3bfd4wzj30i10213yk.jpg" alt="ssh -T"></p><p>如果看到<code>Hi</code>后面是你的用户名，就说明成功了。</p><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>Hexo 基于 Node.js，因此需要先安装 Node.js，你可以在这里进行对应电脑版本的下载：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzk3ecq45aj313u0jkju0.jpg" alt="Node.js下载"></p><p>你也可以通过命令行进行安装：</p><p>cURL:</p><pre><code>$ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</code></pre><p>Wget:</p><pre><code>$ wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</code></pre><p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p><pre><code>$ nvm install stable</code></pre><h3 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><pre><code>$ npm install -g hexo-cli</code></pre><h3 id="Hexo使用"><a href="#Hexo使用" class="headerlink" title="Hexo使用"></a>Hexo使用</h3><p>安装好 Hexo 后，马上就能使用了。首先初始化博客，输入：</p><pre><code>$ hexo init myBlog</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk3pvt34mj319f0u0qcz.jpg" alt=""></p><p>接下来，进入文件夹 <code>myBlog</code>,输入</p><pre><code>$ hexo s</code></pre><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk3s50l94j30hy054t96.jpg" alt=""></p><p>然后，打开浏览器输入地址：</p><pre><code>localhost:4000</code></pre><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk3te442qj313t0n1gxs.jpg" alt="hexo网站"></p><p>执行到这里事实上博客就已经搭建好了，接下来就是去完善它。</p><p>注意：下面的命令都是在 <code>myBlog</code>文件里进行操作的。</p><h3 id="添加文章"><a href="#添加文章" class="headerlink" title="添加文章"></a>添加文章</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk7dls02rj31840kiaco.jpg" alt="添加文章"></p><h4 id="1-直接导入文章"><a href="#1-直接导入文章" class="headerlink" title="1.直接导入文章"></a>1.直接导入文章</h4><p>你可以将你平时写的文章直接导入到 <code>_posts</code>  文件夹里，注意文章类型得是 <code>md</code>格式。</p><h4 id="2-写新文章"><a href="#2-写新文章" class="headerlink" title="2.写新文章"></a>2.写新文章</h4><p>你可以执行下列命令来创建一篇新文章。</p><pre><code>$ hexo new [layout] &lt;title&gt;</code></pre><p>你可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk7hoiy3ij30z6042q3w.jpg" alt="写新文章"></p><p>这样在 <code>_posts</code>  文件夹里也生成了一篇新的文章。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzk7j5ffx5j316c0ewmzp.jpg" alt="新的文章"></p><h3 id="生成网页"><a href="#生成网页" class="headerlink" title="生成网页"></a>生成网页</h3><p>使用 Hexo 生成静态文件快速而且简单。</p><pre><code>$ hexo generate</code></pre><p>你也可以简写成</p><pre><code>$ hexo g</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk7n3i1jyj318d0u0wpf.jpg" alt="生成文章"></p><h3 id="启动服务预览文章"><a href="#启动服务预览文章" class="headerlink" title="启动服务预览文章"></a>启动服务预览文章</h3><p>输入以下命令以启动服务器，你的网站会在 <code>http://localhost:4000</code> 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，无须重启服务器。</p><pre><code>$ hexo server</code></pre><p>你也可以简写成</p><pre><code>$ hexo s</code></pre><p>如果你想要更改端口，或是在执行时遇到了 <code>EADDRINUSE</code> 错误，可以在执行时使用 <code>-p</code> 选项指定其他端口，如下：</p><pre><code>$ hexo server -p 5000</code></pre><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzk7pthinwj315606kdhh.jpg" alt="查看文章"></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzk7rs1dp8j31iy0u0e81.jpg" alt="网站"></p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><pre><code>hexo new &quot;我的博客文章&quot; #新建文章</code></pre><pre><code>hexo generate #生成网页</code></pre><pre><code>hexo server #启动服务预览</code></pre><p>这三个命令依次就是新建一篇博客文章、生成网页、在本地预览的操作。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>Hexo 提供了快速方便的一键部署功能，只需一条命令就能将网站部署到服务器上。</p><pre><code>$ hexo deploy</code></pre><p>你也可以简写成</p><pre><code>$ hexo d</code></pre><p>在开始之前，必须先在 <code>_config.yml</code> 中修改参数，一个正确的部署配置中至少要有 <code>type</code> 参数，例如：</p><pre><code>deploy:  type: git</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk7w0wzlyj30mk0eetae.jpg" alt="config"></p><p>在<code>_config.yml</code>中进行修改。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzk7xrf4smj30y40u00yx.jpg" alt=""></p><p>这一步的目的是将 Hexo 与 GitHub 进行关联。</p><p>配置好后通过</p><pre><code>$ hexo d</code></pre><p>命令，稍等片刻，网站就已经部署好了，可以在浏览器输入<code>你的GitHub名称.github.io</code>，这样一个免费的博客就已经搭建好了。</p><h3 id="Hexo-主题"><a href="#Hexo-主题" class="headerlink" title="Hexo 主题"></a>Hexo 主题</h3><p>hexo 默认的主题可能显得有点呆板，你可以在 <a href="https://hexo.io/themes/index.html" target="_blank" rel="noopener">https://hexo.io/themes/index.html</a>进行主题的挑选更换。将下好的主题安放在<code>themes</code>文件夹内，同时在<code>_config.yml</code>中进行主题修改就好了。</p><p>经过一个小时的主题筛选，我选择了<code>hexo-theme-matery</code> 这款主题。通过<a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/" target="_blank" rel="noopener">https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/</a>文档说明，经过简单的配置，效果就出来了！</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzk9f1968uj30yk0jmtb2.jpg" alt=""></p><p>一般大佬们提供的主题都会提供文档说明，按照说明进行简单的设置就能拥有一个酷炫的页面了。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk130ii6qg313l0ixx6q.gif" alt=""></p><h3 id="Markdown-写作"><a href="#Markdown-写作" class="headerlink" title="Markdown 写作"></a>Markdown 写作</h3><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><p>世面上支持 Markdown 语法的编辑器不胜枚举，选择起来十分困难，小吴在这里推荐 Typora 这款 Markdown 写作软件。</p><p> Typora 是一款免费的 MD 编辑器，它是优雅简洁与强大开放的完美结合体。</p><p>官网直达 <a href="https://typora.io" target="_blank" rel="noopener">https://typora.io</a></p><h4 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h4><p>选择 Typora 一个最主要的原因是它对图片的良好支持。</p><p>在 Mac 上安装好 iPic 后 ，并在设置中将图片插入修改为 通过 iPic 上传 ，快捷键是 control + command + i ，就可以十分快捷优雅地完成图片插入。强调一点：图床使用默认的微博图床即可，建议不要折腾。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzk9r3q6toj30s40rwh1u.jpg" alt=""></p><p>这样，每次写作时，将图片拖入到 Typora 里，图片就能自动上传到图床上。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>申请 GitHub 账号</p></li><li><p>在 GitHub 上创建仓库</p></li><li><p>配备 Git ，同时将 SSH Key 提交到 GitHub 上</p></li><li><p>安装 Node.js</p></li><li><p>安装 Hexo</p></li><li><p>安装 Hexo 主题</p></li><li><p>使用 Markdown 软件写文章</p></li></ul><p>希望这篇文章能帮到想写博客却还没付诸行动的人，毕竟拥有一个免费且酷炫的博客还是挺简单还挺好玩的：）</p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新手 </tag>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode上第 75 号问题： Two Sum II</title>
      <link href="/2019/01/26/75/"/>
      <url>/2019/01/26/75/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/10/29/166bdc86b1885e65?w=2294&amp;h=1412&amp;f=png&amp;s=261824" alt=""><br>leetcode上第75号问题：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">Two Sum II</a></p><blockquote><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p></blockquote><blockquote><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p></blockquote><blockquote><p>说明:</p></blockquote><blockquote><ul><li>返回的下标值（index1 和 index2）不是从零开始的。</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ul></blockquote><blockquote><p>示例:</p></blockquote><blockquote><p>输入: numbers = [2, 7, 11, 15], target = 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>初始化左指针left指向数组起始，初始化右指针right指向数组结尾。</p><p>根据<strong>已排序</strong>这个特性，</p><ul><li><p>（1）如果numbers[left]与numbers[right]的和tmp小于target，说明应该增加tmp,因此left右移指向一个较大的值。</p></li><li><p>（2）如果tmp大于target，说明应该减小tmp,因此right左移指向一个较小的值。</p></li><li><p>（3）tmp等于target，则找到，返回left+1和right+1。（注意以1为起始下标）</p></li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://user-gold-cdn.xitu.io/2018/10/29/166bdc5dfb63ea8d?w=853&amp;h=457&amp;f=gif&amp;s=69203" alt=""></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对撞指针</span><span class="token comment" spellcheck="true">// 时间复杂度: O(n)</span><span class="token comment" spellcheck="true">// 空间复杂度: O(1)</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">twoSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> numbers<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> res<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> res<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span>                l <span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token comment" spellcheck="true">// numbers[l] + numbers[r] > target</span>                r <span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode上第 283 号问题： Move Zeros</title>
      <link href="/2019/01/26/283/"/>
      <url>/2019/01/26/283/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669facb3a2bb86e?w=1240&amp;h=574&amp;f=png&amp;s=228428" alt="Move Zeros"><br>leetcode上第283号问题：<a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">Move Zeros</a></p><blockquote><p>给定一个数组nums，写一个函数，将数组中所有的0挪到数组的末尾，⽽维持其他所有非0元素的相对位置。<br>举例: nums = [0, 1, 0, 3, 12]，函数运⾏后结果为[1, 3, 12, 0, 0]</p></blockquote><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>思路：创建一个临时数组nonZeroElements，遍历nums，将nums中非0元素赋值到nonZeroElements中，而后按顺序将nonZeroElements赋值到nums上，未遍历的元素置0；</p><p>动画如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669facb3a048c12?w=420&amp;h=203&amp;f=gif&amp;s=60758" alt="image"></p><p>代码如下：</p><pre><code>// 时间复杂度: O(n)// 空间复杂度: O(n)class Solution {public:    void moveZeroes(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; nonZeroElements;        // 将vec中所有非0元素放入nonZeroElements中        for(int i = 0 ; i &lt; nums.size() ; i ++)            if(nums[i])                nonZeroElements.push_back(nums[i]);        // 将nonZeroElements中的所有元素依次放入到nums开始的位置        for(int i = 0 ; i &lt; nonZeroElements.size() ; i ++)            nums[i] = nonZeroElements[i];        // 将nums剩余的位置放置为0        for(int i = nonZeroElements.size() ; i &lt; nums.size() ; i ++)            nums[i] = 0;    }};</code></pre><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>思路：设定一个临时变量k=0，遍历数组nums，将非零元素移动到nums[k]位置，同时k++，而后将【k,….nums.size()】中的元素置零。</p><p>动画如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669facb3a3f2742?w=744&amp;h=418&amp;f=gif&amp;s=104124" alt="image"></p><p>代码如下：</p><pre><code>// 原地(in place)解决该问题// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    void moveZeroes(vector&lt;int&gt;&amp; nums) {        int k = 0; // nums中, [0...k)的元素均为非0元素        // 遍历到第i个元素后,保证[0...i]中所有非0元素        // 都按照顺序排列在[0...k)中        for(int i = 0 ; i &lt; nums.size() ; i ++)            if(nums[i])                nums[k++] = nums[i];        // 将nums剩余的位置放置为0        for(int i = k ; i &lt; nums.size() ; i ++)            nums[i] = 0;    }};</code></pre><h3 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h3><p>思路：设定一个临时变量k=0，遍历数组nums，将非零元素与之前的零元素进行交换，维护变量k的值。</p><p>动画如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669facb3a1f570c?w=744&amp;h=418&amp;f=gif&amp;s=92514" alt="image"></p><p>代码如下：</p><pre><code>// 原地(in place)解决该问题// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    void moveZeroes(vector&lt;int&gt;&amp; nums) {        int k = 0; // nums中, [0...k)的元素均为非0元素        // 遍历到第i个元素后,保证[0...i]中所有非0元素        // 都按照顺序排列在[0...k)中        // 同时, [k...i] 为 0        for(int i = 0 ; i &lt; nums.size() ; i ++)            if(nums[i])                if(k != i)                    swap(nums[k++] , nums[i]);                else                    k ++;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示桶排序</title>
      <link href="/2019/01/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-tong-pai-xu/"/>
      <url>/2019/01/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-tong-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解桶排序"><a href="#【图解数据结构】-一组动画彻底理解桶排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解桶排序"></a>【图解数据结构】 一组动画彻底理解桶排序</h1><p>由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 —–《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序(Bucket sort)是一种基于计数的排序算法（<strong>计数排序</strong>可参考上节的内容），工作的原理是将数据分到有限数量的桶子里，然后每个桶再分别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>设置固定数量的空桶。</p></li><li><p>把数据放到对应的桶中。</p></li><li><p>对每个不为空的桶中数据进行排序。</p></li><li><p>拼接不为空的桶中数据，得到结果。</p></li></ol><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/29/1675ceff66c00fe7?w=955&amp;h=539&amp;f=gif&amp;s=1026397" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，设置固定数量的空桶，在这里为了方便演示，设置桶的数量为 5 个空桶</p></li><li><p>遍历整个数列，找到最大值为 56 ，最小值为 2 ，每个桶的范围为 （ 56 - 2 + 1 ）/ 5 = 11</p></li><li><p>再次遍历整个数列，按照公式 floor((数字 – 最小值) / 11) 将数字放到对应的桶中</p></li><li><p>比如，数字 7 代入公式 floor((7 – 2) / 11) = 0 放入 0 号桶</p></li><li><p>数字 12 代入公式 floor((12 – 2) / 11) = 0 放入 0 号桶</p></li><li><p>数字 56 代入公式 floor((56 – 2) / 11) = 4 放入 4 号桶</p></li><li><p>当向同一个索引的桶，第二次插入数据时，判断桶中已存在的数字与新插入数字的大小，按照左到右，从小到大的顺序插入（可以使用前面讲解的<strong>插入排序</strong>）实现</p></li><li><p>比如，插入数字 19 时， 1 号桶中已经有数字 23 ，在这里使用插入排序，让 19 排在 23 前面</p></li><li><p>遍历完整个数列后，合并非空的桶，按从左到右的顺序合并0，1，2，3，4桶。</p></li><li><p>这样就完成了 <strong>桶排序</strong></p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/29/1675ceff669fd15d?w=1864&amp;h=2122&amp;f=png&amp;s=80844" alt=""></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/29/1675ceff66c62d33?w=2016&amp;h=3272&amp;f=png&amp;s=170854" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/29/1675ceff66b31247?w=2048&amp;h=2260&amp;f=png&amp;s=131496" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 桶排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示快速排序</title>
      <link href="/2019/01/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-kuai-su-pai-xu/"/>
      <url>/2019/01/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-kuai-su-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解快速排序"><a href="#【图解数据结构】-一组动画彻底理解快速排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解快速排序"></a>【图解数据结构】 一组动画彻底理解快速排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 —–《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>从数列中挑出一个元素，称为 “基准”（pivot）;</p></li><li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p></li></ol><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e00a0d10d84d?w=950&amp;h=534&amp;f=gif&amp;s=492246" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，操作数列中的所有数字</p></li><li><p>在所有数字中选择一个数字作为排序的基准（pivot）, pivot 通常是随机选择的，在这里为了演示方便，我们选择最右边的数字作为 pivot</p></li><li><p>选取好 pivot 后，在操作数列中选择最左边的数字标记为 左标记 ，最右边的数字标记为 右标记</p></li><li><p>将左边的标记向右移动</p></li><li><p>当 左标记 达到超过 pivot 的数字时，停止移动</p></li><li><p>在这里，8 &gt; 6 ,所以停止移动</p></li><li><p>然后将右边的标记向左移动</p></li><li><p>当 右标记 达到小于 pivot 的数字时，停止移动</p></li><li><p>在这里，4 &gt; 6 ,所以停止移动</p></li><li><p>当左右标记停止时，更改标记的数字</p></li><li><p>因此，左标记 的作用是找到一个大于 pivot 的数字，右标记 的作用是找到一个小于 pivot 的数字</p></li><li><p>通过交换数字，可以在数列的左边收集小于 pivot 的数字集合，右边收集大于 pivot 的数字集合</p></li><li><p>交换之后，继续移动 左标记</p></li><li><p>在这里，9 &gt; 6 ,所以停止移动</p></li><li><p>然后将右边的标记向左移动</p></li><li><p>当 右标记 碰撞到 左标记 时也停止移动</p></li><li><p>如果左右侧的标记停止时，并且都在同一个位置，将这个数字和 pivot 的数字交换</p></li><li><p>这就完成了第一次操作</p></li><li><p>小于 6 的都在 6 的左侧，大于 6 的都在 6 的右侧</p></li><li><p>然后递归对这分成的两部分都执行同样的操作</p></li><li><p>完成 快速排序</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e00a0dc023d8?w=1392&amp;h=1524&amp;f=png&amp;s=68959" alt="C++代码实现"></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e00a0cb5d352?w=1668&amp;h=2214&amp;f=png&amp;s=109067" alt="Java代码实现"></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e00a0c058ac5?w=1756&amp;h=1432&amp;f=png&amp;s=74882" alt="Python代码实现"></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e00a0e6e21b7?w=1572&amp;h=2950&amp;f=png&amp;s=139434" alt="JavaScript代码实现"></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示基数排序</title>
      <link href="/2019/01/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-ji-shu-pai-xu/"/>
      <url>/2019/01/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-ji-shu-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解基数排序"><a href="#【图解数据结构】-一组动画彻底理解基数排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解基数排序"></a>【图解数据结构】 一组动画彻底理解基数排序</h1><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序 (Radix Sort) 是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。基数排序的发明可以追溯到 1887 年赫尔曼·何乐礼在打孔卡片制表机 (Tabulation Machine)上的贡献。</p><p>基数排序法会使用到桶 (Bucket)，顾名思义，通过将要比较的位（个位、十位、百位…），将要排序的元素分配至 0~9 个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其它的比较性排序法。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零</p></li><li><p>从最低位开始，依次进行一次排序</p></li><li><p>从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列</p></li></ol><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^<br><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181128114235.gif" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>基数排序的方式可以采用 LSD (Least sgnificant digital) 或 MSD (Most sgnificant digital)</p></li><li><p>在本例中使用的是 <strong>LSD</strong></p></li><li><p>首先创建编号 0 ， 1 ，2 ，3 ，4 ，5 ， 6 ，7 ，8 ，9 这 10 个桶 </p></li><li><p>遍历整个数列，查看数字的个位数，按照先后顺序存放在对应编号的桶中</p></li><li><p>比如 321 个位数 为 1 ，存放在编号 1 桶中</p></li><li><p>数字 1 个位数 为 1 ，存放在编号 1 桶中，同时存放在 321 上面 </p></li><li><p>遍历完整个数列的个位数，将数字存放在桶中后，按照编号顺序取出数字，先放入桶中的数字先取出</p></li><li><p>然后依次遍历整个数列的十位数，按照上述个位数的操作整理数列</p></li><li><p>依次遍历整个数列的百位数，按照上述个位数的操作整理数列</p></li><li><p>这样就完成了 <strong>基数排序</strong></p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181128123735.png" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181128123743.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基数排序 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示选择排序</title>
      <link href="/2019/01/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-yan-shi-xuan-ze-pai-xu/"/>
      <url>/2019/01/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-yan-shi-xuan-ze-pai-xu/</url>
      
        <content type="html"><![CDATA[<p># </p><h1 id="【图解数据结构】-一组动画演示选择排序"><a href="#【图解数据结构】-一组动画演示选择排序" class="headerlink" title="【图解数据结构】 一组动画演示选择排序"></a>【图解数据结构】 一组动画演示选择排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 —–《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</p></li><li><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p></li><li><p>重复第二步，直到所有元素均排序完毕。</p></li></ol><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/16738f0f5824e2d8?w=955&amp;h=538&amp;f=gif&amp;s=346690" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>线性搜索数列并找到最小值，此时找到了为 2</p></li><li><p>将最小值替换为数列中左端的数字，即将 2 与 4 进行交换</p></li><li><p>此时 2 已经排序好</p></li><li><p>继续线性搜索剩余数列找到最小值，此时找到了 3</p></li><li><p>将最小值替换为数列中左端的数字，即将 3 与 4 进行交换</p></li><li><p>此时 2 与 3 已经排序好</p></li><li><p>继续线性搜索剩余数列找到最小值，此时找到了 4</p></li><li><p>如果最小值已经在左端，那么不执行任何操作，所以此时不做任何处理</p></li><li><p>此时 2 、 3  、 4 已经排序好</p></li><li><p>重复相同操作，直到所有数字都被排序</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/16738f0eff237d54?w=1148&amp;h=972&amp;f=png&amp;s=36827" alt=""></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/16738f0f0a65d4cf?w=1668&amp;h=1708&amp;f=png&amp;s=75701" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/16738f0ef955a299?w=1604&amp;h=1110&amp;f=png&amp;s=51471" alt=""></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/16738f0f0156b4cc?w=1452&amp;h=880&amp;f=png&amp;s=44413" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 选择排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一组动画演示归并排序</title>
      <link href="/2019/01/26/tu-jie-shu-ju-jie-gou-wu-fen-zhong-xue-suan-fa-zhi-yi-zu-dong-hua-yan-shi-gui-bing-pai-xu/"/>
      <url>/2019/01/26/tu-jie-shu-ju-jie-gou-wu-fen-zhong-xue-suan-fa-zhi-yi-zu-dong-hua-yan-shi-gui-bing-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画演示归并排序"><a href="#【图解数据结构】-一组动画演示归并排序" class="headerlink" title="【图解数据结构】 一组动画演示归并排序"></a>【图解数据结构】 一组动画演示归并排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 —–《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。</p><h2 id="归并排序（Merge-sort"><a href="#归并排序（Merge-sort" class="headerlink" title="归并排序（Merge sort"></a>归并排序（Merge sort</h2><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ul><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li><li>自下而上的迭代；</li></ul><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p></li><li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p></li><li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p></li><li><p>重复步骤 3 直到某一指针达到序列尾；</p></li><li><p>将另一序列剩下的所有元素直接复制到合并序列尾。</p></li></ol><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16733b1a9c74ce50?w=955&amp;h=538&amp;f=gif&amp;s=586156" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，将数字分割成两片区域</p></li><li><p>将数字分割成两片区域</p></li><li><p>。。。。。。</p></li><li><p>直到每片区域只有一个元素</p></li><li><p>分割完成</p></li><li><p>接下来，将分割的每片区域进行合并组合</p></li><li><p>合并时，按照数字的升序移动，使得合并后的数字在组内按升序排列</p></li><li><p>当合并包含多个数字的组时，比较开头的数字，移动其中较小的数字</p></li><li><p>比如在动画中，比较开头的 4 和 3 </p></li><li><p>其中 4 大于 3， 因此移动 3</p></li><li><p>按照同样的逻辑去比较该列剩余的头数</p></li><li><p>4 小于 7 ，所以移动 4</p></li><li><p>。。。。。。</p></li><li><p>递归的重复组的合并操作，直到所有数字都在一个组中。</p></li><li><p>完成 归并排序 啦~</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16733b1a9c8f7fff?w=1832&amp;h=1708&amp;f=png&amp;s=85502" alt="C++代码实现"></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16733b1a9db220c7?w=1668&amp;h=2444&amp;f=png&amp;s=128379" alt="Java代码实现"></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16733b1a9dd4b5f7?w=1322&amp;h=1294&amp;f=png&amp;s=64894" alt="Python代码实现"></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16733b1a9dcea382?w=1344&amp;h=1800&amp;f=png&amp;s=76855" alt="JavaScript代码实现"></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示冒泡排序</title>
      <link href="/2019/01/26/tu-jie-shu-ju-jie-gou-dong-hua-yan-shi-mou-pao-pai-xu/"/>
      <url>/2019/01/26/tu-jie-shu-ju-jie-gou-dong-hua-yan-shi-mou-pao-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画演示冒泡排序"><a href="#【图解数据结构】-一组动画演示冒泡排序" class="headerlink" title="【图解数据结构】 一组动画演示冒泡排序"></a>【图解数据结构】 一组动画演示冒泡排序</h1><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p></li><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p></li><li><p>针对所有的元素重复以上的步骤，除了最后一个。</p></li><li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p></li></ol><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181119200024.gif" alt="五分钟学算法之冒泡排序"></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>将天平放在序列的右端，并比较天平左右的数字</p></li><li><p>在这种情况下我们比较 3 和 8 </p></li><li><p>比较后如果右边的数字较小，则被交换</p></li><li><p>因为 8 大于 3 ，所以数字不用交换</p></li><li><p>比较完成后，将天平向左移动一个位置，比较数字</p></li><li><p>因为 3 大于 2 ，所以数字不用交换</p></li><li><p>比较完成后，逐一移动天平，比较数字</p></li><li><p>此时 2 小于 4 ，所以左右的数字互相交换</p></li><li><p>重复同样的操作，直到天平移动到左端</p></li><li><p>。。。。。。</p></li><li><p>天平到达左端</p></li><li><p>经过上述的操作，数列中最小的数字已经移动到左端</p></li><li><p>将天平返回右端</p></li><li><p>重复相同的操作，直到所有数字都被排序</p></li><li><p>。。。。。。</p></li><li><p>吐完泡泡了</p></li></ol><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181119201851.png" alt=""></p><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181119201910.png" alt=""></p><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181119201417.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 冒泡排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示希尔排序</title>
      <link href="/2018/11/29/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-xi-er-pai-xu/"/>
      <url>/2018/11/29/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-xi-er-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解希尔排序"><a href="#【图解数据结构】-一组动画彻底理解希尔排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解希尔排序"></a>【图解数据结构】 一组动画彻底理解希尔排序</h1><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</p></li><li><p>按增量序列个数 k，对序列进行 k 趟排序；</p></li><li><p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p></li></ol><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，选择增量 gap = 10/2 ，缩小增量继续以 gap = gap/2 的方式</p></li><li><p>初始增量为 gap = 10/2 = 5，整个数组分成了 5 组</p></li><li><p>按颜色划分为【 8 , 3 】，【 9 , 5 】，【 1 , 4 】，【 7 , 6 】，【 2 , 0 】</p></li><li><p>对这分开的 5 组分别使用上节所讲的插入排序</p></li><li><p>结果可以发现，这五组中的相对小元素都被调到前面了</p></li><li><p>缩小增量 gap = 5/2 = 2，整个数组分成了 2 组</p></li><li><p>【 3 , 1 , 0 , 9 , 7  】，【 5 , 6 , 8 , 4 , 2  】</p></li><li><p>对这分开的 2 组分别使用上节所讲的插入排序</p></li><li><p>此时整个数组的有序性是很明显的</p></li><li><p>再缩小增量 gap = 2/2 = 1，整个数组分成了 1 组</p></li><li><p>【 0, 2 , 1 , 4 , 3 , 5 , 7 , 6 , 9 , 0  】</p></li><li><p>此时，只需要对以上数列进行简单的微调，不需要大量的移动操作即可完成整个数组的排序</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674859d8e945f1a?w=1280&amp;h=1037&amp;f=png&amp;s=167873" alt=""></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674859d8dda4858?w=1280&amp;h=1275&amp;f=png&amp;s=248791" alt=""></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674859d902e21b0?w=1128&amp;h=1110&amp;f=png&amp;s=53723" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674859d8e52ee54?w=1280&amp;h=934&amp;f=png&amp;s=185891" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 希尔排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示堆排序</title>
      <link href="/2018/11/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-dui-pai-xu/"/>
      <url>/2018/11/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-dui-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解堆排序"><a href="#【图解数据结构】-一组动画彻底理解堆排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解堆排序"></a>【图解数据结构】 一组动画彻底理解堆排序</h1><h2 id="预备知识：堆结构"><a href="#预备知识：堆结构" class="headerlink" title="预备知识：堆结构"></a>预备知识：堆结构</h2><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p><h4 id="大顶堆"><a href="#大顶堆" class="headerlink" title="大顶堆"></a>大顶堆</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181125194044.png" alt=""></p><h4 id="小顶堆"><a href="#小顶堆" class="headerlink" title="小顶堆"></a>小顶堆</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181125194056.png" alt=""></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序（Heapsort）是指利用堆这种数据结构（后面的【图解数据结构】内容会讲解分析）所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ul><li><p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p></li><li><p>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p></li></ul><p>堆排序的平均时间复杂度为 Ο(nlogn)。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>创建一个堆 H[0……n-1]；</p></li><li><p>把堆首（最大值）和堆尾互换；</p></li><li><p>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</p></li><li><p>重复步骤 2，直到堆的尺寸为 1。</p></li></ol><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181125191942.gif" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，将所有的数字存储在堆中</p></li><li><p>按大顶堆构建堆，其中大顶堆的一个特性是数据将被从大到小取出，将取出的数字按照相反的顺序进行排列，数字就完成了排序</p></li><li><p>在这里数字 5 先入堆</p></li><li><p>数字 2 入堆</p></li><li><p>数字 7 入堆， 7 此时是最后一个节点，与最后一个非叶子节点（也就是数字 5 ）进行比较，由于 7 大于 5 ，所以 7 和 5 交互</p></li><li><p>按照上述的操作将所有数字入堆，然后从左到右，从上到下进行调整，构造出大顶堆</p></li><li><p>入堆完成之后，将堆顶元素取出，将末尾元素置于堆顶，重新调整结构，使其满足堆定义</p></li><li><p>堆顶元素数字 7 取出，末尾元素数字 4 置于堆顶，为了维护好大顶堆的定义，最后一个非叶子节点数字 5 与 4 比较，而后交换两个数字的位置</p></li><li><p>反复执行调整+交换步骤，直到整个序列有序</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="Go代码实现"><a href="#Go代码实现" class="headerlink" title="Go代码实现"></a>Go代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126100338.png" alt=""></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126100347.png" alt=""></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126100353.png" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126100358.png" alt=""></p><p>如果你是iOS开发者，可以在GitHub上 <a href="https://github.com/MisterBooo/Play-With-Sort-OC">https://github.com/MisterBooo/Play-With-Sort-OC</a> 获取更直观可调试运行的源码。</p><p>你可以在公众号 <strong>五分钟学算法</strong> 获取更多排序内容。</p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示计数排序</title>
      <link href="/2018/11/24/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-ji-shu-pai-xu/"/>
      <url>/2018/11/24/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-ji-shu-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解计数排序"><a href="#【图解数据结构】-一组动画彻底理解计数排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解计数排序"></a>【图解数据结构】 一组动画彻底理解计数排序</h1><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序是一种非基于比较的排序算法，其空间复杂度和时间复杂度均为O(n+k)，其中k是整数的范围。基于比较的排序算法时间复杂度最小是O(nlogn)的。该算法于1954年由 Harold H. Seward 提出。</p><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有<strong>确定范围的整数</strong>。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max</p></li><li><p>开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1)</p></li><li><p>数组 B 中 index 的元素记录的值是 A 中某元素出现的次数</p></li><li><p>最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数</p></li></ol><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126190814.gif" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，扫描一下整个序列</p></li><li><p>获得最小值为 2 ，最大值为 7</p></li><li><p>新建数组包含 2~7 的元素</p></li><li><p>再次扫描序列，将序列的值放置在新建数组中</p></li><li><p>扫描数字 5，数组中 index 为 3 的值为 5，次数为 1</p></li><li><p>扫描数字 3，数组中 index 为 1 的值为 3，次数为 1</p></li><li><p>扫描数字 4，数组中 index 为 2 的值为 4，次数为 1</p></li><li><p>扫描数字 7，数组中 index 为 5 的值为 7，次数为 1</p></li><li><p>扫描数字 2，数组中 index 为 0 的值为 2，次数为 1</p></li><li><p>扫描数字 4，数组中 index 为 2 的值为 4，次数为 2</p></li><li><p>扫描数字 3，数组中 index 为 1 的值为 3，次数为 2</p></li><li><p>按照这种节奏，扫描结束后，新建数组中存放了整个序列以及每个数字出现的次数</p></li><li><p>最后输出目标整数序列</p></li><li><p>输出数字 2，同时数组中 index 为 0 的值为 2 的元素次数变为 0</p></li><li><p>输出数字 3，同时数组中 index 为 1 的值为 3 的元素次数变为 1</p></li><li><p>同样的操作，整个序列就完全输出了</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="Go代码实现"><a href="#Go代码实现" class="headerlink" title="Go代码实现"></a>Go代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126191921.png" alt=""></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126191936.png" alt=""></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126191943.png" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126191949.png" alt=""></p><p>如果你是iOS开发者，可以在GitHub上 <a href="https://github.com/MisterBooo/Play-With-Sort-OC">https://github.com/MisterBooo/Play-With-Sort-OC</a> 获取更直观可调试运行的源码。</p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 计数排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示插入排序</title>
      <link href="/2018/11/24/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-yan-shi-cha-ru-pai-xu/"/>
      <url>/2018/11/24/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-yan-shi-cha-ru-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画演示插入排序"><a href="#【图解数据结构】-一组动画演示插入排序" class="headerlink" title="【图解数据结构】 一组动画演示插入排序"></a>【图解数据结构】 一组动画演示插入排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 —–《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p></li><li><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）。</p></li></ol><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181120164938.gif" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>一开始左端数字已经排序，数字 5 不动</p></li><li><p>然后，取出剩余未操作的左端数字 3 </p></li><li><p>将其与已经操作的左侧数字相比较</p></li><li><p>如果左边的数字较大，则交换两个数字</p></li><li><p>这种情况下，由于 5 大于 3 ，所以交换两个数字</p></li><li><p>重复此操作，直到出现一个较小的数字或者数字到达左端</p></li><li><p>数字 3 已经完成排序</p></li><li><p>接下来，和之前一样取出剩余未操作的左端数字 4  </p></li><li><p>与其相邻的左边数字进行比较</p></li><li><p>这种情况下，由于 5 大于 4 ，所以交换两个数字</p></li><li><p>继续操作，由于 3 小于 4 ，即出现了更小的数字，所以 4 停止移动</p></li><li><p>数字 4 已经完成排序</p></li><li><p>重复相同的操作，直到所有的数字完成排序</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="http://upload-images.jianshu.io/upload_images/1940317-ce2bac560fc4620a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="http://upload-images.jianshu.io/upload_images/1940317-e29b04076de62c3a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="http://upload-images.jianshu.io/upload_images/1940317-25d430ac861b8bdd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="http://upload-images.jianshu.io/upload_images/1940317-575eb47403e08c3f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 插入排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2018/11/08/mei-tian-yi-suan-evaluate-reverse-polish-notation-22/"/>
      <url>/2018/11/08/mei-tian-yi-suan-evaluate-reverse-polish-notation-22/</url>
      
        <content type="html"><![CDATA[<hr><p>title: LeetCode上第 150 号问题：逆波兰表达式求值<br>date: 2019-01-27 11:36:01<br>author: 程序员小吴师兄<br>top: false<br>summary:<br>categories: LeetCode<br>tags:</p><ul><li>栈</li><li>数据结构</li></ul><hr><p>LeetCode上第150号问题：<strong><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">逆波兰表达式求值</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>根据逆波兰表示法，求表达式的值。</p></blockquote><blockquote><p>有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p></blockquote><blockquote><h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5></blockquote><blockquote><p>整数除法只保留整数部分。<br>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。   </p><h5 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h5></blockquote><blockquote><p>输入: [“2”, “1”, “+”, “3”, “<em>“]<br>输出: 9<br>解释: ((2 + 1) </em> 3) = 9   </p><h5 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h5></blockquote><blockquote><p>输入: [“4”, “13”, “5”, “/“, “+”]<br>输出: 6<br>解释: (4 + (13 / 5)) = 6   </p><h5 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h5></blockquote><blockquote><p>输入: [“10”, “6”, “9”, “3”, “+”, “-11”, “<em>“, “/“, “</em>“, “17”, “+”, “5”, “+”]<br>输出: 22<br>解释:<br>  ((10 <em> (6 / ((9 + 3) </em> -11))) + 17) + 5<br>= ((10 <em> (6 / (12 </em> -11))) + 17) + 5<br>= ((10 <em> (6 / -132)) + 17) + 5<br>= ((10 </em> 0) + 17) + 5<br>= (0 + 17) + 5<br>= 17 + 5<br>= 22   </p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用数据结构<code>栈</code>来解决这个问题。</p><ul><li>从前往后遍历数组</li><li>遇到数字则压入栈中</li><li>遇到符号，则把栈顶的两个数字拿出来运算，把结果再压入栈中</li><li>遍历完整个数组，栈顶数字即为最终答案</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong><br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzntpqf2g30qx0f4485.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkznqdhk8j30u00wedha.jpg" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2018/11/08/mei-tian-yi-suan-valid-parentheses-21/"/>
      <url>/2018/11/08/mei-tian-yi-suan-valid-parentheses-21/</url>
      
        <content type="html"><![CDATA[<hr><p>title: LeetCode上第20 号问题：有效的括号<br>date: 2019-01-27 11:48:28<br>author: 程序员小吴师兄<br>top: false<br>summary:<br>categories: LeetCode<br>tags:</p><ul><li>栈</li><li>数据结构</li></ul><hr><p>LeetCode上第20 号问题：<strong><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">有效的括号</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p></blockquote><blockquote><p>有效字符串需满足：</p></blockquote><blockquote><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。    </p></blockquote><blockquote><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4></blockquote><blockquote><p>输入: “()”<br>输出: true</p></blockquote><blockquote><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4></blockquote><blockquote><p>输入: “()[]{}”<br>输出: true</p></blockquote><blockquote><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a>示例 3:</h4></blockquote><blockquote><p>输入: “(]”<br>输出: false</p></blockquote><blockquote><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4:"></a>示例 4:</h4></blockquote><blockquote><p>输入: “([)]”<br>输出: false   </p></blockquote><blockquote><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5:"></a>示例 5:</h4></blockquote><blockquote><p>输入: “{[]}”<br>输出: true   </p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题让我们验证输入的字符串是否为括号字符串，包括大括号，中括号和小括号。</p><p>这里我们使用<strong>栈</strong>。</p><ul><li>遍历输入字符串</li><li>如果当前字符为左半边括号时，则将其压入栈中</li><li>如果遇到右半边括号时，<strong>分类讨论：</strong></li><li>1）如栈不为空且为对应的左半边括号，则取出栈顶元素，继续循环  </li><li>2）若此时栈为空，则直接返回false</li><li>3）若不为对应的左半边括号，反之返回false</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzzpkrjng30qo0f0n2n.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkzzqlgmij30u014awmf.jpg" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2018/11/06/mei-tian-yi-suan-remove-nth-node-from-end-of-list-20/"/>
      <url>/2018/11/06/mei-tian-yi-suan-remove-nth-node-from-end-of-list-20/</url>
      
        <content type="html"><![CDATA[<hr><p>title: LeetCode上第19号问题：Remove Nth Node From End of List<br>date: 2019-01-27 11:43:55<br>author: 程序员小吴师兄<br>top: false<br>summary:<br>categories: LeetCode<br>tags:</p><ul><li>链表</li><li>指针</li></ul><hr><p>LeetCode上第19号问题：<strong><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">Remove Nth Node From End of List</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p></blockquote><blockquote><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4></blockquote><blockquote><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</p></blockquote><blockquote><p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5</p><h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4></blockquote><blockquote><p>给定的 n 保证是有效的。</p></blockquote><blockquote><h4 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h4></blockquote><blockquote><p>你能尝试使用一趟扫描实现吗？</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>采取双重遍历肯定是可以解决问题的，但题目要求我们一次遍历解决问题，那我们的思路得发散一下。</p><p>我们可以设想假设设定了双指针<code>p</code>和<code>q</code>的话，当<code>q</code>指向末尾的<code>NULL</code>，<code>p</code>与<code>q</code>之间相隔的元素个数为<code>n</code>时，那么删除掉<code>p</code>的下一个指针就完成了要求。</p><ul><li>设置虚拟节点<code>dummyHead</code>指向<code>head</code></li><li>设定双指针<code>p</code>和<code>q</code>，初始都指向虚拟节点<code>dummyHead</code></li><li>移动<code>q</code>，直到<code>p</code>与<code>q</code>之间相隔的元素个数为<code>n</code></li><li>同时移动<code>p</code>与<code>q</code>，直到<code>q</code>指向的为<code>NULL</code></li><li>将<code>p</code>的下一个节点指向下下个节点</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkzv25jlbg30qn0ezajr.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkzv3cllbj30u012d760.jpg" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2018/11/05/mei-tian-yi-suan-delete-node-in-a-linked-list-18/"/>
      <url>/2018/11/05/mei-tian-yi-suan-delete-node-in-a-linked-list-18/</url>
      
        <content type="html"><![CDATA[<hr><p>title: LeetCode上第 237 号问题：Delete Node in a Linked List<br>date: 2019-01-27 11:35:29<br>author: 程序员小吴师兄<br>top: false<br>summary:<br>categories: LeetCode<br>tags:</p><ul><li>链表</li></ul><hr><p>LeetCode上第237号问题：<strong><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">Delete Node in a Linked List</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p></blockquote><blockquote><p>现有一个链表 – head = [4,5,1,9]，它可以表示为:</p></blockquote><blockquote><pre><code>4 -&gt; 5 -&gt; 1 -&gt; 9##### 示例 1:</code></pre></blockquote><blockquote><p><strong>输入:</strong> head = [4,5,1,9], node = 5<br><strong>输出:</strong> [4,1,9]<br><strong>解释:</strong> 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt;  9.</p><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h5></blockquote><blockquote><p><strong>输入:</strong> head = [4,5,1,9], node = 1<br><strong>输出:</strong> [4,5,9]<br><strong>解释:</strong> 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.     </p><h5 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h5></blockquote><blockquote><ul><li>链表至少包含两个节点。    </li><li>链表中所有节点的值都是唯一的。     </li><li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。     </li><li>不要从你的函数中返回任何结果。          </li></ul></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>此题注意的点是没有给我们链表的起点，只给我们了一个要删的节点，与以往处理的情况稍许不同。</p><p><strong>这道题的处理方法是先把当前节点的值用下一个节点的值覆盖，然后我们删除下一个节点即可</strong></p><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181105171450.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181105171512.png" alt=""></p><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181105171613.png" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2018/11/04/mei-tian-yi-suan-odd-even-linked-list-17/"/>
      <url>/2018/11/04/mei-tian-yi-suan-odd-even-linked-list-17/</url>
      
        <content type="html"><![CDATA[<hr><p>title: LeetCode上第 328 号问题：Odd Even Linked List<br>date: 2019-01-27 11:40:19<br>author: 程序员小吴师兄<br>top: false<br>summary:<br>categories: LeetCode<br>tags:</p><ul><li>链表</li><li>节点</li></ul><hr><p>LeetCode上第328号问题：<strong><a href="https://leetcode-cn.com/problems/odd-even-linked-list/" target="_blank" rel="noopener">Odd Even Linked List</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p></blockquote><blockquote><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p></blockquote><blockquote><p><strong>示例 1:</strong></p></blockquote><blockquote><p><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br><strong>输出:</strong> 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</p><p><strong>示例 2:</strong></p></blockquote><blockquote><p><strong>输入:</strong> 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL<br><strong>输出:</strong> 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</p><p><strong>说明:</strong></p></blockquote><blockquote><ul><li>应当保持奇数节点和偶数节点的相对顺序。</li><li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li></ul></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题给了我们一个链表，让我们分开奇偶节点，所有奇节点在前，偶节点在后。</p><ul><li>设定两个虚拟节点，<code>dummyHead1</code>用来保存奇节点，<code>dummyHead2</code>来保存偶节点；</li><li>遍历整个原始链表，将奇节点放于<code>dummyHead1</code>中，其余的放置在<code>dummyHead2</code>中</li><li>遍历结束后，将<code>dummyHead2</code>插入到<code>dummyHead1</code>后面</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzqr3h93g30qk0ewwo3.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzqncct3j30u00ygwmm.jpg" alt=""></p><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkzqplqhmj31sl0u0mzs.jpg" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2018/11/04/mei-tian-yi-suan-partition-list-16/"/>
      <url>/2018/11/04/mei-tian-yi-suan-partition-list-16/</url>
      
        <content type="html"><![CDATA[<hr><p>title: LeetCode上第86号问题：Partition List<br>date: 2019-01-27 11:40:51<br>author: 程序员小吴师兄<br>top: false<br>summary:<br>categories: LeetCode<br>tags:</p><ul><li>链表</li><li>分治</li></ul><hr><p>LeetCode上第86号问题：<strong><a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener">Partition List</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p></blockquote><blockquote><p>你应当保留两个分区中每个节点的初始相对位置。</p></blockquote><blockquote><h5 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h5></blockquote><blockquote><p>输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题要求我们划分链表，把所有小于给定值的节点都移到前面，大于该值的节点顺序不变，相当于一个局部排序的问题。</p><ul><li>设定两个虚拟节点，<code>dummyHead1</code>用来保存小于于该值的链表，<code>dummyHead2</code>来保存大于等于该值的链表</li><li>遍历整个原始链表，将小于该值的放于<code>dummyHead1</code>中，其余的放置在<code>dummyHead2</code>中</li><li>遍历结束后，将<code>dummyHead2</code>插入到<code>dummyHead1</code>后面</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181104095701.gif" alt="动画演示"></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181106090835.png" alt=""></p><h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p>我们会在公众号（<strong>菠了个菜</strong>）每天早上8点30分准时推送一条LeetCode上的算法题目，并给出该题目的动画解析以及参考答案，每篇文章阅读时长为五分钟左右。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2018/11/03/mei-tian-yi-suan-reverse-linked-list-ii-19/"/>
      <url>/2018/11/03/mei-tian-yi-suan-reverse-linked-list-ii-19/</url>
      
        <content type="html"><![CDATA[<hr><p>title: LeetCode上第92号问题：Reverse Linked List II<br>date: 2019-01-27 11:44:36<br>author: 程序员小吴师兄<br>top: false<br>summary:<br>categories: LeetCode<br>tags:</p><ul><li>链表</li><li>指针</li></ul><hr><p>LeetCode上第92号问题：<strong><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">Reverse Linked List II</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p></blockquote><blockquote><h5 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h5><p>1 ≤ m ≤ n ≤ 链表长度。</p></blockquote><blockquote><h5 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h5></blockquote><blockquote><p><strong>输入</strong>: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4.<br><strong>输出</strong>: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong><a href="https://xiaozhuanlan.com/topic/7513064892" target="_blank" rel="noopener">Reverse Linked List</a></strong>的延伸题。</p><p>可以考虑取出需要反转的这一小段链表，反转完后再插入到原先的链表中。</p><p><strong>以本题为例：</strong></p><p>变换的是2,3,4这三个点，那么我们可以先取出2，用front指针指向2，然后当取出3的时候，我们把3加到2的前面，把front指针前移到3，依次类推，到4后停止，这样我们得到一个新链表4-&gt;3-&gt;2, front指针指向4。</p><p>对于原链表来说，<strong>有两个点的位置很重要</strong>，需要用指针记录下来，分别是1和5，把新链表插入的时候需要这两个点的位置。</p><ul><li>用pre指针记录1的位置</li><li>当4结点被取走后，5的位置需要记下来</li><li>这样我们就可以把倒置后的那一小段链表加入到原链表中</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzvp0nnyg30qk0ev4bt.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzvpvd7xj30vw0u0q82.jpg" alt=""></p><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkzvrexmqj31ss0u00vf.jpg" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2018/11/02/mei-tian-yi-suan-remove-linked-list-elements/"/>
      <url>/2018/11/02/mei-tian-yi-suan-remove-linked-list-elements/</url>
      
        <content type="html"><![CDATA[<hr><p>title: LeetCode上第203号问题：Remove Linked List Elements<br>date: 2019-01-27 11:41:44<br>author: 程序员小吴师兄<br>top: false<br>summary:<br>categories: LeetCode<br>tags:</p><ul><li>链表</li><li>指针</li></ul><hr><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzs7u2a6j31iu0mutbi.jpg" alt=""></p><p>LeetCode上第203号问题：<strong><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">Remove Linked List Elements</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>删除链表中等于给定值 val 的所有节点。</p></blockquote><blockquote><h5 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h5></blockquote><blockquote><p>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6<br>输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>主要考察了基本的链表遍历和设置指针的知识点。</p><p>定义一个虚拟头节点<code>dummyHead</code>，遍历查看原链表，遇到与给定值相同的元素，将该元素的前后两个节点连接起来，然后删除该元素即可。</p><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzs3cu9jg30qo0f0107.gif" alt="动画演示"></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><h4 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h4><pre><code>// 203. Remove Linked List Elements// https://leetcode.com/problems/remove-linked-list-elements/description/// 使用虚拟头结点// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    ListNode* removeElements(ListNode* head, int val) {        // 创建虚拟头结点        ListNode* dummyHead = new ListNode(0);        dummyHead-&gt;next = head;        ListNode* cur = dummyHead;        while(cur-&gt;next != NULL){            if(cur-&gt;next-&gt;val == val){                ListNode* delNode = cur-&gt;next;                cur-&gt;next = delNode-&gt;next;                delete delNode;            }            else                cur = cur-&gt;next;        }        ListNode* retNode = dummyHead-&gt;next;        delete dummyHead;        return retNode;    }};</code></pre><h4 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h4><p>用递归来解。</p><p>通过递归调用到链表末尾，然后回来，需要删的元素，将链表next指针指向下一个元素即可。</p><pre><code>class Solution {public:    ListNode* removeElements(ListNode* head, int val) {        if (!head) return NULL;        head-&gt;next = removeElements(head-&gt;next, val);        return head-&gt;val == val ? head-&gt;next : head;    }};</code></pre><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkzs66gunj31ri0u0773.jpg" alt="执行结果"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2018/11/01/mei-tian-yi-suan-reverse-linked-list/"/>
      <url>/2018/11/01/mei-tian-yi-suan-reverse-linked-list/</url>
      
        <content type="html"><![CDATA[<hr><p>title: LeetCode上第206号问题：Reverse Linked List<br>date: 2019-01-27 11:45:35<br>author: 程序员小吴师兄<br>top: false<br>summary:<br>categories: LeetCode<br>tags:</p><ul><li>链表</li><li>反转</li></ul><hr><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzvypae1j311m0g6gms.jpg" alt=""></p><p>LeetCode上第206号问题：<strong><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">Reverse Linked List</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>反转一个单链表。</p></blockquote><blockquote><h5 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h5></blockquote><blockquote><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><h5 id="进阶"><a href="#进阶" class="headerlink" title="进阶:"></a>进阶:</h5><p>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>设置三个节点<code>pre</code>、<code>cur</code>、<code>next</code></p><ul><li>（1）每次查看<code>cur</code>节点是否为<code>NULL</code>，如果是，则结束循环，获得结果</li><li>（2）如果<code>cur</code>节点不是为<code>NULL</code>，则先设置临时变量<code>next</code>为<code>cur</code>的下一个节点</li><li>（3）让<code>cur</code>的下一个节点变成指向<code>pre</code>，而后<code>pre</code>移动<code>cur</code>，<code>cur</code>移动到<code>next</code></li><li>（4）重复（1）（2）（3）</li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzw15rnng30nj0d9wqe.gif" alt="动画演示"></p><h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><h5 id="迭代的方式处理"><a href="#迭代的方式处理" class="headerlink" title="迭代的方式处理"></a>迭代的方式处理</h5><pre><code>// 206. Reverse Linked List// https://leetcode.com/problems/reverse-linked-list/description/// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    ListNode* reverseList(ListNode* head) {        ListNode* pre = NULL;        ListNode* cur = head;        while(cur != NULL){            ListNode* next = cur-&gt;next;            cur-&gt;next = pre;            pre = cur;            cur = next;        }        return pre;    }};</code></pre><h5 id="递归的方式处理"><a href="#递归的方式处理" class="headerlink" title="递归的方式处理"></a>递归的方式处理</h5><pre><code>// 206. Reverse Linked List// https://leetcode.com/problems/reverse-linked-list/description///// 递归的方式反转链表// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    ListNode* reverseList(ListNode* head) {        // 递归终止条件        if(head == NULL || head-&gt;next == NULL)            return head;        ListNode* rhead = reverseList(head-&gt;next);        // head-&gt;next此刻指向head后面的链表的尾节点        // head-&gt;next-&gt;next = head把head节点放在了尾部        head-&gt;next-&gt;next = head;        head-&gt;next = NULL;        return rhead;    }};</code></pre><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzw3k5wkj31sn0u0gnx.jpg" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2018/11/01/mei-tian-yi-suan-reverse-string/"/>
      <url>/2018/11/01/mei-tian-yi-suan-reverse-string/</url>
      
        <content type="html"><![CDATA[<hr><p>title: LeetCode上第344号问题：Reverse String<br>date: 2019-01-27 11:46:45<br>author: 程序员小吴师兄<br>top: false<br>summary:<br>categories: LeetCode<br>tags:</p><ul><li>反转</li><li>字符串</li></ul><hr><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzwvxg08j311i0hot9w.jpg" alt=""></p><p>LeetCode上第344号问题：<strong><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">Reverse String</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>编写一个函数，其作用是将输入的字符串反转过来。</p></blockquote><blockquote><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h5></blockquote><blockquote><p>输入: “hello”<br>输出: “olleh”   </p></blockquote><blockquote><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h5></blockquote><blockquote><p>输入: “A man, a plan, a canal: Panama”<br>输出: “amanaP :lanac a ,nalp a ,nam A”</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接从两头往中间走，同时交换两边的字符即可</p><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkzwxdigqg30qm0ep0xp.gif" alt="动画演示"></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><h4 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h4><pre><code>// 344. Reverse String// https://leetcode.com/problems/reverse-string/description/// Two Pointers// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    string reverseString(string s) {        int i = 0, j = s.size() - 1;        while(i &lt; j){            swap(s[i], s[j]);            i ++;            j --;        }        return s;    }};</code></pre><h4 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h4><pre><code>// 344. Reverse String// https://leetcode.com/problems/reverse-string/description/// Two Pointers// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    string reverseString(string s) {         int left = 0, right = s.size() - 1;        while (left &lt; right) {           char t = s[left];            s[left++] = s[right];           s[right--] = t;        }       return s;   }};</code></pre><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzwzp763j313u0h6mxq.jpg" alt="执行结果"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2018/10/28/mei-tian-yi-suan-two-sum-2018-nian-10-yue-28-ri/"/>
      <url>/2018/10/28/mei-tian-yi-suan-two-sum-2018-nian-10-yue-28-ri/</url>
      
        <content type="html"><![CDATA[<hr><p>title: LeetCode上第 1 号问题：Two Sum<br>date: 2019-01-27 11:47:56<br>author: 程序员小吴师兄<br>top: false<br>summary:<br>categories: LeetCode<br>tags:</p><ul><li>查找表</li><li>索引</li></ul><hr><p>leetcode上第1号问题：<a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">Two Sum</a></p><blockquote><p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p></blockquote><blockquote><p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p></blockquote><blockquote><p>示例:</p></blockquote><blockquote><p>给定 nums = [2, 7, 11, 15], target = 9</p></blockquote><blockquote><p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用查找表来解决该问题。</p><blockquote><p>设置一个map容器record用来记录元素的值与索引</p><p>遍历数组nums</p><ul><li>每次遍历时使用临时变量complement用来保存目标值与当前值的差值</li><li>在此次遍历中查找record，查看是否有与complement一致的值，如果查找成功则返回查找值的索引值与当前变量的值i</li><li>如果未找到，则在record保存该元素与索引值i</li></ul></blockquote><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkzyntxibg30nn0dd458.gif" alt="Two Sum"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 1. Two Sum// https://leetcode.com/problems/two-sum/description/// 时间复杂度：O(n)// 空间复杂度：O(n)class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        unordered_map&lt;int,int&gt; record;        for(int i = 0 ; i &lt; nums.size() ; i ++){            int complement = target - nums[i];            if(record.find(complement) != record.end()){                int res[] = {i, record[complement]};                return vector&lt;int&gt;(res, res + 2);            }            record[nums[i]] = i;        }    }};</code></pre><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkzymcdnzj31nx0u0q5l.jpg" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2018/10/27/mei-tian-yi-suan-intersection-of-two-arrays/"/>
      <url>/2018/10/27/mei-tian-yi-suan-intersection-of-two-arrays/</url>
      
        <content type="html"><![CDATA[<hr><p>title: LeetCode上第  349 号问题：Intersection of Two Arrays<br>date: 2019-01-27 11:38:21<br>author: 程序员小吴师兄<br>top: false<br>summary:<br>categories: LeetCode<br>tags:</p><ul><li>set</li><li>容器</li></ul><hr><p>leetcode上第 349 号问题：<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">Intersection of Two Arrays</a></p><blockquote><p>给定两个数组，编写一个函数来计算它们的交集。</p></blockquote><blockquote><p>示例 1:<br>输入: nums1 = [1,2,2,1], nums2 = [2,2]<br>输出: [2]  </p><p>示例 2:<br>输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>输出: [9,4]</p><p>说明:  </p><ul><li>输出结果中的每个元素一定是唯一的。   </li><li>我们可以不考虑输出结果的顺序。</li></ul></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>容器类<a href="https://zh.cppreference.com/w/cpp/container/set" target="_blank" rel="noopener">set</a>的使用。</p><ul><li>遍历num1，通过set容器record存储num1的元素</li><li>遍历num2，在record中查找是否有相同的元素，如果有，用set容器resultSet进行存储</li><li>将resultSet转换为vector类型</li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzoct4m6g30nk0dbq67.gif" alt="Intersection of Two Arrays"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 349. Intersection of Two Arrays// https://leetcode.com/problems/intersection-of-two-arrays/description/// 时间复杂度: O(nlogn)// 空间复杂度: O(n)class Solution {public:    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        set&lt;int&gt; record;        for( int i = 0 ; i &lt; nums1.size() ; i ++ ){            record.insert(nums1[i]);        }        set&lt;int&gt; resultSet;        for( int i = 0 ; i &lt; nums2.size() ; i ++ ){            if(record.find(nums2[i]) != record.end()){                resultSet.insert(nums2[i]);            }        }        vector&lt;int&gt; resultVector;        for(set&lt;int&gt;::iterator iter = resultSet.begin(); iter != resultSet.end(); iter ++ ){            resultVector.push_back(*iter);        }        return resultVector;    }};</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2018/10/24/mei-zhou-yi-suan-two-sum-ii/"/>
      <url>/2018/10/24/mei-zhou-yi-suan-two-sum-ii/</url>
      
        <content type="html"><![CDATA[<hr><p>title: LeetCode上第167号问题：Two Sum II<br>date: 2019-01-27 11:50:40<br>author: 程序员小吴师兄<br>top: false<br>summary:<br>categories: LeetCode<br>tags:</p><ul><li>数组</li><li>指针</li></ul><hr><p>leetcode上第167号问题：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">Two Sum II</a></p><blockquote><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p></blockquote><blockquote><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p></blockquote><blockquote><p>说明:</p></blockquote><blockquote><ul><li>返回的下标值（index1 和 index2）不是从零开始的。</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ul></blockquote><blockquote><p>示例:</p></blockquote><blockquote><p>输入: numbers = [2, 7, 11, 15], target = 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>初始化左指针left指向数组起始，初始化右指针right指向数组结尾。</p><p>根据<strong>已排序</strong>这个特性，</p><ul><li><p>（1）如果numbers[left]与numbers[right]的和tmp小于target，说明应该增加tmp,因此left右移指向一个较大的值。</p></li><li><p>（2）如果tmp大于target，说明应该减小tmp,因此right左移指向一个较小的值。</p></li><li><p>（3）tmp等于target，则找到，返回left+1和right+1。（注意以1为起始下标）</p></li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzl02exvalg30np0cpjsz.gif" alt="Two sum"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 对撞指针// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {        int l = 0, r = numbers.size() - 1;        while(l &lt; r){            if(numbers[l] + numbers[r] == target){                int res[2] = {l+1, r+1};                return vector&lt;int&gt;(res, res+2);            }            else if(numbers[l] + numbers[r] &lt; target)                l ++;            else // numbers[l] + numbers[r] &gt; target                r --;        }    }</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2018/10/24/mei-zhou-yi-suan-sort-colors/"/>
      <url>/2018/10/24/mei-zhou-yi-suan-sort-colors/</url>
      
        <content type="html"><![CDATA[<hr><p>title: LeetCode上第75号问题：Sort Colors<br>date: 2019-01-27 11:49:32<br>author: 程序员小吴师兄<br>top: false<br>summary:<br>categories: LeetCode<br>tags:</p><ul><li>分治</li><li>快速</li></ul><hr><p>leetcode上第75号问题：<a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">Sort Colors</a></p><blockquote><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p></blockquote><blockquote><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p></blockquote><blockquote><p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p></blockquote><blockquote><p>示例:</p></blockquote><blockquote><p>输入: [2,0,2,1,1,0]</p></blockquote><blockquote><p>输出: [0,0,1,1,2,2]</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>结合三路快排partition思路的应用，设定两个索引，一个从左往右滑动<code>zero</code>，一个从右往左滑动<code>two</code>，遍历<code>nums</code>，当<code>nums[i]</code>的值为1时，<code>i++</code>；当<code>nums[i]</code>的值为2时，<code>two</code>的值先减1，而后交换<code>nums[i]</code>与<code>nums[two]</code>，此时在观察<code>nums[i]</code>的值；当<code>nums[i]</code>的值为0时，<code>zero++</code>，而后交换<code>nums[i]</code>与<code>nums[zero]</code>，<code>i++</code>;当 <code>i = two</code>时，结束循环。</p><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzl014a9kug30np0cp42x.gif" alt="Sort Colors"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 三路快速排序的思想// 对整个数组只遍历了一遍// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    void sortColors(vector&lt;int&gt; &amp;nums) {        int zero = -1;          // [0...zero] == 0        int two = nums.size();  // [two...n-1] == 2        for(int i = 0 ; i &lt; two ; ){            if(nums[i] == 1){                 i ++;            }else if (nums[i] == 2){                 two--;                 swap( nums[i] , nums[two]);            }else{ // nums[i] == 0                 zero++;                 swap(nums[zero] , nums[i]);                 i++;            }        }    }};</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode上第 94 号问题：二叉树的中序遍历</title>
      <link href="/2019/01/27/mei-tian-yi-suan-binary-tree-inorder-traversal-24/"/>
      <url>/2019/01/27/mei-tian-yi-suan-binary-tree-inorder-traversal-24/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第 94 号问题：<strong><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个二叉树，返回它的 中序 遍历。</p></blockquote><blockquote><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4></blockquote><blockquote><p><strong>输入:</strong> [1,null,2,3]  </p></blockquote><p> <img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181109101353.png" alt="">   </p><blockquote><p><strong>输出:</strong> [1,3,2]<br><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用<strong>栈(Stack)</strong>的思路来处理问题。</p><p>中序遍历的顺序为<strong>左-根-右</strong>，具体算法为：</p><ul><li>从根节点开始，先将根节点压入栈</li><li>然后再将其所有左子结点压入栈，取出栈顶节点，保存节点值</li><li>再将当前指针移到其右子节点上，若存在右子节点，则在下次循环时又可将其所有左子结点压入栈中</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkxkmfacog30qp0eywoh.gif" alt="动画演示"></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkxkq7y97j30u00u17db.jpg" alt="参考代码"></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 中序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 2 号问题：两个数字相加</title>
      <link href="/2019/01/27/mei-tian-yi-suan-add-two-numbers-31/"/>
      <url>/2019/01/27/mei-tian-yi-suan-add-two-numbers-31/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第 2 号问题：<strong><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">两个数字相加</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p></blockquote><blockquote><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p></blockquote><blockquote><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5></blockquote><blockquote><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>设立一个表示进位的变量<code>carried</code>，建立一个新链表，把输入的两个链表从头往后同时处理，每两个相加，将结果加上<code>carried</code>后的值作为一个新节点到新链表后面。</p><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkxjfcatug30qh0eon5c.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkxjhpat9j30ub0u0n4r.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 上第 26 号问题：删除排序数组中的重复项</title>
      <link href="/2019/01/27/mei-tian-yi-suan-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang-30/"/>
      <url>/2019/01/27/mei-tian-yi-suan-shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang-30/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第26 号问题：<strong><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">删除排序数组中的重复项</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><blockquote><p>给定数组 nums = [1,1,2], </p></blockquote><blockquote><p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p></blockquote><blockquote><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><blockquote><p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p></blockquote><blockquote><p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p></blockquote><blockquote><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用快慢指针来记录遍历的坐标。</p><ul><li>开始时这两个指针都指向第一个数字</li><li>如果两个指针指的数字相同，则快指针向前走一步</li><li>如果不同，则两个指针都向前走一步</li><li>当快指针走完整个数组后，慢指针当前的坐标加1就是数组中不同数字的个数</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkxjo8a76g30qg0esju1.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkxjmqk58j30xo0tktci.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 上第 454 号问题：4Sum II</title>
      <link href="/2019/01/27/mei-tian-yi-suan-4sum-ii-di-jiu-pian/"/>
      <url>/2019/01/27/mei-tian-yi-suan-4sum-ii-di-jiu-pian/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 上第 454 号问题：<strong><a href="https://leetcode-cn.com/problems/4sum-ii/" target="_blank" rel="noopener">4Sum II</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] &gt; + B[j] + C[k] + D[l] = 0。</p></blockquote><blockquote><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。</p></blockquote><blockquote><p><em>例如:</em></p></blockquote><blockquote><p>输入:<br>A = [ 1, 2]<br>B = [-2,-1]<br>C = [-1, 2]<br>D = [ 0, 2] </p></blockquote><blockquote><p>输出:<br>2 </p><p>解释:<br>两个元组如下:       </p><ol><li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0  </li><li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</li></ol></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>与<a href="https://xiaozhuanlan.com/topic/7923618450" target="_blank" rel="noopener">Two Sum</a>类似，需要用哈希表来解决问题。</p><ul><li>把A和B的两两之和都求出来，在哈希表中建立两数之和与其出现次数之间的映射</li><li>遍历C和D中任意两个数之和，只要看哈希表存不存在这两数之和的相反数就行了</li></ul><p>##动画演示</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkxffnjo7g30np0dbadt.gif" alt="4Sum II"></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><pre><code>// 454. 4Sum II// https://leetcode.com/problems/4sum-ii/description/// 时间复杂度: O(n^2)// 空间复杂度: O(n^2)class Solution {public:    int fourSumCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) {        unordered_map&lt;int,int&gt; hashtable;        for(int i = 0 ; i &lt; A.size() ; i ++){            for(int j = 0 ; j &lt; B.size() ; j ++){                 hashtable[A[i]+B[j]] += 1;            }        }        int res = 0;        for(int i = 0 ; i &lt; C.size() ; i ++){            for(int j = 0 ; j &lt; D.size() ; j ++){                if(hashtable.find(-C[i]-D[j]) != hashtable.end()){                    res += hashtable[-C[i]-D[j]];                }            }        }        return res;    }};</code></pre><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkxfhd78yj313c0i5wfd.jpg" alt="执行结果"></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 447 号问题：Number of Boomerangs</title>
      <link href="/2019/01/27/mei-tian-yi-suan-number-of-boomerangs/"/>
      <url>/2019/01/27/mei-tian-yi-suan-number-of-boomerangs/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第 447 号问题：<a href="https://leetcode-cn.com/problems/number-of-boomerangs/" target="_blank" rel="noopener">Number of Boomerangs</a></p><blockquote><p>给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 (i, j, k) ，其中 i 和 j 之间的距离和 &gt; i 和 k 之间的距离相等（需要考虑元组的顺序）。</p></blockquote><blockquote><p>找到所有回旋镖的数量。你可以假设 n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。</p></blockquote><blockquote><p>示例:</p></blockquote><blockquote><p>输入:<br>[[0,0],[1,0],[2,0]]   </p></blockquote><blockquote><p>输出:<br>2</p></blockquote><blockquote><p>解释:<br>两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>n最大为500，可以使用时间复杂度为 O(n^2)的算法。</p><ul><li>遍历所有的点，让每个点作为一个锚点</li><li>然后再遍历其他的点，统计和锚点距离相等的点有多少个</li><li>然后分别带入n(n-1)计算结果并累加到res中</li></ul><h5 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h5><h6 id="Tip1"><a href="#Tip1" class="headerlink" title="Tip1"></a>Tip1</h6><ul><li>如果有一个点a，还有两个点b和c，如果ab和ac之间的距离相等，那么就有两种排列方法abc和acb；</li><li>如果有三个点b，c，d都分别和a之间的距离相等，那么有六种排列方法，abc, acb, acd, adc, abd, adb；</li><li>如果有n个点和点a距离相等，那么排列方式为n(n-1)。</li></ul><h6 id="Tip2"><a href="#Tip2" class="headerlink" title="Tip2"></a>Tip2</h6><ul><li>计算距离时不进行开根运算, 以保证精度；</li><li>只有当n大于等于2时，res值才会真正增加，因为当n=1时，增加量为<code>1*(1-1)=0</code>。</li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkx8sx3zlg30qn0estfw.gif" alt=""></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 447. Number of Boomerangs// https://leetcode.com/problems/number-of-boomerangs/description/// 时间复杂度: O(n^2)// 空间复杂度: O(n)class Solution {public:    int numberOfBoomerangs(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) {        int res = 0;        for( int i = 0 ; i &lt; points.size() ; i ++ ){            // record中存储 点i 到所有其他点的距离出现的频次            unordered_map&lt;int, int&gt; record;            for(int j = 0 ; j &lt; points.size() ; j ++){                if(j != i){                    // 计算距离时不进行开根运算, 以保证精度                    record[dis(points[i], points[j])] += 1;                }            }            for(unordered_map&lt;int, int&gt;::iterator iter = record.begin() ; iter != record.end() ; iter ++){                res += (iter-&gt;second) * (iter-&gt;second - 1);            }        }        return res;    }private:    int dis(const pair&lt;int,int&gt; &amp;pa, const pair&lt;int,int&gt; &amp;pb){        return (pa.first - pb.first) * (pa.first - pb.first) +               (pa.second - pb.second) * (pa.second - pb.second);    }};</code></pre><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181030113403.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 元祖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 103 号问题：二叉树的锯齿形层次遍历</title>
      <link href="/2019/01/27/mei-tian-yi-suan-binary-tree-zigzag-level-order-traversal-28/"/>
      <url>/2019/01/27/mei-tian-yi-suan-binary-tree-zigzag-level-order-traversal-28/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第103 号问题：<strong><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">二叉树的锯齿形层次遍历</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p></blockquote><blockquote><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p></blockquote><blockquote><p> <img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181112084143.png" alt=""></p><p>返回其层次遍历结果：</p></blockquote><blockquote><p>[<br>   [3],<br>   [20,9],<br>   [15,7]<br>]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>该问题需要用到<strong>队列</strong>，与之前的<a href="https://xiaozhuanlan.com/topic/8579460312" target="_blank" rel="noopener">二叉树的层次遍历</a>类似，不同点在于在偶数层需要翻转一下。</p><ul><li>建立一个queue</li><li>先把根节点放进去，这时候找根节点的左右两个子节点</li><li>去掉根节点，此时queue里的元素就是下一层的所有节点</li><li>循环遍历，将结果存到一个一维向量里</li><li>遍历完之后再把这个一维向量存到二维向量里</li><li>如果该层为偶数层，则reverse翻转一下</li><li>以此类推，可以完成层序遍历</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkx5g05uxg30qg0esgy0.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkx56go9ij30xa0u0wgi.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建一个酷炫免费的个人博客</title>
      <link href="/2019/01/26/xin-shou-xiang-cong-ling-kai-shi-da-jian-yi-ge-ku-xuan-mian-fei-de-ge-ren-bo-ke/"/>
      <url>/2019/01/26/xin-shou-xiang-cong-ling-kai-shi-da-jian-yi-ge-ku-xuan-mian-fei-de-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="【新手向】从零开始搭建一个酷炫免费的个人博客"><a href="#【新手向】从零开始搭建一个酷炫免费的个人博客" class="headerlink" title="【新手向】从零开始搭建一个酷炫免费的个人博客"></a>【新手向】从零开始搭建一个酷炫免费的个人博客</h1><p>由于公众号的文章不易后续整理阅读，于是小吴昨天上午花了半个小时使用 GitHub + Hexo 搭建了一下个人博客，打算将公众号的文章搬过去，支持关键字搜索、分类标签功能。效果是下面这样子的👇</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk130ii6qg313l0ixx6q.gif" alt=""></p><p>结果后台好多小伙伴挺好奇博客是怎么搭建的，实际上这个挺简单的，小吴就从零开始分享一波如何搭建一个酷炫免费的个人博客吧，如果已经有博客的小伙伴可以留言一波网站地址：）</p><h3 id="GitHub创建个人仓库"><a href="#GitHub创建个人仓库" class="headerlink" title="GitHub创建个人仓库"></a>GitHub创建个人仓库</h3><p>登录到 GitHub ，如果没有 GitHub 帐号，请使用你的邮箱注册 GitHub 帐号：<a href="https://github.com/join?source=header-home">https://github.com/join?source=header-home</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk21xjx8gj31420myn1f.jpg" alt="注册"></p><p>登录成功之后，点击 GitHub 中的 New repository 创建新仓库，仓库名应该为：<strong>用户名</strong> .github.io 。这里<strong>用户名</strong>使用你的 GitHub 帐号名称代替，这是固定写法。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzk2601f8kg313l0ixqca.gif" alt="创建新仓库"></p><p>ps: 因为我已经注册了同名仓库，因此第二次创建时会报错。</p><p>我的仓库名为👇：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk29gwq48j30fu03igls.jpg" alt="仓库名"></p><h3 id="Git管理"><a href="#Git管理" class="headerlink" title="Git管理"></a>Git管理</h3><p>Git 是目前世界上最先进的分布式版本控制系统（没有之一）。这是使用 Git 的目的是为了将我们的网站从本地提交上服务器（GitHub）上面去。我认为 Git 操作是程序员应该具备的一个基本操作，具体的 Git 操作细节可以查看廖雪峰的教程，讲的十分详细 <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk2hsewy8j313r0k0n5i.jpg" alt=""></p><p>安装好 Git 后，只需要进行下面的配置即可。</p><h4 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h4><p>在终端进行操作，设置 user.name 和 user.email 配置信息，我这里设置为全局。</p><pre class=" language-java"><code class="language-java">git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>name <span class="token string">"你的GitHub用户名"</span>git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>email <span class="token string">"你的GitHub注册邮箱"</span></code></pre><h4 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h4><p>通过注册的邮箱生成 ssh 密钥文件：</p><pre class=" language-bash"><code class="language-bash">ssh-keygen -t rsa -C <span class="token string">"你的GitHub注册邮箱"</span></code></pre><p>然后直接三个回车即可，默认不需要设置密码。最后得到了两个文件：<code>id_rsa</code>和<code>id_rsa.pub</code>。</p><h4 id="拷贝密钥"><a href="#拷贝密钥" class="headerlink" title="拷贝密钥"></a>拷贝密钥</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk2vog35vj30mw0f2mzq.jpg" alt="拷贝密钥"></p><p>打开 <code>id_rsa.pub 文件</code>，将里面的内容全部复制。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzk2xjwnthj30tv0b5dh4.jpg" alt="内容全部复制"></p><h4 id="粘贴到GitHub"><a href="#粘贴到GitHub" class="headerlink" title="粘贴到GitHub"></a>粘贴到GitHub</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzk36z40lzj313s0k1n08.jpg" alt="GitHub SSh"></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk376rh7yj313r0ketbj.jpg" alt="添加新的 SSH"></p><h4 id="测试GitHub-SSH"><a href="#测试GitHub-SSH" class="headerlink" title="测试GitHub SSH"></a>测试GitHub SSH</h4><p>添加好 <code>SSH Key</code>后，进行测试。</p><pre><code>ssh -T git@github.com</code></pre><p>你将会看到：</p><pre><code>The authenticity of host &#39;github.com (207.97.227.239)&#39; can&#39;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)?</code></pre><p>选择 <code>yes</code></p><pre><code>Hi MisterBooo! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk3bfd4wzj30i10213yk.jpg" alt="ssh -T"></p><p>如果看到<code>Hi</code>后面是你的用户名，就说明成功了。</p><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>Hexo 基于 Node.js，因此需要先安装 Node.js，你可以在这里进行对应电脑版本的下载：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzk3ecq45aj313u0jkju0.jpg" alt="Node.js下载"></p><p>你也可以通过命令行进行安装：</p><p>cURL:</p><pre><code>$ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</code></pre><p>Wget:</p><pre><code>$ wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</code></pre><p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p><pre><code>$ nvm install stable</code></pre><h3 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><pre><code>$ npm install -g hexo-cli</code></pre><h3 id="Hexo使用"><a href="#Hexo使用" class="headerlink" title="Hexo使用"></a>Hexo使用</h3><p>安装好 Hexo 后，马上就能使用了。首先初始化博客，输入：</p><pre><code>$ hexo init myBlog</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk3pvt34mj319f0u0qcz.jpg" alt=""></p><p>接下来，进入文件夹 <code>myBlog</code>,输入</p><pre><code>$ hexo s</code></pre><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk3s50l94j30hy054t96.jpg" alt=""></p><p>然后，打开浏览器输入地址：</p><pre><code>localhost:4000</code></pre><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk3te442qj313t0n1gxs.jpg" alt="hexo网站"></p><p>执行到这里事实上博客就已经搭建好了，接下来就是去完善它。</p><p>注意：下面的命令都是在 <code>myBlog</code>文件里进行操作的。</p><h3 id="添加文章"><a href="#添加文章" class="headerlink" title="添加文章"></a>添加文章</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk7dls02rj31840kiaco.jpg" alt="添加文章"></p><h4 id="1-直接导入文章"><a href="#1-直接导入文章" class="headerlink" title="1.直接导入文章"></a>1.直接导入文章</h4><p>你可以将你平时写的文章直接导入到 <code>_posts</code>  文件夹里，注意文章类型得是 <code>md</code>格式。</p><h4 id="2-写新文章"><a href="#2-写新文章" class="headerlink" title="2.写新文章"></a>2.写新文章</h4><p>你可以执行下列命令来创建一篇新文章。</p><pre><code>$ hexo new [layout] &lt;title&gt;</code></pre><p>你可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk7hoiy3ij30z6042q3w.jpg" alt="写新文章"></p><p>这样在 <code>_posts</code>  文件夹里也生成了一篇新的文章。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzk7j5ffx5j316c0ewmzp.jpg" alt="新的文章"></p><h3 id="生成网页"><a href="#生成网页" class="headerlink" title="生成网页"></a>生成网页</h3><p>使用 Hexo 生成静态文件快速而且简单。</p><pre><code>$ hexo generate</code></pre><p>你也可以简写成</p><pre><code>$ hexo g</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk7n3i1jyj318d0u0wpf.jpg" alt="生成文章"></p><h3 id="启动服务预览文章"><a href="#启动服务预览文章" class="headerlink" title="启动服务预览文章"></a>启动服务预览文章</h3><p>输入以下命令以启动服务器，你的网站会在 <code>http://localhost:4000</code> 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，无须重启服务器。</p><pre><code>$ hexo server</code></pre><p>你也可以简写成</p><pre><code>$ hexo s</code></pre><p>如果你想要更改端口，或是在执行时遇到了 <code>EADDRINUSE</code> 错误，可以在执行时使用 <code>-p</code> 选项指定其他端口，如下：</p><pre><code>$ hexo server -p 5000</code></pre><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzk7pthinwj315606kdhh.jpg" alt="查看文章"></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzk7rs1dp8j31iy0u0e81.jpg" alt="网站"></p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><pre><code>hexo new &quot;我的博客文章&quot; #新建文章</code></pre><pre><code>hexo generate #生成网页</code></pre><pre><code>hexo server #启动服务预览</code></pre><p>这三个命令依次就是新建一篇博客文章、生成网页、在本地预览的操作。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>Hexo 提供了快速方便的一键部署功能，只需一条命令就能将网站部署到服务器上。</p><pre><code>$ hexo deploy</code></pre><p>你也可以简写成</p><pre><code>$ hexo d</code></pre><p>在开始之前，必须先在 <code>_config.yml</code> 中修改参数，一个正确的部署配置中至少要有 <code>type</code> 参数，例如：</p><pre><code>deploy:  type: git</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk7w0wzlyj30mk0eetae.jpg" alt="config"></p><p>在<code>_config.yml</code>中进行修改。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzk7xrf4smj30y40u00yx.jpg" alt=""></p><p>这一步的目的是将 Hexo 与 GitHub 进行关联。</p><p>配置好后通过</p><pre><code>$ hexo d</code></pre><p>命令，稍等片刻，网站就已经部署好了，可以在浏览器输入<code>你的GitHub名称.github.io</code>，这样一个免费的博客就已经搭建好了。</p><h3 id="Hexo-主题"><a href="#Hexo-主题" class="headerlink" title="Hexo 主题"></a>Hexo 主题</h3><p>hexo 默认的主题可能显得有点呆板，你可以在 <a href="https://hexo.io/themes/index.html" target="_blank" rel="noopener">https://hexo.io/themes/index.html</a>进行主题的挑选更换。将下好的主题安放在<code>themes</code>文件夹内，同时在<code>_config.yml</code>中进行主题修改就好了。</p><p>经过一个小时的主题筛选，我选择了<code>hexo-theme-matery</code> 这款主题。通过<a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/" target="_blank" rel="noopener">https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/</a>文档说明，经过简单的配置，效果就出来了！</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzk9f1968uj30yk0jmtb2.jpg" alt=""></p><p>一般大佬们提供的主题都会提供文档说明，按照说明进行简单的设置就能拥有一个酷炫的页面了。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk130ii6qg313l0ixx6q.gif" alt=""></p><h3 id="Markdown-写作"><a href="#Markdown-写作" class="headerlink" title="Markdown 写作"></a>Markdown 写作</h3><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><p>世面上支持 Markdown 语法的编辑器不胜枚举，选择起来十分困难，小吴在这里推荐 Typora 这款 Markdown 写作软件。</p><p> Typora 是一款免费的 MD 编辑器，它是优雅简洁与强大开放的完美结合体。</p><p>官网直达 <a href="https://typora.io" target="_blank" rel="noopener">https://typora.io</a></p><h4 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h4><p>选择 Typora 一个最主要的原因是它对图片的良好支持。</p><p>在 Mac 上安装好 iPic 后 ，并在设置中将图片插入修改为 通过 iPic 上传 ，快捷键是 control + command + i ，就可以十分快捷优雅地完成图片插入。强调一点：图床使用默认的微博图床即可，建议不要折腾。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzk9r3q6toj30s40rwh1u.jpg" alt=""></p><p>这样，每次写作时，将图片拖入到 Typora 里，图片就能自动上传到图床上。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>申请 GitHub 账号</p></li><li><p>在 GitHub 上创建仓库</p></li><li><p>配备 Git ，同时将 SSH Key 提交到 GitHub 上</p></li><li><p>安装 Node.js</p></li><li><p>安装 Hexo</p></li><li><p>安装 Hexo 主题</p></li><li><p>使用 Markdown 软件写文章</p></li></ul><p>希望这篇文章能帮到想写博客却还没付诸行动的人，毕竟拥有一个免费且酷炫的博客还是挺简单还挺好玩的：）</p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新手 </tag>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode上第 75 号问题： Two Sum II</title>
      <link href="/2019/01/26/75/"/>
      <url>/2019/01/26/75/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/10/29/166bdc86b1885e65?w=2294&amp;h=1412&amp;f=png&amp;s=261824" alt=""><br>leetcode上第75号问题：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">Two Sum II</a></p><blockquote><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p></blockquote><blockquote><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p></blockquote><blockquote><p>说明:</p></blockquote><blockquote><ul><li>返回的下标值（index1 和 index2）不是从零开始的。</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ul></blockquote><blockquote><p>示例:</p></blockquote><blockquote><p>输入: numbers = [2, 7, 11, 15], target = 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>初始化左指针left指向数组起始，初始化右指针right指向数组结尾。</p><p>根据<strong>已排序</strong>这个特性，</p><ul><li><p>（1）如果numbers[left]与numbers[right]的和tmp小于target，说明应该增加tmp,因此left右移指向一个较大的值。</p></li><li><p>（2）如果tmp大于target，说明应该减小tmp,因此right左移指向一个较小的值。</p></li><li><p>（3）tmp等于target，则找到，返回left+1和right+1。（注意以1为起始下标）</p></li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://user-gold-cdn.xitu.io/2018/10/29/166bdc5dfb63ea8d?w=853&amp;h=457&amp;f=gif&amp;s=69203" alt=""></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对撞指针</span><span class="token comment" spellcheck="true">// 时间复杂度: O(n)</span><span class="token comment" spellcheck="true">// 空间复杂度: O(1)</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">twoSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> numbers<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> res<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> res<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span>                l <span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token comment" spellcheck="true">// numbers[l] + numbers[r] > target</span>                r <span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode上第 283 号问题： Move Zeros</title>
      <link href="/2019/01/26/283/"/>
      <url>/2019/01/26/283/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669facb3a2bb86e?w=1240&amp;h=574&amp;f=png&amp;s=228428" alt="Move Zeros"><br>leetcode上第283号问题：<a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">Move Zeros</a></p><blockquote><p>给定一个数组nums，写一个函数，将数组中所有的0挪到数组的末尾，⽽维持其他所有非0元素的相对位置。<br>举例: nums = [0, 1, 0, 3, 12]，函数运⾏后结果为[1, 3, 12, 0, 0]</p></blockquote><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>思路：创建一个临时数组nonZeroElements，遍历nums，将nums中非0元素赋值到nonZeroElements中，而后按顺序将nonZeroElements赋值到nums上，未遍历的元素置0；</p><p>动画如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669facb3a048c12?w=420&amp;h=203&amp;f=gif&amp;s=60758" alt="image"></p><p>代码如下：</p><pre><code>// 时间复杂度: O(n)// 空间复杂度: O(n)class Solution {public:    void moveZeroes(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; nonZeroElements;        // 将vec中所有非0元素放入nonZeroElements中        for(int i = 0 ; i &lt; nums.size() ; i ++)            if(nums[i])                nonZeroElements.push_back(nums[i]);        // 将nonZeroElements中的所有元素依次放入到nums开始的位置        for(int i = 0 ; i &lt; nonZeroElements.size() ; i ++)            nums[i] = nonZeroElements[i];        // 将nums剩余的位置放置为0        for(int i = nonZeroElements.size() ; i &lt; nums.size() ; i ++)            nums[i] = 0;    }};</code></pre><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>思路：设定一个临时变量k=0，遍历数组nums，将非零元素移动到nums[k]位置，同时k++，而后将【k,….nums.size()】中的元素置零。</p><p>动画如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669facb3a3f2742?w=744&amp;h=418&amp;f=gif&amp;s=104124" alt="image"></p><p>代码如下：</p><pre><code>// 原地(in place)解决该问题// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    void moveZeroes(vector&lt;int&gt;&amp; nums) {        int k = 0; // nums中, [0...k)的元素均为非0元素        // 遍历到第i个元素后,保证[0...i]中所有非0元素        // 都按照顺序排列在[0...k)中        for(int i = 0 ; i &lt; nums.size() ; i ++)            if(nums[i])                nums[k++] = nums[i];        // 将nums剩余的位置放置为0        for(int i = k ; i &lt; nums.size() ; i ++)            nums[i] = 0;    }};</code></pre><h3 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h3><p>思路：设定一个临时变量k=0，遍历数组nums，将非零元素与之前的零元素进行交换，维护变量k的值。</p><p>动画如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669facb3a1f570c?w=744&amp;h=418&amp;f=gif&amp;s=92514" alt="image"></p><p>代码如下：</p><pre><code>// 原地(in place)解决该问题// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    void moveZeroes(vector&lt;int&gt;&amp; nums) {        int k = 0; // nums中, [0...k)的元素均为非0元素        // 遍历到第i个元素后,保证[0...i]中所有非0元素        // 都按照顺序排列在[0...k)中        // 同时, [k...i] 为 0        for(int i = 0 ; i &lt; nums.size() ; i ++)            if(nums[i])                if(k != i)                    swap(nums[k++] , nums[i]);                else                    k ++;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示桶排序</title>
      <link href="/2019/01/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-tong-pai-xu/"/>
      <url>/2019/01/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-tong-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解桶排序"><a href="#【图解数据结构】-一组动画彻底理解桶排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解桶排序"></a>【图解数据结构】 一组动画彻底理解桶排序</h1><p>由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 —–《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序(Bucket sort)是一种基于计数的排序算法（<strong>计数排序</strong>可参考上节的内容），工作的原理是将数据分到有限数量的桶子里，然后每个桶再分别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>设置固定数量的空桶。</p></li><li><p>把数据放到对应的桶中。</p></li><li><p>对每个不为空的桶中数据进行排序。</p></li><li><p>拼接不为空的桶中数据，得到结果。</p></li></ol><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/29/1675ceff66c00fe7?w=955&amp;h=539&amp;f=gif&amp;s=1026397" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，设置固定数量的空桶，在这里为了方便演示，设置桶的数量为 5 个空桶</p></li><li><p>遍历整个数列，找到最大值为 56 ，最小值为 2 ，每个桶的范围为 （ 56 - 2 + 1 ）/ 5 = 11</p></li><li><p>再次遍历整个数列，按照公式 floor((数字 – 最小值) / 11) 将数字放到对应的桶中</p></li><li><p>比如，数字 7 代入公式 floor((7 – 2) / 11) = 0 放入 0 号桶</p></li><li><p>数字 12 代入公式 floor((12 – 2) / 11) = 0 放入 0 号桶</p></li><li><p>数字 56 代入公式 floor((56 – 2) / 11) = 4 放入 4 号桶</p></li><li><p>当向同一个索引的桶，第二次插入数据时，判断桶中已存在的数字与新插入数字的大小，按照左到右，从小到大的顺序插入（可以使用前面讲解的<strong>插入排序</strong>）实现</p></li><li><p>比如，插入数字 19 时， 1 号桶中已经有数字 23 ，在这里使用插入排序，让 19 排在 23 前面</p></li><li><p>遍历完整个数列后，合并非空的桶，按从左到右的顺序合并0，1，2，3，4桶。</p></li><li><p>这样就完成了 <strong>桶排序</strong></p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/29/1675ceff669fd15d?w=1864&amp;h=2122&amp;f=png&amp;s=80844" alt=""></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/29/1675ceff66c62d33?w=2016&amp;h=3272&amp;f=png&amp;s=170854" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/29/1675ceff66b31247?w=2048&amp;h=2260&amp;f=png&amp;s=131496" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 桶排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示快速排序</title>
      <link href="/2019/01/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-kuai-su-pai-xu/"/>
      <url>/2019/01/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-kuai-su-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解快速排序"><a href="#【图解数据结构】-一组动画彻底理解快速排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解快速排序"></a>【图解数据结构】 一组动画彻底理解快速排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 —–《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>从数列中挑出一个元素，称为 “基准”（pivot）;</p></li><li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p></li></ol><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e00a0d10d84d?w=950&amp;h=534&amp;f=gif&amp;s=492246" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，操作数列中的所有数字</p></li><li><p>在所有数字中选择一个数字作为排序的基准（pivot）, pivot 通常是随机选择的，在这里为了演示方便，我们选择最右边的数字作为 pivot</p></li><li><p>选取好 pivot 后，在操作数列中选择最左边的数字标记为 左标记 ，最右边的数字标记为 右标记</p></li><li><p>将左边的标记向右移动</p></li><li><p>当 左标记 达到超过 pivot 的数字时，停止移动</p></li><li><p>在这里，8 &gt; 6 ,所以停止移动</p></li><li><p>然后将右边的标记向左移动</p></li><li><p>当 右标记 达到小于 pivot 的数字时，停止移动</p></li><li><p>在这里，4 &gt; 6 ,所以停止移动</p></li><li><p>当左右标记停止时，更改标记的数字</p></li><li><p>因此，左标记 的作用是找到一个大于 pivot 的数字，右标记 的作用是找到一个小于 pivot 的数字</p></li><li><p>通过交换数字，可以在数列的左边收集小于 pivot 的数字集合，右边收集大于 pivot 的数字集合</p></li><li><p>交换之后，继续移动 左标记</p></li><li><p>在这里，9 &gt; 6 ,所以停止移动</p></li><li><p>然后将右边的标记向左移动</p></li><li><p>当 右标记 碰撞到 左标记 时也停止移动</p></li><li><p>如果左右侧的标记停止时，并且都在同一个位置，将这个数字和 pivot 的数字交换</p></li><li><p>这就完成了第一次操作</p></li><li><p>小于 6 的都在 6 的左侧，大于 6 的都在 6 的右侧</p></li><li><p>然后递归对这分成的两部分都执行同样的操作</p></li><li><p>完成 快速排序</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e00a0dc023d8?w=1392&amp;h=1524&amp;f=png&amp;s=68959" alt="C++代码实现"></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e00a0cb5d352?w=1668&amp;h=2214&amp;f=png&amp;s=109067" alt="Java代码实现"></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e00a0c058ac5?w=1756&amp;h=1432&amp;f=png&amp;s=74882" alt="Python代码实现"></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e00a0e6e21b7?w=1572&amp;h=2950&amp;f=png&amp;s=139434" alt="JavaScript代码实现"></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示基数排序</title>
      <link href="/2019/01/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-ji-shu-pai-xu/"/>
      <url>/2019/01/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-ji-shu-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解基数排序"><a href="#【图解数据结构】-一组动画彻底理解基数排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解基数排序"></a>【图解数据结构】 一组动画彻底理解基数排序</h1><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序 (Radix Sort) 是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。基数排序的发明可以追溯到 1887 年赫尔曼·何乐礼在打孔卡片制表机 (Tabulation Machine)上的贡献。</p><p>基数排序法会使用到桶 (Bucket)，顾名思义，通过将要比较的位（个位、十位、百位…），将要排序的元素分配至 0~9 个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其它的比较性排序法。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零</p></li><li><p>从最低位开始，依次进行一次排序</p></li><li><p>从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列</p></li></ol><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^<br><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181128114235.gif" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>基数排序的方式可以采用 LSD (Least sgnificant digital) 或 MSD (Most sgnificant digital)</p></li><li><p>在本例中使用的是 <strong>LSD</strong></p></li><li><p>首先创建编号 0 ， 1 ，2 ，3 ，4 ，5 ， 6 ，7 ，8 ，9 这 10 个桶 </p></li><li><p>遍历整个数列，查看数字的个位数，按照先后顺序存放在对应编号的桶中</p></li><li><p>比如 321 个位数 为 1 ，存放在编号 1 桶中</p></li><li><p>数字 1 个位数 为 1 ，存放在编号 1 桶中，同时存放在 321 上面 </p></li><li><p>遍历完整个数列的个位数，将数字存放在桶中后，按照编号顺序取出数字，先放入桶中的数字先取出</p></li><li><p>然后依次遍历整个数列的十位数，按照上述个位数的操作整理数列</p></li><li><p>依次遍历整个数列的百位数，按照上述个位数的操作整理数列</p></li><li><p>这样就完成了 <strong>基数排序</strong></p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181128123735.png" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181128123743.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基数排序 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示选择排序</title>
      <link href="/2019/01/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-yan-shi-xuan-ze-pai-xu/"/>
      <url>/2019/01/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-yan-shi-xuan-ze-pai-xu/</url>
      
        <content type="html"><![CDATA[<p># </p><h1 id="【图解数据结构】-一组动画演示选择排序"><a href="#【图解数据结构】-一组动画演示选择排序" class="headerlink" title="【图解数据结构】 一组动画演示选择排序"></a>【图解数据结构】 一组动画演示选择排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 —–《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</p></li><li><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p></li><li><p>重复第二步，直到所有元素均排序完毕。</p></li></ol><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/16738f0f5824e2d8?w=955&amp;h=538&amp;f=gif&amp;s=346690" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>线性搜索数列并找到最小值，此时找到了为 2</p></li><li><p>将最小值替换为数列中左端的数字，即将 2 与 4 进行交换</p></li><li><p>此时 2 已经排序好</p></li><li><p>继续线性搜索剩余数列找到最小值，此时找到了 3</p></li><li><p>将最小值替换为数列中左端的数字，即将 3 与 4 进行交换</p></li><li><p>此时 2 与 3 已经排序好</p></li><li><p>继续线性搜索剩余数列找到最小值，此时找到了 4</p></li><li><p>如果最小值已经在左端，那么不执行任何操作，所以此时不做任何处理</p></li><li><p>此时 2 、 3  、 4 已经排序好</p></li><li><p>重复相同操作，直到所有数字都被排序</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/16738f0eff237d54?w=1148&amp;h=972&amp;f=png&amp;s=36827" alt=""></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/16738f0f0a65d4cf?w=1668&amp;h=1708&amp;f=png&amp;s=75701" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/16738f0ef955a299?w=1604&amp;h=1110&amp;f=png&amp;s=51471" alt=""></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/16738f0f0156b4cc?w=1452&amp;h=880&amp;f=png&amp;s=44413" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 选择排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一组动画演示归并排序</title>
      <link href="/2019/01/26/tu-jie-shu-ju-jie-gou-wu-fen-zhong-xue-suan-fa-zhi-yi-zu-dong-hua-yan-shi-gui-bing-pai-xu/"/>
      <url>/2019/01/26/tu-jie-shu-ju-jie-gou-wu-fen-zhong-xue-suan-fa-zhi-yi-zu-dong-hua-yan-shi-gui-bing-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画演示归并排序"><a href="#【图解数据结构】-一组动画演示归并排序" class="headerlink" title="【图解数据结构】 一组动画演示归并排序"></a>【图解数据结构】 一组动画演示归并排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 —–《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。</p><h2 id="归并排序（Merge-sort"><a href="#归并排序（Merge-sort" class="headerlink" title="归并排序（Merge sort"></a>归并排序（Merge sort</h2><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ul><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li><li>自下而上的迭代；</li></ul><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p></li><li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p></li><li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p></li><li><p>重复步骤 3 直到某一指针达到序列尾；</p></li><li><p>将另一序列剩下的所有元素直接复制到合并序列尾。</p></li></ol><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16733b1a9c74ce50?w=955&amp;h=538&amp;f=gif&amp;s=586156" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，将数字分割成两片区域</p></li><li><p>将数字分割成两片区域</p></li><li><p>。。。。。。</p></li><li><p>直到每片区域只有一个元素</p></li><li><p>分割完成</p></li><li><p>接下来，将分割的每片区域进行合并组合</p></li><li><p>合并时，按照数字的升序移动，使得合并后的数字在组内按升序排列</p></li><li><p>当合并包含多个数字的组时，比较开头的数字，移动其中较小的数字</p></li><li><p>比如在动画中，比较开头的 4 和 3 </p></li><li><p>其中 4 大于 3， 因此移动 3</p></li><li><p>按照同样的逻辑去比较该列剩余的头数</p></li><li><p>4 小于 7 ，所以移动 4</p></li><li><p>。。。。。。</p></li><li><p>递归的重复组的合并操作，直到所有数字都在一个组中。</p></li><li><p>完成 归并排序 啦~</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16733b1a9c8f7fff?w=1832&amp;h=1708&amp;f=png&amp;s=85502" alt="C++代码实现"></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16733b1a9db220c7?w=1668&amp;h=2444&amp;f=png&amp;s=128379" alt="Java代码实现"></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16733b1a9dd4b5f7?w=1322&amp;h=1294&amp;f=png&amp;s=64894" alt="Python代码实现"></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16733b1a9dcea382?w=1344&amp;h=1800&amp;f=png&amp;s=76855" alt="JavaScript代码实现"></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示冒泡排序</title>
      <link href="/2019/01/26/tu-jie-shu-ju-jie-gou-dong-hua-yan-shi-mou-pao-pai-xu/"/>
      <url>/2019/01/26/tu-jie-shu-ju-jie-gou-dong-hua-yan-shi-mou-pao-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画演示冒泡排序"><a href="#【图解数据结构】-一组动画演示冒泡排序" class="headerlink" title="【图解数据结构】 一组动画演示冒泡排序"></a>【图解数据结构】 一组动画演示冒泡排序</h1><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p></li><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p></li><li><p>针对所有的元素重复以上的步骤，除了最后一个。</p></li><li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p></li></ol><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181119200024.gif" alt="五分钟学算法之冒泡排序"></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>将天平放在序列的右端，并比较天平左右的数字</p></li><li><p>在这种情况下我们比较 3 和 8 </p></li><li><p>比较后如果右边的数字较小，则被交换</p></li><li><p>因为 8 大于 3 ，所以数字不用交换</p></li><li><p>比较完成后，将天平向左移动一个位置，比较数字</p></li><li><p>因为 3 大于 2 ，所以数字不用交换</p></li><li><p>比较完成后，逐一移动天平，比较数字</p></li><li><p>此时 2 小于 4 ，所以左右的数字互相交换</p></li><li><p>重复同样的操作，直到天平移动到左端</p></li><li><p>。。。。。。</p></li><li><p>天平到达左端</p></li><li><p>经过上述的操作，数列中最小的数字已经移动到左端</p></li><li><p>将天平返回右端</p></li><li><p>重复相同的操作，直到所有数字都被排序</p></li><li><p>。。。。。。</p></li><li><p>吐完泡泡了</p></li></ol><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181119201851.png" alt=""></p><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181119201910.png" alt=""></p><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181119201417.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 冒泡排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示希尔排序</title>
      <link href="/2018/11/29/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-xi-er-pai-xu/"/>
      <url>/2018/11/29/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-xi-er-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解希尔排序"><a href="#【图解数据结构】-一组动画彻底理解希尔排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解希尔排序"></a>【图解数据结构】 一组动画彻底理解希尔排序</h1><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</p></li><li><p>按增量序列个数 k，对序列进行 k 趟排序；</p></li><li><p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p></li></ol><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，选择增量 gap = 10/2 ，缩小增量继续以 gap = gap/2 的方式</p></li><li><p>初始增量为 gap = 10/2 = 5，整个数组分成了 5 组</p></li><li><p>按颜色划分为【 8 , 3 】，【 9 , 5 】，【 1 , 4 】，【 7 , 6 】，【 2 , 0 】</p></li><li><p>对这分开的 5 组分别使用上节所讲的插入排序</p></li><li><p>结果可以发现，这五组中的相对小元素都被调到前面了</p></li><li><p>缩小增量 gap = 5/2 = 2，整个数组分成了 2 组</p></li><li><p>【 3 , 1 , 0 , 9 , 7  】，【 5 , 6 , 8 , 4 , 2  】</p></li><li><p>对这分开的 2 组分别使用上节所讲的插入排序</p></li><li><p>此时整个数组的有序性是很明显的</p></li><li><p>再缩小增量 gap = 2/2 = 1，整个数组分成了 1 组</p></li><li><p>【 0, 2 , 1 , 4 , 3 , 5 , 7 , 6 , 9 , 0  】</p></li><li><p>此时，只需要对以上数列进行简单的微调，不需要大量的移动操作即可完成整个数组的排序</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674859d8e945f1a?w=1280&amp;h=1037&amp;f=png&amp;s=167873" alt=""></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674859d8dda4858?w=1280&amp;h=1275&amp;f=png&amp;s=248791" alt=""></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674859d902e21b0?w=1128&amp;h=1110&amp;f=png&amp;s=53723" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674859d8e52ee54?w=1280&amp;h=934&amp;f=png&amp;s=185891" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 希尔排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示堆排序</title>
      <link href="/2018/11/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-dui-pai-xu/"/>
      <url>/2018/11/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-dui-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解堆排序"><a href="#【图解数据结构】-一组动画彻底理解堆排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解堆排序"></a>【图解数据结构】 一组动画彻底理解堆排序</h1><h2 id="预备知识：堆结构"><a href="#预备知识：堆结构" class="headerlink" title="预备知识：堆结构"></a>预备知识：堆结构</h2><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p><h4 id="大顶堆"><a href="#大顶堆" class="headerlink" title="大顶堆"></a>大顶堆</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181125194044.png" alt=""></p><h4 id="小顶堆"><a href="#小顶堆" class="headerlink" title="小顶堆"></a>小顶堆</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181125194056.png" alt=""></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序（Heapsort）是指利用堆这种数据结构（后面的【图解数据结构】内容会讲解分析）所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ul><li><p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p></li><li><p>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p></li></ul><p>堆排序的平均时间复杂度为 Ο(nlogn)。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>创建一个堆 H[0……n-1]；</p></li><li><p>把堆首（最大值）和堆尾互换；</p></li><li><p>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</p></li><li><p>重复步骤 2，直到堆的尺寸为 1。</p></li></ol><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181125191942.gif" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，将所有的数字存储在堆中</p></li><li><p>按大顶堆构建堆，其中大顶堆的一个特性是数据将被从大到小取出，将取出的数字按照相反的顺序进行排列，数字就完成了排序</p></li><li><p>在这里数字 5 先入堆</p></li><li><p>数字 2 入堆</p></li><li><p>数字 7 入堆， 7 此时是最后一个节点，与最后一个非叶子节点（也就是数字 5 ）进行比较，由于 7 大于 5 ，所以 7 和 5 交互</p></li><li><p>按照上述的操作将所有数字入堆，然后从左到右，从上到下进行调整，构造出大顶堆</p></li><li><p>入堆完成之后，将堆顶元素取出，将末尾元素置于堆顶，重新调整结构，使其满足堆定义</p></li><li><p>堆顶元素数字 7 取出，末尾元素数字 4 置于堆顶，为了维护好大顶堆的定义，最后一个非叶子节点数字 5 与 4 比较，而后交换两个数字的位置</p></li><li><p>反复执行调整+交换步骤，直到整个序列有序</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="Go代码实现"><a href="#Go代码实现" class="headerlink" title="Go代码实现"></a>Go代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126100338.png" alt=""></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126100347.png" alt=""></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126100353.png" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126100358.png" alt=""></p><p>如果你是iOS开发者，可以在GitHub上 <a href="https://github.com/MisterBooo/Play-With-Sort-OC">https://github.com/MisterBooo/Play-With-Sort-OC</a> 获取更直观可调试运行的源码。</p><p>你可以在公众号 <strong>五分钟学算法</strong> 获取更多排序内容。</p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示插入排序</title>
      <link href="/2018/11/24/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-yan-shi-cha-ru-pai-xu/"/>
      <url>/2018/11/24/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-yan-shi-cha-ru-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画演示插入排序"><a href="#【图解数据结构】-一组动画演示插入排序" class="headerlink" title="【图解数据结构】 一组动画演示插入排序"></a>【图解数据结构】 一组动画演示插入排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 —–《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p></li><li><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）。</p></li></ol><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181120164938.gif" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>一开始左端数字已经排序，数字 5 不动</p></li><li><p>然后，取出剩余未操作的左端数字 3 </p></li><li><p>将其与已经操作的左侧数字相比较</p></li><li><p>如果左边的数字较大，则交换两个数字</p></li><li><p>这种情况下，由于 5 大于 3 ，所以交换两个数字</p></li><li><p>重复此操作，直到出现一个较小的数字或者数字到达左端</p></li><li><p>数字 3 已经完成排序</p></li><li><p>接下来，和之前一样取出剩余未操作的左端数字 4  </p></li><li><p>与其相邻的左边数字进行比较</p></li><li><p>这种情况下，由于 5 大于 4 ，所以交换两个数字</p></li><li><p>继续操作，由于 3 小于 4 ，即出现了更小的数字，所以 4 停止移动</p></li><li><p>数字 4 已经完成排序</p></li><li><p>重复相同的操作，直到所有的数字完成排序</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="http://upload-images.jianshu.io/upload_images/1940317-ce2bac560fc4620a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="http://upload-images.jianshu.io/upload_images/1940317-e29b04076de62c3a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="http://upload-images.jianshu.io/upload_images/1940317-25d430ac861b8bdd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="http://upload-images.jianshu.io/upload_images/1940317-575eb47403e08c3f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 插入排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示计数排序</title>
      <link href="/2018/11/24/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-ji-shu-pai-xu/"/>
      <url>/2018/11/24/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-ji-shu-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解计数排序"><a href="#【图解数据结构】-一组动画彻底理解计数排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解计数排序"></a>【图解数据结构】 一组动画彻底理解计数排序</h1><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序是一种非基于比较的排序算法，其空间复杂度和时间复杂度均为O(n+k)，其中k是整数的范围。基于比较的排序算法时间复杂度最小是O(nlogn)的。该算法于1954年由 Harold H. Seward 提出。</p><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有<strong>确定范围的整数</strong>。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max</p></li><li><p>开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1)</p></li><li><p>数组 B 中 index 的元素记录的值是 A 中某元素出现的次数</p></li><li><p>最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数</p></li></ol><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126190814.gif" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，扫描一下整个序列</p></li><li><p>获得最小值为 2 ，最大值为 7</p></li><li><p>新建数组包含 2~7 的元素</p></li><li><p>再次扫描序列，将序列的值放置在新建数组中</p></li><li><p>扫描数字 5，数组中 index 为 3 的值为 5，次数为 1</p></li><li><p>扫描数字 3，数组中 index 为 1 的值为 3，次数为 1</p></li><li><p>扫描数字 4，数组中 index 为 2 的值为 4，次数为 1</p></li><li><p>扫描数字 7，数组中 index 为 5 的值为 7，次数为 1</p></li><li><p>扫描数字 2，数组中 index 为 0 的值为 2，次数为 1</p></li><li><p>扫描数字 4，数组中 index 为 2 的值为 4，次数为 2</p></li><li><p>扫描数字 3，数组中 index 为 1 的值为 3，次数为 2</p></li><li><p>按照这种节奏，扫描结束后，新建数组中存放了整个序列以及每个数字出现的次数</p></li><li><p>最后输出目标整数序列</p></li><li><p>输出数字 2，同时数组中 index 为 0 的值为 2 的元素次数变为 0</p></li><li><p>输出数字 3，同时数组中 index 为 1 的值为 3 的元素次数变为 1</p></li><li><p>同样的操作，整个序列就完全输出了</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="Go代码实现"><a href="#Go代码实现" class="headerlink" title="Go代码实现"></a>Go代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126191921.png" alt=""></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126191936.png" alt=""></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126191943.png" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126191949.png" alt=""></p><p>如果你是iOS开发者，可以在GitHub上 <a href="https://github.com/MisterBooo/Play-With-Sort-OC">https://github.com/MisterBooo/Play-With-Sort-OC</a> 获取更直观可调试运行的源码。</p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 计数排序 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

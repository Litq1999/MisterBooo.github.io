<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Leetcode上第 75 号问题： Two Sum II</title>
      <link href="/2019/01/26/75/"/>
      <url>/2019/01/26/75/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/10/29/166bdc86b1885e65?w=2294&amp;h=1412&amp;f=png&amp;s=261824" alt=""><br>leetcode上第75号问题：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">Two Sum II</a></p><blockquote><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p></blockquote><blockquote><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p></blockquote><blockquote><p>说明:</p></blockquote><blockquote><ul><li>返回的下标值（index1 和 index2）不是从零开始的。</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ul></blockquote><blockquote><p>示例:</p></blockquote><blockquote><p>输入: numbers = [2, 7, 11, 15], target = 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>初始化左指针left指向数组起始，初始化右指针right指向数组结尾。</p><p>根据<strong>已排序</strong>这个特性，</p><ul><li><p>（1）如果numbers[left]与numbers[right]的和tmp小于target，说明应该增加tmp,因此left右移指向一个较大的值。</p></li><li><p>（2）如果tmp大于target，说明应该减小tmp,因此right左移指向一个较小的值。</p></li><li><p>（3）tmp等于target，则找到，返回left+1和right+1。（注意以1为起始下标）</p></li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://user-gold-cdn.xitu.io/2018/10/29/166bdc5dfb63ea8d?w=853&amp;h=457&amp;f=gif&amp;s=69203" alt=""></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 对撞指针// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {        int l = 0, r = numbers.size() - 1;        while(l &lt; r){            if(numbers[l] + numbers[r] == target){                int res[2] = {l+1, r+1};                return vector&lt;int&gt;(res, res+2);            }            else if(numbers[l] + numbers[r] &lt; target)                l ++;            else // numbers[l] + numbers[r] &gt; target                r --;        }    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode上第 283 号问题： Move Zeros</title>
      <link href="/2019/01/26/283/"/>
      <url>/2019/01/26/283/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669facb3a2bb86e?w=1240&amp;h=574&amp;f=png&amp;s=228428" alt="Move Zeros"><br>leetcode上第283号问题：<a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">Move Zeros</a></p><blockquote><p>给定一个数组nums，写一个函数，将数组中所有的0挪到数组的末尾，⽽维持其他所有非0元素的相对位置。<br>举例: nums = [0, 1, 0, 3, 12]，函数运⾏后结果为[1, 3, 12, 0, 0]</p></blockquote><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>思路：创建一个临时数组nonZeroElements，遍历nums，将nums中非0元素赋值到nonZeroElements中，而后按顺序将nonZeroElements赋值到nums上，未遍历的元素置0；</p><p>动画如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669facb3a048c12?w=420&amp;h=203&amp;f=gif&amp;s=60758" alt="image"></p><p>代码如下：</p><pre><code>// 时间复杂度: O(n)// 空间复杂度: O(n)class Solution {public:    void moveZeroes(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; nonZeroElements;        // 将vec中所有非0元素放入nonZeroElements中        for(int i = 0 ; i &lt; nums.size() ; i ++)            if(nums[i])                nonZeroElements.push_back(nums[i]);        // 将nonZeroElements中的所有元素依次放入到nums开始的位置        for(int i = 0 ; i &lt; nonZeroElements.size() ; i ++)            nums[i] = nonZeroElements[i];        // 将nums剩余的位置放置为0        for(int i = nonZeroElements.size() ; i &lt; nums.size() ; i ++)            nums[i] = 0;    }};</code></pre><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>思路：设定一个临时变量k=0，遍历数组nums，将非零元素移动到nums[k]位置，同时k++，而后将【k,….nums.size()】中的元素置零。</p><p>动画如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669facb3a3f2742?w=744&amp;h=418&amp;f=gif&amp;s=104124" alt="image"></p><p>代码如下：</p><pre><code>// 原地(in place)解决该问题// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    void moveZeroes(vector&lt;int&gt;&amp; nums) {        int k = 0; // nums中, [0...k)的元素均为非0元素        // 遍历到第i个元素后,保证[0...i]中所有非0元素        // 都按照顺序排列在[0...k)中        for(int i = 0 ; i &lt; nums.size() ; i ++)            if(nums[i])                nums[k++] = nums[i];        // 将nums剩余的位置放置为0        for(int i = k ; i &lt; nums.size() ; i ++)            nums[i] = 0;    }};</code></pre><h3 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h3><p>思路：设定一个临时变量k=0，遍历数组nums，将非零元素与之前的零元素进行交换，维护变量k的值。</p><p>动画如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669facb3a1f570c?w=744&amp;h=418&amp;f=gif&amp;s=92514" alt="image"></p><p>代码如下：</p><pre><code>// 原地(in place)解决该问题// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    void moveZeroes(vector&lt;int&gt;&amp; nums) {        int k = 0; // nums中, [0...k)的元素均为非0元素        // 遍历到第i个元素后,保证[0...i]中所有非0元素        // 都按照顺序排列在[0...k)中        // 同时, [k...i] 为 0        for(int i = 0 ; i &lt; nums.size() ; i ++)            if(nums[i])                if(k != i)                    swap(nums[k++] , nums[i]);                else                    k ++;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示桶排序</title>
      <link href="/2019/01/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-tong-pai-xu/"/>
      <url>/2019/01/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-tong-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解桶排序"><a href="#【图解数据结构】-一组动画彻底理解桶排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解桶排序"></a>【图解数据结构】 一组动画彻底理解桶排序</h1><p>由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 —–《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序(Bucket sort)是一种基于计数的排序算法（<strong>计数排序</strong>可参考上节的内容），工作的原理是将数据分到有限数量的桶子里，然后每个桶再分别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>设置固定数量的空桶。</p></li><li><p>把数据放到对应的桶中。</p></li><li><p>对每个不为空的桶中数据进行排序。</p></li><li><p>拼接不为空的桶中数据，得到结果。</p></li></ol><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/29/1675ceff66c00fe7?w=955&amp;h=539&amp;f=gif&amp;s=1026397" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，设置固定数量的空桶，在这里为了方便演示，设置桶的数量为 5 个空桶</p></li><li><p>遍历整个数列，找到最大值为 56 ，最小值为 2 ，每个桶的范围为 （ 56 - 2 + 1 ）/ 5 = 11</p></li><li><p>再次遍历整个数列，按照公式 floor((数字 – 最小值) / 11) 将数字放到对应的桶中</p></li><li><p>比如，数字 7 代入公式 floor((7 – 2) / 11) = 0 放入 0 号桶</p></li><li><p>数字 12 代入公式 floor((12 – 2) / 11) = 0 放入 0 号桶</p></li><li><p>数字 56 代入公式 floor((56 – 2) / 11) = 4 放入 4 号桶</p></li><li><p>当向同一个索引的桶，第二次插入数据时，判断桶中已存在的数字与新插入数字的大小，按照左到右，从小到大的顺序插入（可以使用前面讲解的<strong>插入排序</strong>）实现</p></li><li><p>比如，插入数字 19 时， 1 号桶中已经有数字 23 ，在这里使用插入排序，让 19 排在 23 前面</p></li><li><p>遍历完整个数列后，合并非空的桶，按从左到右的顺序合并0，1，2，3，4桶。</p></li><li><p>这样就完成了 <strong>桶排序</strong></p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/29/1675ceff669fd15d?w=1864&amp;h=2122&amp;f=png&amp;s=80844" alt=""></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/29/1675ceff66c62d33?w=2016&amp;h=3272&amp;f=png&amp;s=170854" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/29/1675ceff66b31247?w=2048&amp;h=2260&amp;f=png&amp;s=131496" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 桶排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示快速排序</title>
      <link href="/2019/01/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-kuai-su-pai-xu/"/>
      <url>/2019/01/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-kuai-su-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解快速排序"><a href="#【图解数据结构】-一组动画彻底理解快速排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解快速排序"></a>【图解数据结构】 一组动画彻底理解快速排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 —–《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>从数列中挑出一个元素，称为 “基准”（pivot）;</p></li><li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p></li></ol><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e00a0d10d84d?w=950&amp;h=534&amp;f=gif&amp;s=492246" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，操作数列中的所有数字</p></li><li><p>在所有数字中选择一个数字作为排序的基准（pivot）, pivot 通常是随机选择的，在这里为了演示方便，我们选择最右边的数字作为 pivot</p></li><li><p>选取好 pivot 后，在操作数列中选择最左边的数字标记为 左标记 ，最右边的数字标记为 右标记</p></li><li><p>将左边的标记向右移动</p></li><li><p>当 左标记 达到超过 pivot 的数字时，停止移动</p></li><li><p>在这里，8 &gt; 6 ,所以停止移动</p></li><li><p>然后将右边的标记向左移动</p></li><li><p>当 右标记 达到小于 pivot 的数字时，停止移动</p></li><li><p>在这里，4 &gt; 6 ,所以停止移动</p></li><li><p>当左右标记停止时，更改标记的数字</p></li><li><p>因此，左标记 的作用是找到一个大于 pivot 的数字，右标记 的作用是找到一个小于 pivot 的数字</p></li><li><p>通过交换数字，可以在数列的左边收集小于 pivot 的数字集合，右边收集大于 pivot 的数字集合</p></li><li><p>交换之后，继续移动 左标记</p></li><li><p>在这里，9 &gt; 6 ,所以停止移动</p></li><li><p>然后将右边的标记向左移动</p></li><li><p>当 右标记 碰撞到 左标记 时也停止移动</p></li><li><p>如果左右侧的标记停止时，并且都在同一个位置，将这个数字和 pivot 的数字交换</p></li><li><p>这就完成了第一次操作</p></li><li><p>小于 6 的都在 6 的左侧，大于 6 的都在 6 的右侧</p></li><li><p>然后递归对这分成的两部分都执行同样的操作</p></li><li><p>完成 快速排序</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e00a0dc023d8?w=1392&amp;h=1524&amp;f=png&amp;s=68959" alt="C++代码实现"></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e00a0cb5d352?w=1668&amp;h=2214&amp;f=png&amp;s=109067" alt="Java代码实现"></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e00a0c058ac5?w=1756&amp;h=1432&amp;f=png&amp;s=74882" alt="Python代码实现"></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e00a0e6e21b7?w=1572&amp;h=2950&amp;f=png&amp;s=139434" alt="JavaScript代码实现"></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示基数排序</title>
      <link href="/2019/01/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-ji-shu-pai-xu/"/>
      <url>/2019/01/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-ji-shu-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解基数排序"><a href="#【图解数据结构】-一组动画彻底理解基数排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解基数排序"></a>【图解数据结构】 一组动画彻底理解基数排序</h1><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序 (Radix Sort) 是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。基数排序的发明可以追溯到 1887 年赫尔曼·何乐礼在打孔卡片制表机 (Tabulation Machine)上的贡献。</p><p>基数排序法会使用到桶 (Bucket)，顾名思义，通过将要比较的位（个位、十位、百位…），将要排序的元素分配至 0~9 个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其它的比较性排序法。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零</p></li><li><p>从最低位开始，依次进行一次排序</p></li><li><p>从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列</p></li></ol><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^<br><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181128114235.gif" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>基数排序的方式可以采用 LSD (Least sgnificant digital) 或 MSD (Most sgnificant digital)</p></li><li><p>在本例中使用的是 <strong>LSD</strong></p></li><li><p>首先创建编号 0 ， 1 ，2 ，3 ，4 ，5 ， 6 ，7 ，8 ，9 这 10 个桶 </p></li><li><p>遍历整个数列，查看数字的个位数，按照先后顺序存放在对应编号的桶中</p></li><li><p>比如 321 个位数 为 1 ，存放在编号 1 桶中</p></li><li><p>数字 1 个位数 为 1 ，存放在编号 1 桶中，同时存放在 321 上面 </p></li><li><p>遍历完整个数列的个位数，将数字存放在桶中后，按照编号顺序取出数字，先放入桶中的数字先取出</p></li><li><p>然后依次遍历整个数列的十位数，按照上述个位数的操作整理数列</p></li><li><p>依次遍历整个数列的百位数，按照上述个位数的操作整理数列</p></li><li><p>这样就完成了 <strong>基数排序</strong></p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181128123735.png" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181128123743.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基数排序 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示选择排序</title>
      <link href="/2019/01/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-yan-shi-xuan-ze-pai-xu/"/>
      <url>/2019/01/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-yan-shi-xuan-ze-pai-xu/</url>
      
        <content type="html"><![CDATA[<p># </p><h1 id="【图解数据结构】-一组动画演示选择排序"><a href="#【图解数据结构】-一组动画演示选择排序" class="headerlink" title="【图解数据结构】 一组动画演示选择排序"></a>【图解数据结构】 一组动画演示选择排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 —–《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</p></li><li><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p></li><li><p>重复第二步，直到所有元素均排序完毕。</p></li></ol><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/16738f0f5824e2d8?w=955&amp;h=538&amp;f=gif&amp;s=346690" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>线性搜索数列并找到最小值，此时找到了为 2</p></li><li><p>将最小值替换为数列中左端的数字，即将 2 与 4 进行交换</p></li><li><p>此时 2 已经排序好</p></li><li><p>继续线性搜索剩余数列找到最小值，此时找到了 3</p></li><li><p>将最小值替换为数列中左端的数字，即将 3 与 4 进行交换</p></li><li><p>此时 2 与 3 已经排序好</p></li><li><p>继续线性搜索剩余数列找到最小值，此时找到了 4</p></li><li><p>如果最小值已经在左端，那么不执行任何操作，所以此时不做任何处理</p></li><li><p>此时 2 、 3  、 4 已经排序好</p></li><li><p>重复相同操作，直到所有数字都被排序</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/16738f0eff237d54?w=1148&amp;h=972&amp;f=png&amp;s=36827" alt=""></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/16738f0f0a65d4cf?w=1668&amp;h=1708&amp;f=png&amp;s=75701" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/16738f0ef955a299?w=1604&amp;h=1110&amp;f=png&amp;s=51471" alt=""></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/16738f0f0156b4cc?w=1452&amp;h=880&amp;f=png&amp;s=44413" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 选择排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一组动画演示归并排序</title>
      <link href="/2019/01/26/tu-jie-shu-ju-jie-gou-wu-fen-zhong-xue-suan-fa-zhi-yi-zu-dong-hua-yan-shi-gui-bing-pai-xu/"/>
      <url>/2019/01/26/tu-jie-shu-ju-jie-gou-wu-fen-zhong-xue-suan-fa-zhi-yi-zu-dong-hua-yan-shi-gui-bing-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画演示归并排序"><a href="#【图解数据结构】-一组动画演示归并排序" class="headerlink" title="【图解数据结构】 一组动画演示归并排序"></a>【图解数据结构】 一组动画演示归并排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 —–《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。</p><h2 id="归并排序（Merge-sort"><a href="#归并排序（Merge-sort" class="headerlink" title="归并排序（Merge sort"></a>归并排序（Merge sort</h2><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ul><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li><li>自下而上的迭代；</li></ul><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p></li><li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p></li><li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p></li><li><p>重复步骤 3 直到某一指针达到序列尾；</p></li><li><p>将另一序列剩下的所有元素直接复制到合并序列尾。</p></li></ol><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16733b1a9c74ce50?w=955&amp;h=538&amp;f=gif&amp;s=586156" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，将数字分割成两片区域</p></li><li><p>将数字分割成两片区域</p></li><li><p>。。。。。。</p></li><li><p>直到每片区域只有一个元素</p></li><li><p>分割完成</p></li><li><p>接下来，将分割的每片区域进行合并组合</p></li><li><p>合并时，按照数字的升序移动，使得合并后的数字在组内按升序排列</p></li><li><p>当合并包含多个数字的组时，比较开头的数字，移动其中较小的数字</p></li><li><p>比如在动画中，比较开头的 4 和 3 </p></li><li><p>其中 4 大于 3， 因此移动 3</p></li><li><p>按照同样的逻辑去比较该列剩余的头数</p></li><li><p>4 小于 7 ，所以移动 4</p></li><li><p>。。。。。。</p></li><li><p>递归的重复组的合并操作，直到所有数字都在一个组中。</p></li><li><p>完成 归并排序 啦~</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16733b1a9c8f7fff?w=1832&amp;h=1708&amp;f=png&amp;s=85502" alt="C++代码实现"></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16733b1a9db220c7?w=1668&amp;h=2444&amp;f=png&amp;s=128379" alt="Java代码实现"></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16733b1a9dd4b5f7?w=1322&amp;h=1294&amp;f=png&amp;s=64894" alt="Python代码实现"></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16733b1a9dcea382?w=1344&amp;h=1800&amp;f=png&amp;s=76855" alt="JavaScript代码实现"></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示冒泡排序</title>
      <link href="/2019/01/26/tu-jie-shu-ju-jie-gou-dong-hua-yan-shi-mou-pao-pai-xu/"/>
      <url>/2019/01/26/tu-jie-shu-ju-jie-gou-dong-hua-yan-shi-mou-pao-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画演示冒泡排序"><a href="#【图解数据结构】-一组动画演示冒泡排序" class="headerlink" title="【图解数据结构】 一组动画演示冒泡排序"></a>【图解数据结构】 一组动画演示冒泡排序</h1><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p></li><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p></li><li><p>针对所有的元素重复以上的步骤，除了最后一个。</p></li><li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p></li></ol><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181119200024.gif" alt="五分钟学算法之冒泡排序"></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>将天平放在序列的右端，并比较天平左右的数字</p></li><li><p>在这种情况下我们比较 3 和 8 </p></li><li><p>比较后如果右边的数字较小，则被交换</p></li><li><p>因为 8 大于 3 ，所以数字不用交换</p></li><li><p>比较完成后，将天平向左移动一个位置，比较数字</p></li><li><p>因为 3 大于 2 ，所以数字不用交换</p></li><li><p>比较完成后，逐一移动天平，比较数字</p></li><li><p>此时 2 小于 4 ，所以左右的数字互相交换</p></li><li><p>重复同样的操作，直到天平移动到左端</p></li><li><p>。。。。。。</p></li><li><p>天平到达左端</p></li><li><p>经过上述的操作，数列中最小的数字已经移动到左端</p></li><li><p>将天平返回右端</p></li><li><p>重复相同的操作，直到所有数字都被排序</p></li><li><p>。。。。。。</p></li><li><p>吐完泡泡了</p></li></ol><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181119201851.png" alt=""></p><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181119201910.png" alt=""></p><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181119201417.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 冒泡排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示希尔排序</title>
      <link href="/2018/11/29/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-xi-er-pai-xu/"/>
      <url>/2018/11/29/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-xi-er-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解希尔排序"><a href="#【图解数据结构】-一组动画彻底理解希尔排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解希尔排序"></a>【图解数据结构】 一组动画彻底理解希尔排序</h1><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</p></li><li><p>按增量序列个数 k，对序列进行 k 趟排序；</p></li><li><p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p></li></ol><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，选择增量 gap = 10/2 ，缩小增量继续以 gap = gap/2 的方式</p></li><li><p>初始增量为 gap = 10/2 = 5，整个数组分成了 5 组</p></li><li><p>按颜色划分为【 8 , 3 】，【 9 , 5 】，【 1 , 4 】，【 7 , 6 】，【 2 , 0 】</p></li><li><p>对这分开的 5 组分别使用上节所讲的插入排序</p></li><li><p>结果可以发现，这五组中的相对小元素都被调到前面了</p></li><li><p>缩小增量 gap = 5/2 = 2，整个数组分成了 2 组</p></li><li><p>【 3 , 1 , 0 , 9 , 7  】，【 5 , 6 , 8 , 4 , 2  】</p></li><li><p>对这分开的 2 组分别使用上节所讲的插入排序</p></li><li><p>此时整个数组的有序性是很明显的</p></li><li><p>再缩小增量 gap = 2/2 = 1，整个数组分成了 1 组</p></li><li><p>【 0, 2 , 1 , 4 , 3 , 5 , 7 , 6 , 9 , 0  】</p></li><li><p>此时，只需要对以上数列进行简单的微调，不需要大量的移动操作即可完成整个数组的排序</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674859d8e945f1a?w=1280&amp;h=1037&amp;f=png&amp;s=167873" alt=""></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674859d8dda4858?w=1280&amp;h=1275&amp;f=png&amp;s=248791" alt=""></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674859d902e21b0?w=1128&amp;h=1110&amp;f=png&amp;s=53723" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674859d8e52ee54?w=1280&amp;h=934&amp;f=png&amp;s=185891" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 希尔排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示堆排序</title>
      <link href="/2018/11/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-dui-pai-xu/"/>
      <url>/2018/11/26/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-dui-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解堆排序"><a href="#【图解数据结构】-一组动画彻底理解堆排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解堆排序"></a>【图解数据结构】 一组动画彻底理解堆排序</h1><h2 id="预备知识：堆结构"><a href="#预备知识：堆结构" class="headerlink" title="预备知识：堆结构"></a>预备知识：堆结构</h2><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p><h4 id="大顶堆"><a href="#大顶堆" class="headerlink" title="大顶堆"></a>大顶堆</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181125194044.png" alt=""></p><h4 id="小顶堆"><a href="#小顶堆" class="headerlink" title="小顶堆"></a>小顶堆</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181125194056.png" alt=""></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序（Heapsort）是指利用堆这种数据结构（后面的【图解数据结构】内容会讲解分析）所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ul><li><p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p></li><li><p>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p></li></ul><p>堆排序的平均时间复杂度为 Ο(nlogn)。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>创建一个堆 H[0……n-1]；</p></li><li><p>把堆首（最大值）和堆尾互换；</p></li><li><p>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</p></li><li><p>重复步骤 2，直到堆的尺寸为 1。</p></li></ol><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181125191942.gif" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，将所有的数字存储在堆中</p></li><li><p>按大顶堆构建堆，其中大顶堆的一个特性是数据将被从大到小取出，将取出的数字按照相反的顺序进行排列，数字就完成了排序</p></li><li><p>在这里数字 5 先入堆</p></li><li><p>数字 2 入堆</p></li><li><p>数字 7 入堆， 7 此时是最后一个节点，与最后一个非叶子节点（也就是数字 5 ）进行比较，由于 7 大于 5 ，所以 7 和 5 交互</p></li><li><p>按照上述的操作将所有数字入堆，然后从左到右，从上到下进行调整，构造出大顶堆</p></li><li><p>入堆完成之后，将堆顶元素取出，将末尾元素置于堆顶，重新调整结构，使其满足堆定义</p></li><li><p>堆顶元素数字 7 取出，末尾元素数字 4 置于堆顶，为了维护好大顶堆的定义，最后一个非叶子节点数字 5 与 4 比较，而后交换两个数字的位置</p></li><li><p>反复执行调整+交换步骤，直到整个序列有序</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="Go代码实现"><a href="#Go代码实现" class="headerlink" title="Go代码实现"></a>Go代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126100338.png" alt=""></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126100347.png" alt=""></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126100353.png" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126100358.png" alt=""></p><p>如果你是iOS开发者，可以在GitHub上 <a href="https://github.com/MisterBooo/Play-With-Sort-OC">https://github.com/MisterBooo/Play-With-Sort-OC</a> 获取更直观可调试运行的源码。</p><p>你可以在公众号 <strong>五分钟学算法</strong> 获取更多排序内容。</p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示插入排序</title>
      <link href="/2018/11/24/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-yan-shi-cha-ru-pai-xu/"/>
      <url>/2018/11/24/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-yan-shi-cha-ru-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画演示插入排序"><a href="#【图解数据结构】-一组动画演示插入排序" class="headerlink" title="【图解数据结构】 一组动画演示插入排序"></a>【图解数据结构】 一组动画演示插入排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 —–《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p></li><li><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）。</p></li></ol><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181120164938.gif" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>一开始左端数字已经排序，数字 5 不动</p></li><li><p>然后，取出剩余未操作的左端数字 3 </p></li><li><p>将其与已经操作的左侧数字相比较</p></li><li><p>如果左边的数字较大，则交换两个数字</p></li><li><p>这种情况下，由于 5 大于 3 ，所以交换两个数字</p></li><li><p>重复此操作，直到出现一个较小的数字或者数字到达左端</p></li><li><p>数字 3 已经完成排序</p></li><li><p>接下来，和之前一样取出剩余未操作的左端数字 4  </p></li><li><p>与其相邻的左边数字进行比较</p></li><li><p>这种情况下，由于 5 大于 4 ，所以交换两个数字</p></li><li><p>继续操作，由于 3 小于 4 ，即出现了更小的数字，所以 4 停止移动</p></li><li><p>数字 4 已经完成排序</p></li><li><p>重复相同的操作，直到所有的数字完成排序</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="http://upload-images.jianshu.io/upload_images/1940317-ce2bac560fc4620a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="http://upload-images.jianshu.io/upload_images/1940317-e29b04076de62c3a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="http://upload-images.jianshu.io/upload_images/1940317-25d430ac861b8bdd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="http://upload-images.jianshu.io/upload_images/1940317-575eb47403e08c3f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 插入排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示计数排序</title>
      <link href="/2018/11/24/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-ji-shu-pai-xu/"/>
      <url>/2018/11/24/tu-jie-shu-ju-jie-gou-yi-zu-dong-hua-che-di-li-jie-ji-shu-pai-xu/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解计数排序"><a href="#【图解数据结构】-一组动画彻底理解计数排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解计数排序"></a>【图解数据结构】 一组动画彻底理解计数排序</h1><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序是一种非基于比较的排序算法，其空间复杂度和时间复杂度均为O(n+k)，其中k是整数的范围。基于比较的排序算法时间复杂度最小是O(nlogn)的。该算法于1954年由 Harold H. Seward 提出。</p><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有<strong>确定范围的整数</strong>。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max</p></li><li><p>开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1)</p></li><li><p>数组 B 中 index 的元素记录的值是 A 中某元素出现的次数</p></li><li><p>最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数</p></li></ol><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126190814.gif" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，扫描一下整个序列</p></li><li><p>获得最小值为 2 ，最大值为 7</p></li><li><p>新建数组包含 2~7 的元素</p></li><li><p>再次扫描序列，将序列的值放置在新建数组中</p></li><li><p>扫描数字 5，数组中 index 为 3 的值为 5，次数为 1</p></li><li><p>扫描数字 3，数组中 index 为 1 的值为 3，次数为 1</p></li><li><p>扫描数字 4，数组中 index 为 2 的值为 4，次数为 1</p></li><li><p>扫描数字 7，数组中 index 为 5 的值为 7，次数为 1</p></li><li><p>扫描数字 2，数组中 index 为 0 的值为 2，次数为 1</p></li><li><p>扫描数字 4，数组中 index 为 2 的值为 4，次数为 2</p></li><li><p>扫描数字 3，数组中 index 为 1 的值为 3，次数为 2</p></li><li><p>按照这种节奏，扫描结束后，新建数组中存放了整个序列以及每个数字出现的次数</p></li><li><p>最后输出目标整数序列</p></li><li><p>输出数字 2，同时数组中 index 为 0 的值为 2 的元素次数变为 0</p></li><li><p>输出数字 3，同时数组中 index 为 1 的值为 3 的元素次数变为 1</p></li><li><p>同样的操作，整个序列就完全输出了</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="Go代码实现"><a href="#Go代码实现" class="headerlink" title="Go代码实现"></a>Go代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126191921.png" alt=""></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126191936.png" alt=""></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126191943.png" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126191949.png" alt=""></p><p>如果你是iOS开发者，可以在GitHub上 <a href="https://github.com/MisterBooo/Play-With-Sort-OC">https://github.com/MisterBooo/Play-With-Sort-OC</a> 获取更直观可调试运行的源码。</p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 计数排序 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

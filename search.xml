<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>详解什么是平衡二叉树（AVL）</title>
      <link href="/posts/65aa991e/"/>
      <url>/posts/65aa991e/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>Wiki:在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">计算机科学</a>中，<strong>AVL树</strong>是最早被发明的<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91" target="_blank" rel="noopener">自平衡二叉查找树</a>。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为<strong>高度平衡树</strong>。查找、插入和删除在平均和最坏情况下的<a href="https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" target="_blank" rel="noopener">时间复杂度</a>都是 O(logn）。增加和删除元素的操作则可能需要借由一次或多次<a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E6%97%8B%E8%BD%AC" target="_blank" rel="noopener">树旋转</a>，以实现树的重新平衡。AVL 树得名于它的发明者 <a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%A5%A5%E5%B0%94%E5%90%89%C2%B7%E9%98%BF%E6%9D%B0%E5%B0%94%E6%9D%BE-%E9%9F%A6%E5%88%A9%E6%96%AF%E5%9F%BA" target="_blank" rel="noopener">G. M. Adelson-Velsky</a> 和 <a href="https://zh.wikipedia.org/w/index.php?title=Evgenii_Landis&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">Evgenii Landis</a>，他们在1962年的论文《An algorithm for the organization of information》中公开了这一数据结构。</p></blockquote><h3 id="1-为什么要有平衡二叉树"><a href="#1-为什么要有平衡二叉树" class="headerlink" title="1 为什么要有平衡二叉树"></a>1 为什么要有平衡二叉树</h3><p>二叉搜索树一定程度上可以提高搜索效率，但是当原序列有序时，例如序列 A = {1，2，3，4，5，6}，构造二叉搜索树如图 1.1。依据此序列构造的二叉搜索树为右斜树，同时二叉树退化成单链表，搜索效率降低为 O(n)。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzofsmoafpj31hc0u0t8y.jpg" alt="图 1.1"></p><p>在此二叉搜索树中查找元素 6 需要查找 6 次。</p><p>二叉搜索树的查找效率取决于树的高度，因此保持树的高度最小，即可保证树的查找效率。同样的序列 A，将其改为图 1.2 的方式存储，查找元素 6 时只需比较 3 次，查找效率提升一倍。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzofyo9w0wj31k60mcjrg.jpg" alt="图 1.2"></p><p>可以看出当节点数目一定，保持树的左右两端保持平衡，树的查找效率最高。</p><p><strong>这种左右子树的高度相差不超过 1 的树为平衡二叉树。</strong></p><h3 id="2-定义"><a href="#2-定义" class="headerlink" title="2. 定义"></a>2. 定义</h3><p><strong>平衡二叉查找树</strong>：简称平衡二叉树。由前苏联的数学家 <strong>A</strong>delse-<strong>V</strong>elskil 和 <strong>L</strong>andis 在 1962 年提出的高度平衡的二叉树，根据科学家的英文名也称为 AVL 树。它具有如下几个性质：</p><ol><li>可以是空树。</li><li>假如不是空树，任何一个节点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。</li></ol><p>平衡之意，如天平，即两边的分量大约相同。</p><p>例如图 2.1 不是平衡二叉树，因为节点 60 的左子树不是平衡二叉树。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzogeu6pn5j31ke0nyq35.jpg" alt="图 2.1"></p><p>图 2.2 也不是平衡二叉树，因为虽然任何一个节点的左子树与右子树都是平衡二叉树，但高度之差已经超过 1 。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzogewh2naj31kc0n6t8w.jpg" alt="图 2.2"></p><p>图 2.3 是平衡二叉树。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzqme36qn7j31h40rmac6.jpg" alt="图 2.3"></p><h3 id="3-平衡因子"><a href="#3-平衡因子" class="headerlink" title="3. 平衡因子"></a>3. 平衡因子</h3><p><strong>定义：</strong>某节点的左子树与右子树的高度(深度)差即为该节点的平衡因子（BF,Balance Factor），平衡二叉树中不存在平衡因子大于 1 的节点。在一棵平衡二叉树中，节点的平衡因子只能取 0 、1 或者 -1 ，分别对应着左右子树等高，左子树比较高，右子树比较高。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzogqxlo4zj31k80lc3yl.jpg" alt="图 3.1"></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzogscuvtzj31jy0kwaa5.jpg" alt="图 3.2"></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzogsc9r7xj31jw0laglp.jpg" alt="图 3.3"></p><h3 id="4-节点结构"><a href="#4-节点结构" class="headerlink" title="4. 节点结构"></a>4. 节点结构</h3><p>定义平衡二叉树的节点结构：</p><pre class=" language-c++"><code class="language-c++">typedef struct AVLNode *Tree;typedef int ElementType;struct AVLNode{    int depth; //深度，这里计算每个节点的深度，通过深度的比较可得出是否平衡    Tree parent; //该节点的父节点    ElementType val; //节点值    Tree lchild;    Tree rchild;    AVLNode(int val=0) {        parent = NULL;        depth = 0;        lchild = rchild = NULL;        this->val=val;    }};</code></pre><h3 id="5-AVL树插入时的失衡与调整"><a href="#5-AVL树插入时的失衡与调整" class="headerlink" title="5. AVL树插入时的失衡与调整"></a>5. AVL树插入时的失衡与调整</h3><p>图 5.1 是一颗平衡二叉树</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzolcmx1qqj31b00g6glk.jpg" alt="图 5.1 "></p><p>在此平衡二叉树插入节点 99 ，树结构变为： </p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzolopfxzxg30q60be41k.gif" alt="动图 5.2"></p><p>在动图 5.2 中，节点 66 的左子树高度为 1，右子树高度为 3，此时平衡因子为 -2，树失去平衡。</p><p>在动图 5.2 中，以节点 66 为父节点的那颗树就称为 <strong>最小失衡子树</strong>。</p><p><strong>最小失衡子树</strong>：在新插入的节点向上查找，以第一个平衡因子的<strong>绝对值</strong>超过 1 的节点为根的子树称为最小不平衡子树。也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的。而这个时候，我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。</p><p><strong>平衡二叉树的失衡调整主要是通过旋转最小失衡子树来实现的</strong>。根据旋转的方向有两种处理方式，<strong>左旋</strong> 与 <strong>右旋</strong> 。</p><p>旋转的目的就是减少高度，通过降低整棵树的高度来平衡。哪边的树高，就把那边的树向上旋转。</p><h4 id="5-1-左旋"><a href="#5-1-左旋" class="headerlink" title="5.1 左旋"></a>5.1 左旋</h4><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzolu39ojoj31gw0lumx9.jpg" alt="图 5.1.1"></p><p>以图 5.1.1 为例，加入新节点 99 后， 节点 66 的左子树高度为 1，右子树高度为 3，此时平衡因子为 -2。为保证树的平衡，此时需要对节点 66 做出旋转，因为右子树高度高于左子树，对节点进行左旋操作，流程如下：</p><p>（1）节点的右孩子替代此节点位置<br>（2）右孩子的左子树变为该节点的右子树<br>（3）节点本身变为右孩子的左子树</p><p>整个操作流程如动图 5.1.2 所示。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzom2pmmr5g30q50ekdiy.gif" alt="动图 5.1.2"></p><ul><li>节点的右孩子替代此节点位置 —— 节点 66 的右孩子是节点 77 ，将节点 77 代替节点 66 的位置</li><li>右孩子的左子树变为该节点的右子树 —— 节点 77 的左子树为节点 75，将节点 75 挪到节点 66 的右子树位置</li><li>节点本身变为右孩子的左子树 —— 节点 66 变为了节点 77 的左子树</li></ul><h4 id="5-2-右旋"><a href="#5-2-右旋" class="headerlink" title="5.2 右旋"></a>5.2 右旋</h4><p>右旋操作与左旋类似，操作流程为：</p><p>（1）节点的左孩子代表此节点<br>（2）节点的左孩子的右子树变为节点的左子树<br>（3）将此节点作为左孩子节点的右子树。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzomfzo5eag30q50ek40u.gif" alt="动图 5.2.1"></p><h3 id="6-AVL树的四种插入节点方式"><a href="#6-AVL树的四种插入节点方式" class="headerlink" title="6. AVL树的四种插入节点方式"></a>6. AVL树的四种插入节点方式</h3><p>假设一颗 AVL 树的某个节点为 A，有四种操作会使 A 的左右子树高度差大于 1，从而破坏了原有 AVL 树的平衡性。平衡二叉树插入节点的情况分为以下四种：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzqpwcjzy5j318i0akq3t.jpg" alt="图 6.0"></p><p>具体分析如下：</p><h4 id="6-1-A的左孩子的左子树插入节点-LL"><a href="#6-1-A的左孩子的左子树插入节点-LL" class="headerlink" title="6.1 A的左孩子的左子树插入节点(LL)"></a>6.1 A的左孩子的左子树插入节点(LL)</h4><p>只需要执行一次右旋即可。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzomzssf3ng30q50ekmyt.gif" alt="动图 6.1"></p><p>实现代码如下：</p><pre class=" language-c++"><code class="language-c++">//LL型调整函数//返回:新父节点Tree LL_rotate(Tree node){    //node为离操作节点最近的失衡的节点    Tree parent=NULL,son;    //获取失衡节点的父节点    parent=node->parent;    //获取失衡节点的左孩子    son=node->lchild;    //设置son节点右孩子的父指针    if (son->rchild!=NULL)  son->rchild->parent=node;    //失衡节点的左孩子变更为son的右孩子    node->lchild=son->rchild;    //更新失衡节点的高度信息    update_depth(node);    //失衡节点变成son的右孩子    son->rchild=node;    //设置son的父节点为原失衡节点的父节点    son->parent=parent;    //如果失衡节点不是根节点，则开始更新父节点    if (parent!=NULL){        //如果父节点的左孩子是失衡节点，指向现在更新后的新孩子son        if (parent->lchild==node){            parent->lchild=son;        }else{             //父节点的右孩子是失衡节点              parent->rchild=son;        }     }    //设置失衡节点的父亲    node->parent=son;    //更新son节点的高度信息    update_depth(son);    return son;}</code></pre><h4 id="6-2-A的右孩子的右子树插入节点-RR"><a href="#6-2-A的右孩子的右子树插入节点-RR" class="headerlink" title="6.2 A的右孩子的右子树插入节点(RR)"></a>6.2 A的右孩子的右子树插入节点(RR)</h4><p>只需要执行一次左旋即可。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzonjzgewgg30q50ek0uh.gif" alt="动图 6.2"></p><p>实现代码如下：</p><pre class=" language-c++"><code class="language-c++">//RR型调整函数//返回新父节点Tree RR_rotate(Tree node){    //node为离操作节点最近的失衡的节点    Tree parent=NULL,son;    //获取失衡节点的父节点    parent=node->parent;    //获取失衡节点的右孩子    son=node->rchild;    //设置son节点左孩子的父指针    if (son->lchild!=NULL){          son->lchild->parent=node;    }    //失衡节点的右孩子变更为son的左孩子    node->rchild=son->lchild;    //更新失衡节点的高度信息    update_depth(node);    //失衡节点变成son的左孩子    son->lchild=node;    //设置son的父节点为原失衡节点的父节点    son->parent=parent;    //如果失衡节点不是根节点，则开始更新父节点    if (parent!=NULL){        //如果父节点的左孩子是失衡节点，指向现在更新后的新孩子son        if (parent->lchild==node){            parent->lchild=son;        }else{            //父节点的右孩子是失衡节点            parent->rchild=son;        }     }    //设置失衡节点的父亲    node->parent=son;    //更新son节点的高度信息    update_depth(son);    return son;}</code></pre><h4 id="6-3-A的左孩子的右子树插入节点-LR"><a href="#6-3-A的左孩子的右子树插入节点-LR" class="headerlink" title="6.3 A的左孩子的右子树插入节点(LR)"></a>6.3 A的左孩子的右子树插入节点(LR)</h4><p>若 A 的左孩子节点 B 的右子树 E 插入节点 F ，导致节点 A 失衡，如图：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzonocvbarj31gm0k4jrh.jpg" alt="图 6.3"></p><p>A 的平衡因子为 2 ，若仍按照右旋调整，则变化后的图形为这样：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzonqswj1cj31gy0j074a.jpg" alt="图 6.3.1"></p><p>经过右旋调整发现，调整后树仍然失衡，说明这种情况单纯的进行右旋操作不能使树重新平衡。那么这种插入方式需要执行两步操作，使得旋转之后为 <strong>原来根节点的左孩子的右孩子作为新的根节点</strong>。</p><p>（1）对失衡节点 A 的左孩子 B 进行左旋操作，即上述 RR 情形操作。<br>（2）对失衡节点 A 做右旋操作，即上述 LL 情形操作。</p><p>调整过程如下：</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzoo8glkatj31gq0l0t8v.jpg" alt="图 6.3.2"></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzoo8g596dj31gw0jit8t.jpg" alt="图 6.3.3"></p><p>也就是说，经过这两步操作，使得 <strong>原来根节点的左孩子的右孩子 E 节点成为了新的根节点</strong>。</p><p>代码实现：</p><pre class=" language-c++"><code class="language-c++">//LR型，先左旋转，再右旋转//返回：新父节点Tree LR_rotate(Tree node){    RR_rotate(node->lchild);    return LL_rotate(node);}</code></pre><h4 id="6-4-A的右孩子的左子树插入节点-RL"><a href="#6-4-A的右孩子的左子树插入节点-RL" class="headerlink" title="6.4 A的右孩子的左子树插入节点(RL)"></a>6.4 A的右孩子的左子树插入节点(RL)</h4><p>右孩子插入左节点的过程与左孩子插入右节点过程类似，也是需要执行两步操作，使得旋转之后为 <strong>原来根节点的右孩子的左孩子作为新的根节点</strong>。</p><p>（1）对失衡节点 A 的右孩子 C 进行右旋操作，即上述 LL 情形操作。<br>（2）对失衡节点 A 做左旋操作，即上述 RR 情形操作。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzqmh6y5ohj31me0mc3yl.jpg" alt="图 6.4"></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzooj35wnqj31gs0jsmxb.jpg" alt="图 6.4.1"></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzooj2th5lj31gc0jqwel.jpg" alt="图 6.4.2"></p><p>也就是说，经过这两步操作，使得 <strong>原来根节点的右孩子的左孩子 D 节点成为了新的根节点</strong>。</p><p>代码实现：</p><pre class=" language-c++"><code class="language-c++">//RL型，先右旋转，再左旋转//返回:新父节点Tree RL_rotate(Tree node){    LL_rotate(node->rchild);    return RR_rotate(node);}</code></pre><p><strong>补充</strong>：</p><p>上述四种插入方式的代码实现的辅助代码如下：</p><pre class=" language-c++"><code class="language-c++">//更新当前深度void update_depth(Tree node){    if (node==NULL){        return;    }else{        int depth_Lchild=get_balance(node->lchild); //左孩子深度        int depth_Rchild=get_balance(node->rchild); //右孩子深度        node->depth=max(depth_Lchild,depth_Rchild)+1;    }}//获取当前节点的深度int get_balance(Tree node){    if (node==NULL){         return 0;    }    return node->depth;}//返回当前平衡因子int is_balance(Tree node){    if (node==NULL){         return 0;    }else{         return get_balance(node->lchild)-get_balance(node->rchild);     }}</code></pre><h4 id="6-5-小总结"><a href="#6-5-小总结" class="headerlink" title="6.5 小总结"></a>6.5 小总结</h4><ol><li>在所有的不平衡情况中，都是按照先 <strong>寻找最小不平衡树</strong>，然后 <strong>寻找所属的不平衡类别</strong>，再 <strong>根据 4 种类别进行固定化程序的操作</strong>。</li><li>LL , LR ，RR ，RL其实已经为我们提供了最后哪个节点作为新的根指明了方向。如 LR 型最后的根节点为原来的根的左孩子的右孩子，RL 型最后的根节点为原来的根的右孩子的左孩子。只要记住这四种情况，可以很快地推导出所有的情况。</li><li>维护平衡二叉树，最麻烦的地方在于平衡因子的维护。建议读者们根据小吴提供的图片和动图，自己动手画一遍，这样可以更加感性的理解操作。</li></ol><h3 id="7-AVL树的四种删除节点方式"><a href="#7-AVL树的四种删除节点方式" class="headerlink" title="7. AVL树的四种删除节点方式"></a>7. AVL树的四种删除节点方式</h3><p>AVL 树和二叉查找树的删除操作情况一致，都分为四种情况：</p><p>（1）删除叶子节点<br>（2）删除的节点只有左子树<br>（3）删除的节点只有右子树<br>（4）删除的节点既有左子树又有右子树</p><p>只不过 AVL 树在删除节点后需要重新<strong>检查平衡性并修正</strong>，同时，删除操作与插入操作后的平衡修正区别在于，插入操作后只需要对插入栈中的弹出的第一个非平衡节点进行修正，而删除操作需要修正栈中的所有非平衡节点。</p><p>删除操作的大致步骤如下：</p><ul><li>以前三种情况为基础尝试删除节点，并将访问节点入栈。</li><li>如果尝试删除成功，则依次检查栈顶节点的平衡状态，遇到非平衡节点，即进行旋转平衡，直到栈空。</li><li>如果尝试删除失败，证明是第四种情况。这时先找到被删除节点的右子树最小节点并删除它，将访问节点继续入栈。</li><li>再依次检查栈顶节点的平衡状态和修正直到栈空。</li></ul><p>对于删除操作造成的非平衡状态的修正，可以这样理解：对左或者右子树的删除操作相当于对右或者左子树的插入操作，然后再对应上插入的四种情况选择相应的旋转就好了。</p><h4 id="7-1-删除叶子节点"><a href="#7-1-删除叶子节点" class="headerlink" title="7.1 删除叶子节点"></a>7.1 删除叶子节点</h4><p>处理步骤：</p><p>  ①、将该节点直接从树中删除；</p><p>  ②、其父节点的子树高度的变化将导致父节点平衡因子的变化，通过向上检索并推算其父节点是否失衡；</p><p>  ③、如果其父节点未失衡，则继续向上检索推算其父节点的父节点是否失衡…如此反复②的判断，直到根节点 ；如果向上推算过程中发现了失衡的现象，则进行 ④ 的处理；</p><p>  ④、如果其父节点失衡，则判断是哪种失衡类型 [LL、LR、RR、RL] ，并对其进行相应的平衡化处理。如果平衡化处理结束后，发现与原来以父节点为根节点的树的高度发生变化，则继续进行 ② 的检索推算；如果与原来以父节点为根节点的高度一致时，则可说明父节点的父节点及祖先节点的平衡因子将不会有变化，因此可以退出处理；</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzqnvf8q5mg30qe0epach.gif" alt="动图 7.1.1"></p><p>具体数字演示：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzqne0cjl8g30qe0epdi7.gif" alt="动图 7.1"></p><h4 id="7-2-amp-7-3-删除的节点只有左子树或右子树"><a href="#7-2-amp-7-3-删除的节点只有左子树或右子树" class="headerlink" title="7.2  &amp; 7.3 删除的节点只有左子树或右子树"></a>7.2  &amp; 7.3 删除的节点只有左子树或右子树</h4><p>处理步骤：</p><p>  ①、将左子树（右子树）替代原有节点 C 的位置；</p><p>  ②、节点  C 被删除后，则以 C 的父节点  B 为起始推算点，依此向上检索推算各节点（父、祖先）是否失衡；</p><p>  ③、如果其父节点未失衡，则继续向上检索推算其父节点 的父节点 是否失衡…如此反复 ② 的判断，直到根节点 ；如果向上推算过程中发现了失衡的现象，则进行 ④ 的处理；</p><p> ④、如果其父节点失衡，则判断是哪种失衡类型 [LL、LR、RR、RL] ，并对其进行相应的平衡化处理。如果平衡化处理结束后，发现与原来以父节点为根节点的树的高度发生变化，则继续进行 ② 的检索推算；如果与原来以父节点为根节点的高度一致时，则可说明父节点的父节点及祖先节点的平衡因子将不会有变化，因此可以退出处理；</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzqovwao9xg30qe0epwfv.gif" alt="动图 7.2"></p><h4 id="7-4-删除的节点既有左子树又有右子树"><a href="#7-4-删除的节点既有左子树又有右子树" class="headerlink" title="7.4 删除的节点既有左子树又有右子树"></a>7.4 删除的节点既有左子树又有右子树</h4><p>处理步骤：</p><p>  ①、找到被删节点 B 和替代节点 BLR (节点 B 的前继节点或后继节点 —— 在此选择 <strong>前继</strong>)；</p><p>  ②、将替代节点 BLR 的值赋给节点 B ，再把替代节点 BLR 的左孩子 BLRL 替换替代节点 BLR 的位置；</p><p>  ③、以 BLR 的父节点 BL 为起始推算点，依此向上检索推算父节点或祖先节点是否失衡；</p><p>  ④、如果其父节点未失衡，则继续向上检索推算其父节点的父节点是否失衡…如此反复③的判断，直到根节点；如果向上推算过程中发现了失衡的现象，则进行⑤的处理；</p><p>  ⑤、如果其父节点失衡，则判断是哪种失衡类型  [LL、LR、RR、RL]  ，并对其进行相应的平衡化处理。如果平衡化处理结束后，发现与原来以父节点为根节点的树的高度发生变化，则继续进行 ② 的检索推算；如果与原来以父节点为根节点的高度一致时，则可说明父节点的父节点及祖先节点的平衡因子将不会有变化，因此可以退出处理；</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzqpk97lodg30qe0epju1.gif" alt="动图 7.4"></p><p>注：在这里，小吴并没有给出 AVL 的删除操作的代码，也没有给出平衡性修复的动画，因为我并不打算过多去讨论它，更复杂的删除操作过程将放在后续的 <strong>红黑树</strong> 中进行讨论。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过对 AVL 的插入操作和删除操作可以看出，平衡二叉树的优势在于不会出现普通二叉查找树的最差情况，即退化成链表结构，但为了保证高度平衡（对称），动态插入和删除的代价也随之增加。</p><p>AVL 的旋转问题看似复杂，但实际上如果你亲自用笔纸操作一下还是很好理解的。</p>]]></content>
      
      
      <categories>
          
          <category> 高级算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>啥是佩奇排名算法</title>
      <link href="/posts/17626341/"/>
      <url>/posts/17626341/</url>
      
        <content type="html"><![CDATA[<h3 id="佩奇排名介绍"><a href="#佩奇排名介绍" class="headerlink" title="佩奇排名介绍"></a>佩奇排名介绍</h3><p>佩奇排名是根据页面之间的链接结构计算页面的值的一种算法。下面我们通过动画来理解进行计算的具体流程。</p><p>假设一个正方形表示一个 WEB 页面，一个箭头表示一个页面之间的链接。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdce7fb77a8?w=2110&amp;h=1184&amp;f=png&amp;s=88799" alt="此图表明下面 3 页包含指向上面 1 页的链接"></p><p>在佩奇排名算法中，网页指向的链接越多，页面被确定为越重要。</p><p>因此，在这里，确定首页最重要。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdce863e479?w=958&amp;h=535&amp;f=gif&amp;s=29656" alt="确定首页最重要"></p><p>实际上，每个页面的重要性都是通过计算来量化的。</p><h4 id="基本的计算方法思想"><a href="#基本的计算方法思想" class="headerlink" title="基本的计算方法思想"></a>基本的计算方法思想</h4><p>1.未链接的页面分数为 1</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdce88b9013?w=1920&amp;h=1078&amp;f=png&amp;s=78229" alt="未链接的页面分数为 1"></p><p>2.有链接的页面得分为正在链接的页面的总得分</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdce8d11b44?w=1918&amp;h=1078&amp;f=png&amp;s=90471" alt=".有链接的页面得分为正在链接的页面的总得分"></p><p>3.当有多个网页的链接时，链接分数均匀分布</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdcea312ae5?w=958&amp;h=535&amp;f=gif&amp;s=74616" alt="链接分数均匀分布"></p><p>4.来自高度链接网页的链接具有很高的价值</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdceae34912?w=1914&amp;h=1088&amp;f=png&amp;s=91417" alt=""></p><p>该图中心页面有三个独立页面指向它的链接，所以它的分数是 3 。<br>首页有一个很大的分数，因为链接是从分数为 3 的页面指向它的。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd163c0dcd?w=958&amp;h=535&amp;f=gif&amp;s=118317" alt=""></p><p>在动画中的六个页面中，判断最上面的页面是最重要的页面—-这是佩奇排名的基本思想。</p><h4 id="基本的计算方法思想的循环问题"><a href="#基本的计算方法思想的循环问题" class="headerlink" title="基本的计算方法思想的循环问题"></a>基本的计算方法思想的循环问题</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd22e57fa0?w=1928&amp;h=1074&amp;f=png&amp;s=92132" alt=""></p><p>如果按照顺序来计算每个页面的分数时，那么就会出现问题：以这种方式计算，它将无限循环，并且在循环中的页面得分在任何地方都会很高。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd36452959?w=958&amp;h=535&amp;f=gif&amp;s=147796" alt=""></p><p>循环的问题可以通过“随机游走模型”的计算方法来解决。</p><h3 id="随机游走模型"><a href="#随机游走模型" class="headerlink" title="随机游走模型"></a>随机游走模型</h3><p>以小猪佩奇浏览网页为例。</p><p>小猪佩奇开始访问「五分钟学算法」中有趣的页面，那么从这个左下角页面开始。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd3662dfe4?w=958&amp;h=535&amp;f=gif&amp;s=270716" alt=""></p><p>它们跟随一个链接并移动到另外的一个页面，看了一些之后，发现不敢兴趣了，这样就停止了浏览。</p><p>然后，又一天，它在小吴的推荐下，在完全不同的页面进行浏览，跟随一个链接并移动到另外的一个页面，一旦失去兴趣就停止浏览。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd39f892f5?w=958&amp;h=535&amp;f=gif&amp;s=182307" alt=""></p><p><strong>像这样，重复从某个页面开始浏览，移动几页后便停止的操作</strong>，如果从互联网空间一侧进行观察，就像网页浏览的人：重复移动页面几次后传送到一个完全不同的页面。</p><h3 id="量化随机游走模型"><a href="#量化随机游走模型" class="headerlink" title="量化随机游走模型"></a>量化随机游走模型</h3><p>假设 <code>1 - α</code> 代表选择当前页面中的一个链接的概率。</p><p> <code>α</code>代表该人将传送到其他页面的概率。</p><p> <img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd3adbd09d?w=958&amp;h=535&amp;f=gif&amp;s=178680" alt=""></p><p> 现在用 随机游走模型 处理上述的循环问题。</p><p> <img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd46b0fdd4?w=958&amp;h=535&amp;f=gif&amp;s=373034" alt=""></p><p> 如果总页面访问次数达到1000次之后，使用百分比进行表示：<strong>那么这个值就表示“在某个时间点查看页面的概率”</strong>。</p><p> <img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd489adc67?w=958&amp;h=535&amp;f=gif&amp;s=97953" alt=""></p><h3 id="更实用的计算方法"><a href="#更实用的计算方法" class="headerlink" title="更实用的计算方法"></a>更实用的计算方法</h3><p> 如图所示，现在来尝试计算复杂的链接网络中每个页面的分数。</p><p> <img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd70aafd4b?w=1914&amp;h=1076&amp;f=png&amp;s=100553" alt=""></p><p> 现在均匀设置分数，使总分加起来为 1 。而后根据网页浏览者的移动，来计算每个页面的概率。</p><blockquote><p>移动 n 次时出现在 A 中的概率表示未 <code>PAn</code>，移动 n 次时出现在 B 中的概率表示未 <code>PBn</code>。</p></blockquote><p> 举一个例子，在移动 1 次之后求在 A 的概率 <code>PA 1</code>。</p><p> <img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd71168fcb?w=958&amp;h=535&amp;f=gif&amp;s=149470" alt=""></p><p> 在 C 选择移动的概率是 <code>1-α</code>。</p><p> 其中，移动到 A 的一种场景是，C 中的佩奇选择了移动而不是传送。另外，这里选择了 A 而不是 B 作为目的地。<br> 并且，根据上面的 <code>当有多个网页的链接时，链接分数均匀分布</code> 这条规则，从 A 或 B 选择 A 的概率是 0.5 。</p><p> <img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd7238f422?w=958&amp;h=535&amp;f=gif&amp;s=149537" alt=""></p><p> 因此，从 C 移动到 A 的概率是 <code>PC0 ✖️ （1-α） ✖️ 0.5</code>。</p><p> <img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd74811ed7?w=958&amp;h=535&amp;f=gif&amp;s=255773" alt="A 被选为传送目标的概率是 0.25"></p><p>A 被选为传送目标的概率是 0.25 ，根据前面的理论：在 A、B、C、D 中小佩奇选择传送的概率为 <code>α</code>。因此，通过传送移动到 A 的概率为 <code>α ✖️ 0.25</code>。<br> 所以，移动一次后在 A 的概率为<br> <code>PA1 = PC0 ✖️ （ 1 - α ) ✖️ 0.5  +  α ✖️ 0.25</code></p><p> 其中 <code>PC0 = 0.25</code> ， <code>α = 0.15</code>，代入计算后 <code>PA1 = 0.14375</code>。</p><p> 这样，通过计算后 B 、 C 、D 页的概率也更新了。</p><p> <img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd7d493022?w=1916&amp;h=1070&amp;f=png&amp;s=102999" alt="B 、 C 、D 页的概率也更新了"></p><p>上面在移动 1 次之后这四个页面的概率更新情况，根据上述相同的方法计算 2 次后小佩奇浏览在每个页面的概率。</p><p> <img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd83fa09b0?w=1924&amp;h=1078&amp;f=png&amp;s=103117" alt="移动 2 次后"></p><p>同样的，经过大量的移动，在每个页面上的概率逐渐趋于固定值。当数值固定是，计算也就完成了。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd9f21920c?w=1930&amp;h=1088&amp;f=png&amp;s=122405" alt=""></p><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3><p>佩奇排名就是这样一种通过访问概率代替链接的权重来计算的机制。</p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新手 </tag>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看动画轻松理解「Trie树」</title>
      <link href="/posts/cb9dd1de/"/>
      <url>/posts/cb9dd1de/</url>
      
        <content type="html"><![CDATA[<h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><blockquote><p>Trie这个名字取自“retrieval”，检索，因为Trie可以只用一个前缀便可以在一部字典中找到想要的单词。<br>虽然发音与「Tree」一致，但为了将这种 字典树 与 普通二叉树 以示区别，程序员小吴一般读「Trie」尾部会重读一声，可以理解为读「TreeE」。</p></blockquote><p>Trie 树，也叫“字典树”。顾名思义，它是一个<strong>树形结构</strong>。它是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。</p><p>此外 Trie 树也称前缀树（因为某节点的后代存在共同的前缀，比如pan是panda的前缀）。</p><p>它的key都为字符串，能做到高效查询和插入，时间复杂度为O(k)，k为字符串长度，缺点是如果大量字符串没有共同前缀时很耗内存。</p><p><strong>它的核心思想就是通过最大限度地减少无谓的字符串比较，使得查询高效率，即「用空间换时间」，再利用共同前缀来提高查询效率。</strong></p><h3 id="Trie树的特点"><a href="#Trie树的特点" class="headerlink" title="Trie树的特点"></a>Trie树的特点</h3><p>假设有 5 个字符串，它们分别是：code，cook，five，file，fat。现在需要在里面多次查找某个字符串是否存在。如果每次查找，都是拿要查找的字符串跟这 5 个字符串依次进行字符串匹配，那效率就比较低，有没有更高效的方法呢？</p><p>如果将这 5 个字符串组织成下图的结构，从肉眼上扫描过去感官上是不是比查找起来会更加迅速。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/2/1680c049b54e82cd?w=1922&amp;h=1074&amp;f=png&amp;s=102217" alt="Trie树样子"></p><p>通过上图，可以发现 Trie树 的三个特点：</p><ul><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串</li><li>每个节点的所有子节点包含的字符都不相同</li></ul><p>通过动画理解 Trie 树构造的过程。在构造过程中的每一步，都相当于往 Trie 树中插入一个字符串。当所有字符串都插入完成之后，Trie 树就构造好了。<br> <img src="https://user-gold-cdn.xitu.io/2019/1/2/1680c049b5365880?w=957&amp;h=536&amp;f=gif&amp;s=125312" alt=" Trie 树构造"></p><h3 id="Trie树的插入操作"><a href="#Trie树的插入操作" class="headerlink" title="Trie树的插入操作"></a>Trie树的插入操作</h3><p><img src="https://user-gold-cdn.xitu.io/2019/1/2/1680c049b51f4db2?w=957&amp;h=536&amp;f=gif&amp;s=223535" alt="Trie树的插入操作"></p><p>Trie树的插入操作很简单，其实就是将单词的每个字母逐一插入 Trie树。插入前先看字母对应的节点是否存在，存在则共享该节点，不存在则创建对应的节点。比如要插入新单词<code>cook</code>，就有下面几步：</p><ul><li>插入第一个字母 <code>c</code>，发现 <code>root</code> 节点下方存在子节点 <code>c</code>，则共享节点 <code>c</code></li><li>插入第二个字母 <code>o</code>，发现 <code>c</code> 节点下方存在子节点 <code>o</code>，则共享节点 <code>o</code></li><li>插入第三个字母 <code>o</code>，发现 <code>o</code> 节点下方不存在子节点 <code>o</code>，则创建子节点 <code>o</code></li><li>插入第三个字母 <code>k</code>，发现 <code>o</code> 节点下方不存在子节点 <code>k</code>，则创建子节点 <code>k</code></li><li>至此，单词 <code>cook</code> 中所有字母已被插入 Trie树 中，然后设置节点 <code>k</code> 中的标志位，标记路径 <code>root-&gt;c-&gt;o-&gt;o-&gt;k</code>这条路径上所有节点的字符可以组成一个单词<code>cook</code></li></ul><h3 id="Trie树的查询操作"><a href="#Trie树的查询操作" class="headerlink" title="Trie树的查询操作"></a>Trie树的查询操作</h3><p>在 Trie 树中查找一个字符串的时候，比如查找字符串 <code>code</code>，可以将要查找的字符串分割成单个的字符 c，o，d，e，然后从 Trie 树的根节点开始匹配。如图所示，绿色的路径就是在 Trie 树中匹配的路径。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/2/1680c049b57767ae?w=1928&amp;h=1084&amp;f=png&amp;s=149652" alt="code的匹配路径"></p><p>如果要查找的是字符串<code>cod</code>(鳕鱼)呢？还是可以用上面同样的方法，从根节点开始，沿着某条路径来匹配，如图所示，绿色的路径，是字符串<code>cod</code>匹配的路径。但是，路径的最后一个节点「d」并不是橙色的，并不是单词标志位，所以<code>cod</code>字符串不存在。也就是说，<code>cod</code>是某个字符串的前缀子串，但并不能完全匹配任何字符串。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/2/1680c049b7443080?w=1920&amp;h=1082&amp;f=png&amp;s=138065" alt="cod的匹配路径"></p><blockquote><p>程序员不要当一条咸鱼，要向 <code>cook</code> 靠拢：）</p></blockquote><h3 id="Trie树的删除操作"><a href="#Trie树的删除操作" class="headerlink" title="Trie树的删除操作"></a>Trie树的删除操作</h3><p>Trie树的删除操作与二叉树的删除操作有类似的地方，需要考虑删除的节点所处的位置，这里分三种情况进行分析：</p><h4 id="删除整个单词（比如hi）"><a href="#删除整个单词（比如hi）" class="headerlink" title="删除整个单词（比如hi）"></a>删除整个单词（比如<code>hi</code>）</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/2/1680c049b68802a6?w=957&amp;h=536&amp;f=gif&amp;s=177162" alt="删除整个单词"></p><ul><li>从根节点开始查找第一个字符<code>h</code></li><li>找到<code>h</code>子节点后，继续查找<code>h</code>的下一个子节点<code>i</code></li><li><code>i</code>是单词<code>hi</code>的标志位，将该标志位去掉</li><li><code>i</code>节点是<code>hi</code>的叶子节点，将其删除</li><li>删除后发现<code>h</code>节点为叶子节点，并且不是单词标志位，也将其删除</li><li>这样就完成了<code>hi</code>单词的删除操作</li></ul><h4 id="删除前缀单词（比如cod）"><a href="#删除前缀单词（比如cod）" class="headerlink" title="删除前缀单词（比如cod）"></a>删除前缀单词（比如<code>cod</code>）</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/2/1680c04a41644ab1?w=957&amp;h=536&amp;f=gif&amp;s=193343" alt="删除前缀单词"><br>这种方式删除比较简单。<br>只需要将<code>cod</code>单词整个字符串查找完后，<code>d</code>节点因为不是叶子节点，只需将其单词标志去掉即可。</p><h4 id="删除分支单词（比如cook）"><a href="#删除分支单词（比如cook）" class="headerlink" title="删除分支单词（比如cook）"></a>删除分支单词（比如<code>cook</code>）</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/2/1680c04a415421ef?w=957&amp;h=536&amp;f=gif&amp;s=173918" alt="删除分支单词"><br>与 <strong>删除整个单词</strong> 情况类似，区别点在于删除到 <code>cook</code> 的第一个 <code>o</code> 时，该节点为非叶子节点，停止删除，这样就完成<code>cook</code>字符串的删除操作。</p><h3 id="Trie树的应用"><a href="#Trie树的应用" class="headerlink" title="Trie树的应用"></a>Trie树的应用</h3><p>事实上 Trie树 在日常生活中的使用随处可见，比如这个：</p><p>具体来说就是经常用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。</p><h4 id="1-前缀匹配"><a href="#1-前缀匹配" class="headerlink" title="1. 前缀匹配"></a>1. 前缀匹配</h4><p>例如：找出一个字符串集合中所有以 <code>五分钟</code> 开头的字符串。我们只需要用所有字符串构造一个 trie树，然后输出以 五−&gt;分−&gt;钟 开头的路径上的关键字即可。</p><p>trie树前缀匹配常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/2/1680c04a4167a729?w=1430&amp;h=1210&amp;f=png&amp;s=392579" alt="google搜索"></p><h4 id="2-字符串检索"><a href="#2-字符串检索" class="headerlink" title="2. 字符串检索"></a>2. 字符串检索</h4><p>给出 N 个单词组成的熟词表，以及一篇全用小写英文书写的文章，按最早出现的顺序写出所有不在熟词表中的生词。</p><p>检索/查询功能是Trie树最原始的功能。给定一组字符串，查找某个字符串是否出现过，思路就是从根节点开始一个一个字符进行比较：</p><ul><li>如果沿路比较，发现不同的字符，则表示该字符串在集合中不存在。</li><li>如果所有的字符全部比较完并且全部相同，还需判断最后一个节点的标志位（标记该节点是否代表一个关键字）。</li></ul><h3 id="Trie树的局限性"><a href="#Trie树的局限性" class="headerlink" title="Trie树的局限性"></a>Trie树的局限性</h3><p>如前文所讲，Trie的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p><p>假设字符的种数有<code>m</code>个，有若干个长度为n的字符串构成了一个 Trie树 ，则每个节点的出度为 <code>m</code>（即每个节点的可能子节点数量为<code>m</code>），Trie树 的高度为<code>n</code>。很明显我们浪费了大量的空间来存储字符，此时Trie树的最坏空间复杂度为<code>O(m^n)</code>。也正由于每个节点的出度为<code>m</code>，所以我们能够沿着树的一个个分支高效的向下逐个字符的查询，而不是遍历所有的字符串来查询，此时Trie树的最坏时间复杂度为<code>O(n)</code>。</p><p>这正是空间换时间的体现，也是利用公共前缀降低查询时间开销的体现。</p>]]></content>
      
      
      <categories>
          
          <category> 高级算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看动画轻松理解「递归」与「动态规划」</title>
      <link href="/posts/ccd7f89d/"/>
      <url>/posts/ccd7f89d/</url>
      
        <content type="html"><![CDATA[<p>在学习「数据结构和算法」的过程中，因为人习惯了平铺直叙的思维方式，所以「递归」与「动态规划」这种带循环概念（绕来绕去）的往往是相对比较难以理解的两个抽象知识点。</p><p>程序员小吴打算使用动画的形式来帮助理解「递归」，然后通过「递归」的概念延伸至理解「动态规划」算法思想。</p><h3 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h3><p>先下定义：<strong>递归算法是一种直接或者间接调用自身函数或者方法的算法。</strong></p><p>通俗来说，递归算法的实质是把问题分解成规模缩小的同类问题的子问题，然后递归调用方法来表示问题的解。它有如下特点：</p><ul><li><ol><li>一个问题的解可以分解为几个子问题的解</li></ol></li><li><ol start="2"><li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li></ol></li><li><ol start="3"><li>存在递归终止条件，即必须有一个明确的递归结束条件，称之为递归出口</li></ol></li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d047ce29b?w=953&amp;h=537&amp;f=gif&amp;s=156148" alt="递归动画"></p><p>通过动画一个一个特点来进行分析。</p><h4 id="1-一个问题的解可以分解为几个子问题的解"><a href="#1-一个问题的解可以分解为几个子问题的解" class="headerlink" title="1.一个问题的解可以分解为几个子问题的解"></a>1.一个问题的解可以分解为几个子问题的解</h4><p>子问题就是相对与其前面的问题数据规模更小的问题。</p><p>在动图中①号问题（一块大区域）划分为②号问题，②号问题由两个子问题（两块中区域）组成。</p><h4 id="2-这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"><a href="#2-这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样" class="headerlink" title="2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"></a>2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</h4><p>「①号划分为②号」与「②号划分为③号」的逻辑是一致的，求解思路是一样的。</p><h4 id="3-存在递归终止条件，即存在递归出口"><a href="#3-存在递归终止条件，即存在递归出口" class="headerlink" title="3. 存在递归终止条件，即存在递归出口"></a>3. 存在递归终止条件，即存在递归出口</h4><p>把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。</p><p>①号划分为②号，②号划分为③号，③号划分为④号，划分到④号的时候每个区域只有一个不能划分的问题，这就表明存在递归终止条件。</p><h3 id="从递归的经典示例开始"><a href="#从递归的经典示例开始" class="headerlink" title="从递归的经典示例开始"></a>从递归的经典示例开始</h3><h4 id="一-数组求和"><a href="#一-数组求和" class="headerlink" title="一.数组求和"></a>一.数组求和</h4><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d04680364?w=953&amp;h=537&amp;f=gif&amp;s=170958" alt="数组求和"></p><pre><code>Sum(arr[0...n-1]) = arr[0] + Sum(arr[1...n-1])</code></pre><p>后面的 Sum 函数要解决的就是比前一个 Sum 更小的同一问题。</p><pre><code>Sum(arr[1...n-1]) = arr[1] + Sum(arr[2...n-1])</code></pre><p>以此类推，直到对一个空数组求和，空数组和为 0 ，此时变成了最基本的问题。</p><pre><code>Sum(arr[n-1...n-1] ) = arr[n-1] + Sum([])</code></pre><h4 id="二-汉诺塔问题"><a href="#二-汉诺塔问题" class="headerlink" title="二.汉诺塔问题"></a>二.汉诺塔问题</h4><p>汉诺塔（Hanoi Tower）问题也是一个经典的递归问题，该问题描述如下：</p><blockquote><p>汉诺塔问题：古代有一个梵塔，塔内有三个座A、B、C，A座上有64个盘子，盘子大小不等，大的在下，小的在上。有一个和尚想把这个盘子从A座移到B座，但每次只能允许移动一个盘子，并且在移动过程中，3个座上的盘子始终保持大盘在下，小盘在上。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d06ac04b2?w=953&amp;h=537&amp;f=gif&amp;s=129013" alt="两个盘子"></p><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d053ae4f6?w=953&amp;h=537&amp;f=gif&amp;s=191396" alt="三个盘子"></p><ul><li><p>①  如果只有 1 个盘子，则不需要利用 B 塔，直接将盘子从 A 移动到 C 。</p></li><li><p>② 如果有 2 个盘子，可以先将盘子 2 上的盘子 1 移动到 B ；将盘子 2 移动到 C ；将盘子 1 移动到 C 。这说明了：可以借助 B 将 2 个盘子从 A 移动到 C ，当然，也可以借助 C 将 2 个盘子从 A 移动到 B 。</p></li><li><p>③ 如果有 3 个盘子，那么根据 2 个盘子的结论，可以借助 C 将盘子 3 上的两个盘子从 A 移动到 B ；将盘子 3 从 A 移动到 C ，A 变成空座；借助 A 座，将 B 上的两个盘子移动到 C 。</p></li><li><p>④ 以此类推，上述的思路可以一直扩展到 n 个盘子的情况，将将较小的 n-1个盘子看做一个整体，也就是我们要求的子问题，以借助 B 塔为例，可以借助空塔 B 将盘子A上面的 n-1 个盘子从 A 移动到 B ；将A 最大的盘子移动到 C ， A 变成空塔；借助空塔 A ，将 B 塔上的 n-2 个盘子移动到 A，将 C 最大的盘子移动到 C， B 变成空塔。。。</p></li></ul><h4 id="三-爬台阶问题"><a href="#三-爬台阶问题" class="headerlink" title="三.爬台阶问题"></a>三.爬台阶问题</h4><p>问题描述：</p><blockquote><p> 一个人爬楼梯，每次只能爬1个或2个台阶，假设有n个台阶，那么这个人有多少种不同的爬楼梯方法？ </p></blockquote><p>先从简单的开始，以 4 个台阶为例，可以通过每次爬 1 个台阶爬完楼梯：</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d06bc802f?w=953&amp;h=537&amp;f=gif&amp;s=160386" alt="每次爬 1 个台阶"></p><p>可以通过先爬 2 个台阶，剩下的每次爬 1 个台阶爬完楼梯</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d06c90ce5?w=953&amp;h=537&amp;f=gif&amp;s=123221" alt="先爬 2 个台阶"></p><p>在这里，可以思考一下：可以根据第一步的走法把所有走法分为两类：</p><ul><li>① 第一类是第一步走了 1 个台阶</li><li>② 第二类是第一步走了 2 个台阶</li></ul><p>所以 n 个台阶的走法就等于先走 1 阶后，n-1 个台阶的走法 ，然后加上先走 2 阶后，n-2 个台阶的走法。</p><p>用公式表示就是：</p><blockquote><p><code>f(n) = f(n-1)+f(n-2)</code></p></blockquote><p>有了递推公式，递归代码基本上就完成了一半。那么接下来考虑递归终止条件。</p><p>当有一个台阶时，我们不需要再继续递归，就只有一种走法。</p><p>所以 <code>f(1)=1</code>。</p><p>通过用 <code>n = 2</code>，<code>n = 3</code> 这样比较小的数试验一下后发现这个递归终止条件还不足够。</p><p><code>n = 2</code> 时，<code>f(2) = f(1) + f(0)</code>。如果递归终止条件只有一个<code>f(1) = 1</code>，那 <code>f(2)</code> 就无法求解，递归无法结束。<br>所以除了 <code>f(1) = 1</code> 这一个递归终止条件外，还要有 <code>f(0) = 1</code>，表示走 0 个台阶有一种走法，从思维上以及动图上来看，这显得的有点不符合逻辑。所以为了便于理解，把 <code>f(2) = 2</code> 作为一种终止条件，表示走 2 个台阶，有两种走法，一步走完或者分两步来走。</p><p>总结如下：</p><ul><li>① 假设只有一个台阶，那么只有一种走法，那就是爬 1 个台阶</li><li>② 假设有两个个台阶，那么有两种走法，一步走完或者分两步来走</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d3cd8be6b?w=953&amp;h=537&amp;f=gif&amp;s=303733" alt="递归终止条件"></p><p>通过递归条件：</p><pre><code>f(1) = 1;f(2) = 2;f(n) = f(n-1)+f(n-2)</code></pre><p>很容易推导出递归代码：</p><pre><code>int f(int n) {  if (n == 1) return 1;  if (n == 2) return 2;  return f(n-1) + f(n-2);}</code></pre><p>通过上述三个示例，总结一下如何写递归代码：</p><ul><li>1.找到如何将大问题分解为小问题的规律</li><li>2.通过规律写出递推公式</li><li>3.通过递归公式的临界点推敲出终止条件</li><li>4.将递推公式和终止条件翻译成代码</li></ul><h3 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h3><p>介绍动态规划之前先介绍一下分治策略（Divide and Conquer）。</p><h4 id="分治策略"><a href="#分治策略" class="headerlink" title="分治策略"></a>分治策略</h4><p>将原问题分解为若干个规模较小但类似于原问题的子问题（<strong>Divide</strong>），「递归」的求解这些子问题（<strong>Conquer</strong>），然后再合并这些子问题的解来建立原问题的解。</p><p>因为在求解大问题时，需要递归的求小问题，因此一般用「递归」的方法实现，即自顶向下。</p><h4 id="动态规划（Dynamic-Programming）"><a href="#动态规划（Dynamic-Programming）" class="headerlink" title="动态规划（Dynamic Programming）"></a>动态规划（Dynamic Programming）</h4><p>动态规划其实和分治策略是类似的，也是将一个原问题分解为若干个规模较小的子问题，递归的求解这些子问题，然后合并子问题的解得到原问题的解。<br>区别在于这些子问题会有重叠，一个子问题在求解后，可能会再次求解，于是我们想到将这些子问题的<strong>解存储起来</strong>，当下次再次求解这个子问题时，直接拿过来就是。<br>其实就是说，动态规划所解决的问题是分治策略所解决问题的一个子集，只是这个子集更适合用动态规划来解决从而得到更小的运行时间。<br><strong>即用动态规划能解决的问题分治策略肯定能解决，只是运行时间长了</strong>。因此，分治策略一般用来解决子问题相互对立的问题，称为标准分治，而动态规划用来解决子问题重叠的问题。</p><p>与「分治策略」「动态规划」概念接近的还有「贪心算法」「回溯算法」，由于篇幅限制，程序员小吴就不在这进行展开，在后续的文章中将分别详细的介绍「贪心算法」、「回溯算法」、「分治算法」，敬请关注：）</p><p>将「动态规划」的概念关键点抽离出来描述就是这样的：</p><ul><li>1.动态规划法试图只解决每个子问题一次</li><li>2.一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 </li></ul><h3 id="从递归到动态规划"><a href="#从递归到动态规划" class="headerlink" title="从递归到动态规划"></a>从递归到动态规划</h3><p>还是以 <strong>爬台阶</strong> 为例，如果以递归的方式解决的话，那么这种方法的时间复杂度为O(2^n)，具体的计算可以查看笔者之前的文章 《冰与火之歌：时间复杂度与空间复杂度》。</p><blockquote><p>相同颜色代表着 爬台阶问题 在递归计算过程中重复计算的部分。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d3cf51362?w=1518&amp;h=858&amp;f=png&amp;s=86406" alt="爬台阶的时间复杂度"></p><p>通过图片可以发现一个现象，我们是 自顶向下 的进行递归运算，比如：<code>f(n)</code> 是<code>f(n-1)</code>与<code>f(n-2)</code>相加，<code>f(n-1)</code> 是<code>f(n-2)</code>与<code>f(n-3)</code>相加。</p><p>思考一下：如果反过来，采取自底向上，用迭代的方式进行推导会怎么样了？</p><p>下面通过表格来解释 <code>f(n)</code>自底向上的求解过程。</p><table><thead><tr><th style="text-align:left">台阶数</th><th style="text-align:center">1</th><th style="text-align:right">2</th><th style="text-align:right">3</th><th style="text-align:right">4</th><th style="text-align:right">5</th><th style="text-align:right">6</th><th style="text-align:right">7</th><th style="text-align:right">8</th><th style="text-align:right">9</th></tr></thead><tbody><tr><td style="text-align:left">走法数</td><td style="text-align:center">1</td><td style="text-align:right">2</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td></tr></tbody></table><p>表格的第一行代表了楼梯台阶的数目，第二行代表了若干台阶对应的走法数。<br>其中<code>f(1) = 1</code> 和 <code>f(2) = 2</code>是前面明确的结果。</p><p>第一次迭代，如果台阶数为 3 ，那么走法数为 3 ，通过 <code>f(3) = f(2) + f(1)</code>得来。</p><table><thead><tr><th style="text-align:left">台阶数</th><th style="text-align:center">1</th><th style="text-align:right">2</th><th style="text-align:right">3</th><th style="text-align:right">4</th><th style="text-align:right">5</th><th style="text-align:right">6</th><th style="text-align:right">7</th><th style="text-align:right">8</th><th style="text-align:right">9</th></tr></thead><tbody><tr><td style="text-align:left">走法数</td><td style="text-align:center">1</td><td style="text-align:right">2</td><td style="text-align:right">3</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td></tr></tbody></table><p>第二次迭代，如果台阶数为 4 ，那么走法数为 5 ，通过 <code>f(4) = f(3) + f(2)</code>得来。</p><table><thead><tr><th style="text-align:left">台阶数</th><th style="text-align:center">1</th><th style="text-align:right">2</th><th style="text-align:right">3</th><th style="text-align:right">4</th><th style="text-align:right">5</th><th style="text-align:right">6</th><th style="text-align:right">7</th><th style="text-align:right">8</th><th style="text-align:right">9</th></tr></thead><tbody><tr><td style="text-align:left">走法数</td><td style="text-align:center">1</td><td style="text-align:right">2</td><td style="text-align:right">3</td><td style="text-align:right">5</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td></tr></tbody></table><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d3ded7651?w=953&amp;h=537&amp;f=gif&amp;s=71448" alt=""></p><p>由此可见，每一次迭代过程中，只需要保留之前的两个状态，就可以推到出新的状态。</p><blockquote><p>show me the code</p></blockquote><pre><code>int f(int n) {    if (n == 1) return 1;    if (n == 2) return 2;    // a 保存倒数第二个子状态数据，b 保存倒数第一个子状态数据， temp 保存当前状态的数据    int a = 1, b = 2;    int temp = a + b;    for (int i = 3; i &lt;= n; i++) {        temp = a + b;        a = b;        b = temp;     }    return temp; }</code></pre><p>程序从 <code>i = 3</code> 开始迭代，一直到 <code>i = n</code> 结束。每一次迭代，都会计算出多一级台阶的走法数量。迭代过程中只需保留两个临时变量 a 和 b ，分别代表了上一次和上上次迭代的结果。为了便于理解，引入了temp变量。temp代表了当前迭代的结果值。</p><p>看一看出，事实上并没有增加太多的代码，只是简单的进行了优化，时间复杂度便就降为O(n)，而空间复杂度也变为O(1)，这，就是「动态规划」的强大！</p><h3 id="详解动态规划"><a href="#详解动态规划" class="headerlink" title="详解动态规划"></a>详解动态规划</h3><p>「动态规划」中包含三个重要的概念：</p><ul><li>【最优子结构】</li><li>【边界】</li><li>【状态转移公式】</li></ul><p>在「 爬台阶问题 」中</p><blockquote><p><code>f(10) = f(9) + f(8)</code> 是【最优子结构】<br><code>f(1) 与 f(2)</code> 是【边界】<br><code>f(n) = f(n-1) + f(n-2)</code> 【状态转移公式】</p></blockquote><p>「 爬台阶问题 」 只是动态规划中相对简单的问题，因为它只有一个变化维度，如果涉及多个维度的话，那么问题就变得复杂多了。 </p><p><strong>难点就在于找出 「动态规划」中的这三个概念。</strong></p><p>比如「 国王和金矿问题 」。</p><h4 id="国王和金矿问题"><a href="#国王和金矿问题" class="headerlink" title="国王和金矿问题"></a>国王和金矿问题</h4><blockquote><p>有一个国家发现了 5 座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是 10 人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？<br><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d3e0c8a2a?w=1448&amp;h=284&amp;f=png&amp;s=27005" alt=" 5 座金矿"></p></blockquote><p><strong>找出 「动态规划」中的这三个概念</strong> </p><h5 id="国王和金矿问题中的【最优子结构】"><a href="#国王和金矿问题中的【最优子结构】" class="headerlink" title="国王和金矿问题中的【最优子结构】"></a>国王和金矿问题中的【最优子结构】</h5><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d3e263ca2?w=1918&amp;h=1080&amp;f=png&amp;s=126900" alt="国王和金矿问题中的【最优子结构】"></p><p>国王和金矿问题中的【最优子结构】有两个：</p><ul><li>① 4 金矿 10 工人的最优选择</li><li>② 4 金矿 （10 - 5） 工人的最优选择</li></ul><p>4 金矿的最优选择与 5 金矿的最优选择之间的关系是</p><p><code>MAX[（4 金矿 10 工人的挖金数量），（4 金矿 5 工人的挖金数量 + 第 5 座金矿的挖金数量）]</code></p><h5 id="国王和金矿问题中的【边界】"><a href="#国王和金矿问题中的【边界】" class="headerlink" title="国王和金矿问题中的【边界】"></a>国王和金矿问题中的【边界】</h5><p>国王和金矿问题中的【边界】 有两个：</p><ul><li>① 当只有 1 座金矿时，只能挖这座唯一的金矿，得到的黄金数量为该金矿的数量</li><li>② 当给定的工人数量不够挖 1 座金矿时，获取的黄金数量为 0 </li></ul><h5 id="国王和金矿问题中的【状态转移公式】"><a href="#国王和金矿问题中的【状态转移公式】" class="headerlink" title="国王和金矿问题中的【状态转移公式】"></a>国王和金矿问题中的【状态转移公式】</h5><p>我们把金矿数量设为 N，工人数设为 W，金矿的黄金量设为数组G[]，金矿的用工量设为数组P[]，得到【状态转移公式】：</p><ul><li><p>边界值：F(n,w) = 0    (n &lt;= 1, w &lt; p[0])</p></li><li><p><code>F(n,w) = g[0]   (n==1, w &gt;= p[0])</code></p></li><li><p>F(n,w) = F(n-1,w)    (n &gt; 1, w &lt; p[n-1]) </p></li><li><p><code>F(n,w) = max(F(n-1,w),  F(n-1,w-p[n-1]) + g[n-1])    (n &gt; 1, w &gt;= p[n-1])</code></p></li></ul><h3 id="国王和金矿问题中的【实现】"><a href="#国王和金矿问题中的【实现】" class="headerlink" title="国王和金矿问题中的【实现】"></a>国王和金矿问题中的【实现】</h3><p>先通过几幅动画来理解 「工人」 与 「金矿」 搭配的方式</p><h6 id="1-只挖第一座金矿"><a href="#1-只挖第一座金矿" class="headerlink" title="1.只挖第一座金矿"></a>1.只挖第一座金矿</h6><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d670b0774?w=957&amp;h=538&amp;f=gif&amp;s=318658" alt="只挖第一座金矿"></p><p>在只挖第一座金矿前面两个工人挖矿收益为 零，当有三个工人时，才开始产生收益为 200，而后即使增加再多的工人收益不变，因为只有一座金矿可挖。</p><h6 id="2-挖第一座与第二座金矿"><a href="#2-挖第一座与第二座金矿" class="headerlink" title="2.挖第一座与第二座金矿"></a>2.挖第一座与第二座金矿</h6><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d404376c8?w=957&amp;h=538&amp;f=gif&amp;s=586737" alt="挖第一座与第二座金矿"></p><p>在第一座与第二座金矿这种情况中，前面两个工人挖矿收益为 零，因为 W &lt; 3,所以F(N,W) = F(N-1,W) = 0。  </p><p>当有 三 个工人时，将其安排挖第 一 个金矿，开始产生收益为 200。</p><p>当有 四 个工人时，挖矿位置变化，将其安排挖第 二 个金矿，开始产生收益为 300。</p><p>当有 五、六 个工人时，由于多于 四 个工人的人数不足以去开挖第 一 座矿，因此收益还是为 300。</p><p>当有 七 个工人时，可以同时开采第 一 个和第 二 个金矿，开始产生收益为 500。</p><h6 id="3-挖前三座金矿"><a href="#3-挖前三座金矿" class="headerlink" title="3.挖前三座金矿"></a>3.挖前三座金矿</h6><p><strong>这是「国王和金矿」 问题中最重要的一个动画之一，可以多看几遍</strong><br><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d685f6826?w=957&amp;h=536&amp;f=gif&amp;s=543368" alt="挖前三座金矿"></p><h6 id="4-挖前四座金矿"><a href="#4-挖前四座金矿" class="headerlink" title="4.挖前四座金矿"></a>4.挖前四座金矿</h6><p><strong>这是「国王和金矿」 问题中最重要的一个动画之一，可以多看几遍</strong>    </p><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d6ef42679?w=957&amp;h=536&amp;f=gif&amp;s=329570" alt="挖前四座金矿"></p><h3 id="国王和金矿问题中的【规律】"><a href="#国王和金矿问题中的【规律】" class="headerlink" title="国王和金矿问题中的【规律】"></a>国王和金矿问题中的【规律】</h3><p>仔细观察上面的几组动画可以发现：</p><ul><li><p>对比「挖第一座与第二座金矿」和「挖前三座金矿」，在「挖前三座金矿」中，3 金矿 7 工人的挖矿收益，来自于 2 金矿 7 工人和  2 金矿 4 工人的结果，Max(500,300 + 350) = 650；</p></li><li><p>对比「挖前三座金矿」和「挖前四座金矿」，在「挖前四座金矿」中，4 金矿 10 工人的挖矿收益，来自于 3 金矿 10 工人和  3 金矿 5 工人的结果，Max(850,400 + 300) = 850；</p></li></ul><h3 id="国王和金矿问题中的【动态规划代码】"><a href="#国王和金矿问题中的【动态规划代码】" class="headerlink" title="国王和金矿问题中的【动态规划代码】"></a>国王和金矿问题中的【动态规划代码】</h3><pre><code>代码来源：https://www.cnblogs.com/SDJL/archive/2008/08/22/1274312.html//maxGold[i][j] 保存了i个人挖前j个金矿能够得到的最大金子数，等于 -1 时表示未知int maxGold[max_people][max_n];int GetMaxGold(int people, int mineNum){    int retMaxGold;                            //声明返回的最大金矿数量    //如果这个问题曾经计算过    if(maxGold[people][mineNum] != -1){        retMaxGold = maxGold[people][mineNum]; //获得保存起来的值    }else if(mineNum == 0) {                   //如果仅有一个金矿时 [ 对应动态规划中的&quot;边界&quot;]        if(people &gt;= peopleNeed[mineNum])      //当给出的人数足够开采这座金矿            retMaxGold = gold[mineNum];        //得到的最大值就是这座金矿的金子数        else                                   //否则这唯一的一座金矿也不能开采            retMaxGold = 0;                    //得到的最大值为 0 个金子    }else if(people &gt;= peopleNeed[mineNum])    // 如果人够开采这座金矿[对应动态规划中的&quot;最优子结构&quot;]    {        //考虑开采与不开采两种情况，取最大值        retMaxGold = max(                         GetMaxGold(people - peopleNeed[mineNum],mineNum - 1) + gold[mineNum],                         GetMaxGold(people,mineNum - 1)                         );    }else//否则给出的人不够开采这座金矿 [ 对应动态规划中的&quot;最优子结构&quot;]    {        retMaxGold = GetMaxGold(people,mineNum - 1);     //仅考虑不开采的情况        maxGold[people][mineNum] = retMaxGold;    }    return retMaxGold;}</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d6fea1634?w=2048&amp;h=1708&amp;f=png&amp;s=555294" alt="动态规划代码"></p>]]></content>
      
      
      <categories>
          
          <category> 高级算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道让你拍案叫绝的算法题</title>
      <link href="/posts/d9a29023/"/>
      <url>/posts/d9a29023/</url>
      
        <content type="html"><![CDATA[<p>这是一道看完答案会觉得很简单，但做之前很难想到答案的题目！！！</p><p>不信？</p><p>Let us go ！</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><p>输入: [2,2,1]<br>输出: 1</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><p>输入: [4,1,2,1,2]<br>输出: 4</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>根据题目描述，由于加上了时间复杂度必须是O(n)，并且空间复杂度为O(1)的条件，因此不能用排序方法，也不能使用map数据结构。</p><p>小吴想了一下午没想出来，答案是使用 <strong>位操作Bit Operation</strong> 来解此题。</p><p>将所有元素做异或运算，即a[1] ⊕  a[2] ⊕  a[3] ⊕ …⊕  a[n]，所得的结果就是那个只出现一次的数字，时间复杂度为O(n)。</p><h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><p>异或运算A ⊕  B的真值表如下：</p><table><thead><tr><th style="text-align:left">A</th><th style="text-align:center">B</th><th style="text-align:right">⊕</th></tr></thead><tbody><tr><td style="text-align:left">F</td><td style="text-align:center">F</td><td style="text-align:right">F</td></tr><tr><td style="text-align:left">F</td><td style="text-align:center">T</td><td style="text-align:right">T</td></tr><tr><td style="text-align:left">T</td><td style="text-align:center">F</td><td style="text-align:right">T</td></tr><tr><td style="text-align:left">T</td><td style="text-align:center">T</td><td style="text-align:right">F</td></tr></tbody></table><h3 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="https://user-gold-cdn.xitu.io/2019/1/16/168542e800a21633?w=959&amp;h=537&amp;f=gif&amp;s=456512" alt=""></p><h3 id="进阶版"><a href="#进阶版" class="headerlink" title="进阶版"></a>进阶版</h3><p>有一个 n 个元素的数组，除了两个数只出现一次外，其余元素都出现两次，让你找出这两个只出现一次的数分别是几，要求时间复杂度为 O(n) 且再开辟的内存空间固定(与 n 无关)。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例 :"></a>示例 :</h4><p>输入: [1,2,2,1,3,4]<br>输出: [3,4]</p><h3 id="题目再解析"><a href="#题目再解析" class="headerlink" title="题目再解析"></a>题目再解析</h3><p>根据前面找一个不同数的思路算法，在这里把所有元素都异或，那么得到的结果就是那两个只出现一次的元素异或的结果。</p><p>然后，因为这两个只出现一次的元素一定是不相同的，所以这两个元素的二进制形式肯定至少有某一位是不同的，即一个为 0 ，另一个为 1 ，现在需要找到这一位。</p><p>根据异或的性质 <code>任何一个数字异或它自己都等于 0</code>，得到这个数字二进制形式中任意一个为 1 的位都是我们要找的那一位。</p><p>再然后，以这一位是 1 还是 0 为标准，将数组的 n 个元素分成两部分。</p><ul><li><p>将这一位为 0 的所有元素做异或，得出的数就是只出现一次的数中的一个</p></li><li><p>将这一位为 1 的所有元素做异或，得出的数就是只出现一次的数中的另一个。</p></li></ul><p>这样就解出题目。忽略寻找不同位的过程，总共遍历数组两次，时间复杂度为O(n)。</p><h3 id="动画再演示"><a href="#动画再演示" class="headerlink" title="动画再演示"></a>动画再演示</h3><p><img src="https://user-gold-cdn.xitu.io/2019/1/16/168542e800e97866?w=958&amp;h=535&amp;f=gif&amp;s=413228" alt=""></p><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3><p>本题的基础版来源于 LeetCode 第 136 号问题：只出现一次的数字。虽然题目难度是 简单，但解法真的很巧妙。感兴趣的同学可以根据思路去回答一下：<a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/single-number/</a> 。</p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新手 </tag>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是鸡尾酒排序和地精排序？</title>
      <link href="/posts/9a8663f9/"/>
      <url>/posts/9a8663f9/</url>
      
        <content type="html"><![CDATA[<p>奇葩排序第二弹：）</p><h3 id="从冒泡排序开始"><a href="#从冒泡排序开始" class="headerlink" title="从冒泡排序开始"></a>从冒泡排序开始</h3><p>先来看回顾一下冒泡排序的思想和原理。</p><h4 id="冒泡排序的思想"><a href="#冒泡排序的思想" class="headerlink" title="冒泡排序的思想"></a>冒泡排序的思想</h4><p>冒泡排序的每一个元素都可以像小气泡一样，根据自身大小，一点一点向着数组的一侧移动。</p><h4 id="冒泡排序算法的原理"><a href="#冒泡排序算法的原理" class="headerlink" title="冒泡排序算法的原理"></a>冒泡排序算法的原理</h4><ul><li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p></li><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p></li><li><p>针对所有的元素重复以上的步骤，除了最后一个。</p></li><li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p></li></ul><p>一般情况下，可以通过下面的动画理解冒泡排序。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a569b8f9419f?w=954&amp;h=537&amp;f=gif&amp;s=906068" alt="冒泡排序"></p><p>现在我们来看一组特殊数据如果使用冒泡排序会怎么样。</p><p>将无序数列：2，3，4，5，6，7，8，1，使用冒泡排序使其从小到大排序。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a569b9213adb?w=1706&amp;h=308&amp;f=png&amp;s=26112" alt="无序数列"></p><p>进行逐步分析：</p><ol><li>第一轮操作（ 8 和 1 交换 ）<br><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a569b8b5a9df?w=849&amp;h=316&amp;f=gif&amp;s=130463" alt="第一轮操作（ 8 和 1 交换 ）"></li><li>第二轮操作（ 7 和 1 交换 ）<br><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a569bb608e55?w=849&amp;h=316&amp;f=gif&amp;s=99952" alt="第二轮操作（ 7 和 1 交换 ）"></li><li>第三轮操作（ 6 和 1 交换 ）<br><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a569baff9449?w=849&amp;h=316&amp;f=gif&amp;s=100137" alt="第三轮操作（ 6 和 1 交换 ）"></li><li>第四轮操作（ 5 和 1 交换 ）<br><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a569b946b782?w=849&amp;h=316&amp;f=gif&amp;s=92676" alt="第四轮操作（ 5 和 1 交换 ）"></li><li>第五轮操作（ 4 和 1 交换 ）<br><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a569e9873cdc?w=849&amp;h=316&amp;f=gif&amp;s=74263" alt="第五轮操作（ 4 和 1 交换 ）"></li><li>第六轮操作（ 3 和 1 交换 ）<br><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a569ea5cd54e?w=849&amp;h=316&amp;f=gif&amp;s=68982" alt="第六轮操作（ 3 和 1 交换 ）"></li><li>第七轮操作（ 2 和 1 交换 ）<br><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a569ec41b088?w=849&amp;h=316&amp;f=gif&amp;s=52410" alt="第七轮操作（ 2 和 1 交换 ）"></li></ol><p>仔细观察上面的这组无序数列，实际上只有 1 的位置不在该在的位置，而 2 ，3 ，4 ，5 ，6 ，7 ，8 都已经有序了，结果使用冒泡排序，需要 <strong>折腾 7 次</strong> 才能将 1 归位。</p><h3 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a>鸡尾酒排序</h3><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a569ef8b3ade?w=277&amp;h=257&amp;f=gif&amp;s=900082" alt="鸡尾酒排序"></p><p>鸡尾酒排序，也就是定向冒泡排序，鸡尾酒搅拌排序，搅拌排序（也可以视作选择排序的一种变形），涟漪排序，来回排序或快乐小时排序，是冒泡排序的一种变形。</p><p><strong>此算法与冒泡排序的不同处在于排序时是以双向在序列中进行排序。</strong></p><p>排序过程：</p><ul><li>先对数组从左到右进行冒泡排序（升序），则最大的元素去到最右端</li><li>再对数组从右到左进行冒泡排序（降序），则最小的元素去到最左端</li><li>以此类推，依次改变冒泡的方向，并不断缩小未排序元素的范围，直到最后一个元素结束</li></ul><p><strong>Show Me The Animation</strong></p><ol><li>第一轮操作（ 8 和 1 交换 ）<br><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a569f211de41?w=849&amp;h=316&amp;f=gif&amp;s=137385" alt="第一轮操作（ 8 和 1 交换 ）"></li><li>第二轮操作 ( 从序列右边开始遍历 ）<br><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a052f9d04?w=849&amp;h=316&amp;f=gif&amp;s=238107" alt="第二轮操作 ( 从序列右边开始遍历 ）"></li><li>第三轮操作 ( 从左向右比较和交换 )<br><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a14d62bde?w=849&amp;h=316&amp;f=gif&amp;s=142025" alt="第三轮操作 ( 从左向右比较和交换 )"><br>在这一轮操作中，没有元素位置交换，证明已经有序，排序结束。</li></ol><p>对比 冒泡排序 ，鸡尾酒排序只需要 3 轮操作就可以完成排序。</p><h3 id="地精排序"><a href="#地精排序" class="headerlink" title="地精排序"></a>地精排序</h3><blockquote><p>Gnome 排序（地精排序），起初由 Hamid Sarbazi-Azad 于 2000 年提出，并被称为 <strong>stupid</strong> 排序，后来被 Dick Grune 描述并命名为 “地精排序” 。</p></blockquote><p>地精排序和插入排序类似，除了移动一个元素到最终的位置，是通过交换一系列的元素实现，就像冒泡排序一样。概念上十分简单，不需要嵌套循环。时间复杂度为O(n2)，但是如果初始数列基本有序，时间复杂度将降为O(n)。实际上 Gnome 算法可以和插入排序算法一样快。平均运行时间为O(n^2)。</p><p>将无序数列：6，2，4，1，5，使用地精排序使其从小到大排序。</p><p>通过设计标识 i = 0 ，然后从头开始判断，什么时候 ( i &lt; 4 ) 不成立,什么时候排序结束。</p><p>这里的核心点就是 <strong>如何控制 i 的值</strong>。</p><h4 id="第一轮操作「i-0」"><a href="#第一轮操作「i-0」" class="headerlink" title="第一轮操作「i = 0」"></a>第一轮操作「i = 0」</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a2dd5946a?w=849&amp;h=284&amp;f=gif&amp;s=22189" alt=""></p><p>先让 i 自增 1 ，达到值为 1 才开始比较 ：</p><p>交换前 [ 6 2 4 1 ] 『 <strong>i = 0</strong> 』</p><p>交换后 [ 6 2 4 1 ] 『 <strong>i = 1</strong> 』</p><h4 id="第二轮操作「i-1」"><a href="#第二轮操作「i-1」" class="headerlink" title="第二轮操作「i = 1」"></a>第二轮操作「i = 1」</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a2f974af7?w=849&amp;h=284&amp;f=gif&amp;s=60337" alt=""></p><p>比较 6 和 2 ，发生交换，<strong>只要发生交换 i 就减 1</strong> 。</p><p>交换前 [ 6 2 4 1 ]『 i = 1 』</p><p>交换后 [ 2 6 4 1 ]『 i = 0 』</p><h4 id="第三轮操作「i-0」"><a href="#第三轮操作「i-0」" class="headerlink" title="第三轮操作「i = 0」"></a>第三轮操作「i = 0」</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a472e0671?w=849&amp;h=284&amp;f=gif&amp;s=35838" alt=""></p><p>i 变成 0 了，啥也不干，自增变成 1 再说。</p><p>交换前 [ 2 6 4 1 ]『 i = 0 』</p><p>交换后 [ 2 6 4 1 ]『 i = 1 』</p><h4 id="第四轮操作「i-1」"><a href="#第四轮操作「i-1」" class="headerlink" title="第四轮操作「i = 1」"></a>第四轮操作「i = 1」</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a45323fb0?w=849&amp;h=284&amp;f=gif&amp;s=39303" alt=""></p><p>比较 2 和 6 ，不交换，<strong>只要不要换就自增 1</strong>。</p><p>交换前 [ 2 6 4 1 ]『 i = 1 』</p><p>交换后 [ 2 6 4 1 ]『 i = 2 』</p><h4 id="第五轮操作「i-2」"><a href="#第五轮操作「i-2」" class="headerlink" title="第五轮操作「i = 2」"></a>第五轮操作「i = 2」</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a4aeb364c?w=849&amp;h=284&amp;f=gif&amp;s=58413" alt=""></p><p>比较 6 和 4 ，发生交换，<strong>只要发生交换 i 就减 1</strong> 。</p><p>交换前 [ 2 6 4 1 ]『 i = 2 』</p><p>交换后 [ 2 4 6 1 ]『 i = 1 』</p><h4 id="第六轮操作「i-1」"><a href="#第六轮操作「i-1」" class="headerlink" title="第六轮操作「i = 1」"></a>第六轮操作「i = 1」</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a59238d49?w=849&amp;h=284&amp;f=gif&amp;s=34234" alt=""></p><p>比较 2 和 4 ，不交换，<strong>只要不要换就自增 1</strong> 。</p><p>交换前 [ 2 6 4 1 ]『 i = 1 』</p><p>交换后 [ 2 4 6 1 ]『 i = 2 』</p><h4 id="第七轮操作「i-2」"><a href="#第七轮操作「i-2」" class="headerlink" title="第七轮操作「i = 2」"></a>第七轮操作「i = 2」</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a69973a0b?w=849&amp;h=284&amp;f=gif&amp;s=37032" alt=""></p><p>比较 4 和 6 ，不交换，<strong>只要不要换就自增 1</strong> 。</p><p>交换前 [ 2 4 6 1 ]『 i = 2 』</p><p>交换后 [ 2 4 6 1 ]『 i = 3 』</p><h4 id="第八轮操作「i-3」"><a href="#第八轮操作「i-3」" class="headerlink" title="第八轮操作「i = 3」"></a>第八轮操作「i = 3」</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a6a5948ac?w=849&amp;h=284&amp;f=gif&amp;s=58152" alt=""></p><p>比较 6 和 1 ，发生交换，<strong>只要发生交换 i 就减 1</strong> 。</p><p>交换前 [ 2 4 6 1 ]『 i = 3 』</p><p>交换后 [ 2 4 1 6 ]『 i = 2 』</p><h4 id="第九轮操作「i-2」"><a href="#第九轮操作「i-2」" class="headerlink" title="第九轮操作「i = 2」"></a>第九轮操作「i = 2」</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a6f54f0f3?w=849&amp;h=284&amp;f=gif&amp;s=56016" alt=""></p><p>比较 4 和 1 ，发生交换，<strong>只要发生交换 i 就减 1</strong> 。</p><p>交换前 [ 2 4 1 6 ]『 i = 2 』</p><p>交换后 [ 2 1 4 6 ]『 i = 1 』</p><h4 id="第十轮操作「i-1」"><a href="#第十轮操作「i-1」" class="headerlink" title="第十轮操作「i = 1」"></a>第十轮操作「i = 1」</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a70ad5a94?w=849&amp;h=284&amp;f=gif&amp;s=57170" alt=""></p><p>比较 2 和 1 ，发生交换，<strong>只要发生交换 i 就减 1</strong> 。</p><p>交换前 [ 2 1 4 6 ]『 i = 1 』</p><p>交换后 [ 1 2 4 6 ]『 i = 0 』</p><h4 id="第十一轮操作「i-0」"><a href="#第十一轮操作「i-0」" class="headerlink" title="第十一轮操作「i = 0」"></a>第十一轮操作「i = 0」</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a7089a4da?w=849&amp;h=284&amp;f=gif&amp;s=86734" alt=""></p><p>啥也不干，先让 i 自增1，达到值为 1 才开始真正的比较。   </p><p>『 i = 1 』时，比较 1 和 2 ，不交换，只要不交换就自增 1 。<br>『 i = 2 』时，比较 2 和 4 ，不交换，只要不交换就自增 1 。<br>『 i = 3 』时，比较 4 和 6 ，不交换，只要不交换就自增 1 。<br>『 i = 4 』时，表达式 （ i &lt; n ) 不成立，排序结束。  </p><p>顺序输出为 [ 1 2 4 6 ]。</p><h5 id="地精排序算法代码"><a href="#地精排序算法代码" class="headerlink" title="地精排序算法代码"></a>地精排序算法代码</h5><pre><code>template &lt;class T&gt;void gnome_sort_1(T data[], int n, bool comparator(T, T)){    int i = 1;    while (i &lt; n){       if (i &gt; 0 &amp;&amp; comparator(data[i], data[i-1])){           swap(data[i], data[i-1]);           i--;       }else{           i++;       }    }}</code></pre><p>这种地精排序算法还有很多优化的空间，这里小吴就不展开来讲了。</p><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3><p>鸡尾酒排序和地精排序虽然被程序员小吴归为奇葩排序一类，但是它们还是有一定的使用场景的。</p><ul><li>在「大部分元素有序」的情况下，使用鸡尾酒排序可以减少排序的回合数。</li><li>地精排序最著名的特点是代码只有一层循环，在「大部分元素有序」的情况下，可以减少排序回合数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 高级算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是散列表</title>
      <link href="/posts/5e0d3e1b/"/>
      <url>/posts/5e0d3e1b/</url>
      
        <content type="html"><![CDATA[<h1 id="【算法动画】：什么是散列表"><a href="#【算法动画】：什么是散列表" class="headerlink" title="【算法动画】：什么是散列表"></a>【算法动画】：什么是散列表</h1><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p><h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>散列函数，顾名思义，它是一个函数。如果把它定义成 <strong>hash(key)</strong> ，其中 key 表示元素的键值，则 <strong>hash(key)</strong> 的值表示经过散列函数计算得到的散列值。</p><p>散列函数的特点：</p><h4 id="1-确定性"><a href="#1-确定性" class="headerlink" title="1.确定性"></a>1.确定性</h4><p>如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的。</p><h4 id="2-散列碰撞（collision）"><a href="#2-散列碰撞（collision）" class="headerlink" title="2.散列碰撞（collision）"></a>2.散列碰撞（collision）</h4><p>散列函数的输入和输出不是唯一对应关系的，如果两个散列值相同，两个输入值很可能是相同的，但也可能不同。</p><h4 id="3-不可逆性"><a href="#3-不可逆性" class="headerlink" title="3.不可逆性"></a>3.不可逆性</h4><p>一个哈希值对应无数个明文，理论上你并不知道哪个是。</p><blockquote><p>“船长，如果一样东西你知道在哪里，还算不算丢了。”</p></blockquote><blockquote><p>“不算。”</p></blockquote><blockquote><p>“好的，那您的酒壶没有丢。”</p></blockquote><h4 id="4-混淆特性"><a href="#4-混淆特性" class="headerlink" title="4.混淆特性"></a>4.混淆特性</h4><p>输入一些数据计算出散列值，然后部分改变输入值，一个具有强混淆特性的散列函数会产生一个完全不同的散列值。</p><h3 id="常见的散列函数"><a href="#常见的散列函数" class="headerlink" title="常见的散列函数"></a>常见的散列函数</h3><h4 id="1-MD5"><a href="#1-MD5" class="headerlink" title="1. MD5"></a>1. MD5</h4><p><strong>MD5</strong> 即 Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一，主流编程语言普遍已有 <strong>MD5</strong> 实现。</p><p>将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，<strong>MD5</strong> 的前身有 MD2 、MD3 和 MD4 。</p><p><strong>MD5</strong> 是输入不定长度信息，输出固定长度 128-bits 的算法。经过程序流程，生成四个32位数据，最后联合起来成为一个 128-bits 散列。</p><p>基本方式为，求余、取余、调整长度、与链接变量进行循环运算，得出结果。</p><p><strong>MD5</strong> 计算广泛应用于错误检查。在一些 BitTorrent 下载中，软件通过计算 MD5 来检验下载到的碎片的完整性。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/7/16825d390f3b1755?w=960&amp;h=536&amp;f=gif&amp;s=50918" alt=" MD5 校验"></p><h4 id="2-SHA-1"><a href="#2-SHA-1" class="headerlink" title="2. SHA-1"></a>2. SHA-1</h4><p>SHA-1（英语：Secure Hash Algorithm 1，中文名：安全散列算法1）是一种密码散列函数，SHA-1可以生成一个被称为消息摘要的160位（20字节）散列值，散列值通常的呈现形式为40个十六进制数。</p><p>SHA-1 曾经在许多安全协议中广为使用，包括TLS和SSL、PGP、SSH、S/MIME和IPsec，曾被视为是MD5的后继者。</p><h3 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h3><p>理想中的一个散列函数，希望达到 </p><blockquote><p>如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)</p></blockquote><p>这种效果，然而在真实的情况下，要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的，即使是 <strong>MD5</strong> 或者 由美国国家安全局设计的 <strong>SHA-1</strong> 算法也无法实现。</p><p><strong>事实上，再好的散列函数都无法避免散列冲突。</strong></p><p>为什么呢？</p><p>这涉及到数学中比较好理解的一个原理：抽屉原理。</p><p>抽屉原理：桌上有十个苹果，要把这十个苹果放到九个抽屉里，无论怎样放，我们会发现至少会有一个抽屉里面至少放两个苹果。这一现象就是我们所说的“抽屉原理”。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/7/16825d390fb8193d?w=952&amp;h=539&amp;f=gif&amp;s=113143" alt="抽屉原理"></p><p>对于散列表而言，无论设置的存储区域（n）有多大，当需要存储的数据大于 n 时，那么必然会存在哈希值相同的情况。这就是所谓的<strong>散列冲突</strong>。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/7/16825d390fce0635?w=960&amp;h=536&amp;f=gif&amp;s=75709" alt="散列冲突"></p><p>那应该如何解决散列冲突问题呢？</p><p>常用的散列冲突解决方法有两类，开放寻址法（open addressing）和链表法（chaining）。</p><h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><blockquote><p>定义：将散列函数扩展定义成探查序列，即每个关键字有一个探查序列h(k,0)、h(k,1)、…、h(k,m-1)，这个探查序列一定是0….m-1的一个排列（一定要包含散列表全部的下标，不然可能会发生虽然散列表没满，但是元素不能插入的情况），如果给定一个关键字k，首先会看h(k,0)是否为空，如果为空，则插入；如果不为空，则看h(k,1)是否为空，以此类推。</p></blockquote><p>开放寻址法是一种解决碰撞的方法，对于开放寻址冲突解决方法，比较经典的有线性探测方法（Linear Probing）、二次探测（Quadratic probing）和 双重散列（Double hashing）等方法。</p><p><strong>线性探测方法</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/7/16825d390f52d29d?w=952&amp;h=539&amp;f=gif&amp;s=110979" alt="开放寻址法之线性探测方法"></p><p>当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p><p>以上图为例，散列表的大小为 8 ，黄色区域表示空闲位置，橙色区域表示已经存储了数据。目前散列表中已经存储了 4 个元素。此时元素 7777777  经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。</p><p>于是按顺序地往后一个一个找，看有没有空闲的位置，此时，运气很好正巧在下一个位置就有空闲位置，将其插入，完成了数据存储。</p><p>线性探测法一个很大的弊端就是当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，需要从头到尾探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。 </p><p><img src="https://user-gold-cdn.xitu.io/2019/1/7/16825d39107d1894?w=952&amp;h=539&amp;f=gif&amp;s=231211" alt="开放寻址法之线性探测方法的弊端"></p><p><strong>二次探测方法</strong></p><p>二次探测是二次方探测法的简称。顾名思义，使用二次探测进行探测的步长变成了原来的“二次方”，也就是说，它探测的下标序列为 <code>hash(key)+0</code>，<code>hash(key)+1^2</code>或<code>[hash(key)-1^2]</code>，<code>hash(key)+2^2</code>或<code>[hash(key)-2^2]</code>。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/7/16825d3910b39490?w=960&amp;h=536&amp;f=gif&amp;s=126340" alt="二次探测方法"></p><p>以上图为例，散列表的大小为 8 ，黄色区域表示空闲位置，橙色区域表示已经存储了数据。目前散列表中已经存储了 7 个元素。此时元素 7777777  经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。</p><p>按照<strong>二次探测方法</strong>的操作，有冲突就先 + 1^2，8 这个位置有值，冲突；变为 - 1^2，6 这个位置有值，还是有冲突；于是 - 2^2， 3 这个位置是空闲的，插入。</p><p><strong>双重散列方法</strong></p><p>所谓双重散列，意思就是不仅要使用一个散列函数，而是使用一组散列函数 <code>hash1(key)</code>，<code>hash2(key)</code>，<code>hash3(key)</code>。。。。。。先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/7/16825d393a80c3e7?w=960&amp;h=536&amp;f=gif&amp;s=130065" alt="双重散列方法"></p><p>以上图为例，散列表的大小为 8 ，黄色区域表示空闲位置，橙色区域表示已经存储了数据。目前散列表中已经存储了 7 个元素。此时元素 7777777  经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。</p><p>此时，再将数据进行一次哈希算法处理，经过另外的 Hash 算法之后，被散列到位置下标为 3 的位置，完成操作。</p><p>事实上，不管采用哪种探测方法，只要当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，需要尽可能保证散列表中有一定比例的空闲槽位。</p><p>一般使用<strong>加载因子</strong>（load factor）来表示空位的多少。</p><p><strong>加载因子</strong>是表示 Hsah 表中元素的填满的程度，若加载因子越大，则填满的元素越多,这样的好处是：空间利用率高了,但冲突的机会加大了。反之,加载因子越小,填满的元素越少,好处是冲突的机会减小了，但空间浪费多了。</p><h4 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h4><p>链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。如下动图所示，在散列表中，每个位置对应一条链表，所有散列值相同的元素都放到相同位置对应的链表中。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/7/16825d393a9cd43d?w=952&amp;h=539&amp;f=gif&amp;s=155331" alt="链表法"></p>]]></content>
      
      
      <categories>
          
          <category> 高级算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动画 </tag>
            
            <tag> 散列表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看动画理解「链表」实现LRU缓存淘汰算法</title>
      <link href="/posts/f5f29cad/"/>
      <url>/posts/f5f29cad/</url>
      
        <content type="html"><![CDATA[<p>前几节学习了「链表」、「时间与空间复杂度」的概念，本节将结合「循环链表」、「双向链表」与 「用空间换时间的设计思想」来设计一个很有意思的缓存淘汰策略：LRU缓存淘汰算法。</p><p><img src="http://upload-images.jianshu.io/upload_images/1940317-68c9e41fd4b0ef90?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三种最常见的链表结构"></p><h3 id="循环链表的概念"><a href="#循环链表的概念" class="headerlink" title="循环链表的概念"></a>循环链表的概念</h3><p>如上图所示：单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。</p><p>因此<strong>循环链表是一种特殊的单链表。</strong>它跟单链表唯一的区别就在于尾结点。它像一个环一样首尾相连，所以叫作「循环链表」。</p><h3 id="循环链表的特点"><a href="#循环链表的特点" class="headerlink" title="循环链表的特点"></a>循环链表的特点</h3><p>和单链表相比，循环链表的优点是从链尾到链头比较方便，当要处理的数据具有环型结构特点时，适合采用循环链表。</p><h3 id="双向链表概念"><a href="#双向链表概念" class="headerlink" title="双向链表概念"></a>双向链表概念</h3><p>双向链表也叫双链表，是链表的一种，它的链接方向是双向的，它的每个数据结点中都包含有两个指针，分别指向直接后继和直接前驱。</p><p>所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p><p>双向链表的数据结构中，会有两个比较重要的参数： <code>pre</code> 和 <code>next</code> 。</p><ul><li><code>pre</code> 指向前一个数据结构</li><li><code>next</code> 指向下一个数据结构</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1940317-259b92057bd8e0db?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单链表与双链表的对比"></p><h3 id="双向链表的特点"><a href="#双向链表的特点" class="headerlink" title="双向链表的特点"></a>双向链表的特点</h3><ul><li><p>与单链表对比，双链表需要多一个指针用于指向前驱节点，因此如果存储同样多的数据，双向链表要比单链表占用更多的内存空间</p></li><li><p>双链表的插入和删除需要同时维护 next 和 prev 两个指针。</p></li><li><p>双链表中的元素访问需要通过顺序访问，支持双向遍历，这就是双向链表操作的灵活性根本</p></li></ul><h3 id="双向链表的基本操作"><a href="#双向链表的基本操作" class="headerlink" title="双向链表的基本操作"></a>双向链表的基本操作</h3><h4 id="1-添加元素。"><a href="#1-添加元素。" class="headerlink" title="1.添加元素。"></a>1.添加元素。</h4><p>与单向链表相对比双向链表可以在 O(1) 时间复杂度搞定，而单向链表需要 O(n) 的时间复杂度。</p><p>双向链表的添加元素包括头插法和尾插法。<br><img src="http://upload-images.jianshu.io/upload_images/1940317-24711ed983f9482b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="头插法和尾插法"></p><p><strong>头插法：</strong>将链表的左边称为链表头部，右边称为链表尾部。头插法是将右边固定，每次新增的元素都在左边头部增加。</p><p><strong>尾插法：</strong>将链表的左边称为链表头部，右边称为链表尾部。尾插法是将左边固定，每次新增都在链表的右边最尾部。</p><h4 id="2-查询元素"><a href="#2-查询元素" class="headerlink" title="2.查询元素"></a>2.查询元素</h4><p><img src="http://upload-images.jianshu.io/upload_images/1940317-8a8215da4597d9ed?imageMogr2/auto-orient/strip" alt="查询元素"></p><p>双向链表的灵活处就是<strong>知道链表中的一个元素结构就可以向左或者向右开始遍历查找需要的元素结构</strong>。因此对于一个有序链表，双向链表的按值查询的效率比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</p><h4 id="3-删除元素"><a href="#3-删除元素" class="headerlink" title="3.删除元素"></a>3.删除元素</h4><p>在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：</p><ul><li><p>删除结点中“值等于某个给定值”的结点</p></li><li><p>删除给定指针指向的结点</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1940317-cc0552cc91316155?imageMogr2/auto-orient/strip" alt="删除元素"></p><p>对于双向链表来说，双向链表中的结点已经保存了前驱结点的指针，删除时不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度。</p><h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h3><p><img src="http://upload-images.jianshu.io/upload_images/1940317-8ccbb5571edeefae?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="双向循环链表"></p><p>如图所示，双向循环链表的概念很好理解：「双向链表」 + 「循环链表」的组合。</p><h3 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h3><p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。</p><p>缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。</p><p>在各个语言的第三方框架中都大量使用到了 LRU 缓存策略。程序员小吴接触到的有Java中的 「 Mybatis 」，iOS中的 「YYCache」与「Lottie」等。</p><h4 id="LRU缓存淘汰算法"><a href="#LRU缓存淘汰算法" class="headerlink" title="LRU缓存淘汰算法"></a>LRU缓存淘汰算法</h4><p>LRU是最近最少使用策略的缩写，是根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p><p><img src="http://upload-images.jianshu.io/upload_images/1940317-f9f489649bb5a632?imageMogr2/auto-orient/strip" alt="LRU概念"></p><h3 id="链表实现LRU"><a href="#链表实现LRU" class="headerlink" title="链表实现LRU"></a>链表实现LRU</h3><p>将Cache的所有位置都用双链表连接起来，当一个位置被命中之后，通过调整链表的指向，将该位置调整到链表头的位置，新加入的Cache直接加到链表头中。</p><p>这样，在多次进行Cache操作后，最近被命中的，就会被向链表头方向移动，而没有命中的，而想链表后面移动，链表尾则表示最近最少使用的Cache。</p><p>当需要替换内容时候，链表的最后位置就是最少被命中的位置，我们只需要淘汰链表最后的部分即可。</p><h3 id="链表实现LRU动画演示"><a href="#链表实现LRU动画演示" class="headerlink" title="链表实现LRU动画演示"></a>链表实现LRU动画演示</h3><ol><li>如果此数据之前已经被缓存在链表中了，通过遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li><li><p>如果此数据没有在缓存链表中，可以分为两种情况：</p><ul><li>如果此时缓存未满，则将此结点直接插入到链表的头部；</li><li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1940317-fd0d9116ed986c7a?imageMogr2/auto-orient/strip" alt="链表实现LRU"></p></li></ol><p>通过动图可以发现，如果缓存空间足够大，那么存储的数据也就足够多，通过缓存中命中数据的概率就越大，也就提高了代码的执行速度。这就是<strong>空间换时间的设计思想</strong>。</p><p>对于程序开发来说，时间复杂度和空间复杂度是可以相互转化的。说通俗一点，就是：</p><ul><li><p>对于执行的慢的程序，可以通过消耗内存（即构造新的数据结构）来进行优化；</p></li><li><p>而消耗内存的程序，可以通过消耗时间来降低内存的消耗。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 高级算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>准备下次编程面试前你应该知道的数据结构</title>
      <link href="/posts/27410/"/>
      <url>/posts/27410/</url>
      
        <content type="html"><![CDATA[<blockquote><p>国外 IT 教育学院 Educative.io 创始人 Fahim ul Haq 写过一篇过万赞的文章<a href="https://medium.freecodecamp.org/the-top-data-structures-you-should-know-for-your-next-coding-interview-36af0831f5e3" target="_blank" rel="noopener">《The top data structures you should know for your next coding interview》</a>,总结了<strong>程序员面试中需要掌握的 8 种数据结构知识</strong>。</p></blockquote><blockquote><p>Fahim ul Haq 曾在 Facebook 和微软任职，面试过不少程序员，所以这篇文章还是值得参考的。以下内容编译自他的这篇《准备下次编程面试前你应该知道的数据结构》：</p></blockquote><p>瑞典计算机科学家 Niklaus Wirth 在 1976 年写了一本书，叫作《Algorithms + Data Structures = Programs》（算法+数据结构=程序）。</p><p>即便在 40 年后的今天，这条等式仍然成立。这也是为何程序员求职者应该向面试官展示出已经透彻理解了数据结构知识。</p><p>几乎所有的面试问题都要求求职者表现出已经熟练掌握数据结构，不管你是刚毕业的应届生还是工作了多年的老手，都是这样。</p><p>有时，面试问题会明确提到数据结构，比如“给定一个二叉树”；有时则比较含蓄，比如“我们想追踪和每位作者相关的书籍数量。”</p><p>学习数据结构知识很有必要，哪怕你只是想找份比现在的工作更好的一份差事。我们首先了解数据结构的基本知识。</p><p><strong>什么是数据结构？</strong></p><p>简单说，数据结构就是一个容器，以某种特定的布局存储数据。这个“布局”使得数据结构在某些操作上非常高效，在另一些操作上则不那么高效。你的目标就是理解数据结构，这样就能为手头的问题选择最优的数据结构。</p><p><strong>为什么我们需要数据结构？</strong></p><p>由于数据结构用来以有组织的形式存储数据，而且数据是计算机科学中最重要的实体，因此数据结构的真正价值显而易见。</p><p>无论你解决什么问题，你都必须以这种或那种方式处理数据比如员工的工资，股票价格，购物清单，甚至简单的电话簿等等。</p><p>根据不同的场景，数据需要以特定格式存储。目前有一些数据结构可以满足我们以不同格式存储数据的需求。</p><p><strong>常用的数据结构</strong></p><p>我们首先列出最常用的数据结构，然后再挨个讲解：</p><ul><li>数组</li><li>堆栈</li><li>队列</li><li>链表</li><li>树</li><li>图</li><li>字典树</li><li>哈希表</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是一种最简单和最广泛使用的数据结构，其它数据结构比如堆栈和队列都源自数组。</p><p>下图是一个大小为 4 的简单数组，包含几个元素（  1  ,  2  ,  3，4）。</p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/16a096ac9282164c94c642f8e8d68961.png" alt=""></p><p>每个数据元素会被分配一个正的数值，叫作“索引”，它对应该元素在数组中的位置。大部分编程语言都将初始索引定义为 0.</p><p>以下是两种数组：</p><ul><li>一维数组（如上所示）</li><li>多维数组（数组的数组）</li></ul><p>数组的基本操作：</p><ul><li>Insert——在给定索引位置插入一个元素</li><li>Get——返回给定索引位置的元素</li><li>Delete——删除给定索引位置的元素</li><li>Size——获取数组内所有元素的总数</li></ul><p><strong>常问的数组面试问题</strong>：</p><ul><li>找到数组中第二小的元素</li><li>找到数组中第一个没有重复的整数</li><li>合并两个分类数组</li><li>重新排列数组中的正值和负值</li></ul><h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><p>我们都熟悉很有名的撤销（Undo）选项，它几乎存在每个应用程序中。有没有想过它是如何工作的？其思路就是，按照最后的状态排列在先的顺序将工作的先前状态（限于特定数字）存储在内存中。这只用数组是无法实现的，因此堆栈就有了用武之地。</p><p>可以把堆栈看作一堆垂直排列的书籍。为了获得位于中间位置的书，你需要拿掉放在它上面的所有书籍。这就是 LIFO（后进先出）方法的工作原理。</p><p>这是一个包含三个数据元素（1,2 和 3）的堆栈图像，其中3位于顶部，首先把它删除：</p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/8418f560a659ff24cb90ded2ca238b59.png" alt=""></p><p><strong>堆栈的基本操作</strong>：</p><ul><li>Push——在顶部插入元素</li><li>Pop—— 从堆栈中删除后返回顶部元素</li><li>isEmpty——如果堆栈为空，则返回 true</li><li>Top ——返回顶部元素，但不从堆栈中删除</li></ul><p><strong>常见的堆栈面试问题</strong>：</p><ul><li>使用堆栈计算后缀表达式</li><li>对堆栈中的值进行排序</li><li>检查表达式中的括号是否平衡</li></ul><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>与堆栈类似，队列是另一种线性数据结构，以顺序方式存储元素。堆栈和队列之间唯一的显着区别是，队列不是使用 LIFO 方法，而是应用 FIFO 方法，这是 First in First Out（先入先出）的缩写。</p><p>队列的完美现实例子：一列人在售票亭等候。如果有新人来，他们是从末尾加入队列，而不是在开头——站在前面的人将先买到票然后离开队列。</p><p>下图是一个包含四个数据元素（1,2,3 和 4）的队列，其中 1 位于顶部，首先把它删除：</p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/f70ab2adc32c9d5c7468401231f60c87.png" alt=""></p><p><strong>队列的基本操作</strong>：</p><ul><li>Enqueue() —— 向队列末尾插入元素</li><li>Dequeue() —— 从队列头部移除元素</li><li>isEmpty() —— 如果队列为空，则返回 true</li><li>Top() —— 返回队列的第一个元素</li></ul><p><strong>常问的队列面试问题</strong>：</p><ul><li>使用队列来实现堆栈</li><li>颠倒队列中前 k 个元素的顺序</li><li>使用队列生成从 1 到 n 的二进制数</li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是另一个重要的线性数据结构，刚一看可能看起来像数组，但在内存分配，内部结构以及如何执行插入和删除的基本操作方面有所不同。</p><p>链表就像一个节点链，其中每个节点包含数据和指向链中后续节点的指针等信息。有一个头指针，指向链表的第一个元素，如果列表是空的，那么它只指向 null 或不指向任何内容。</p><p>链表用于实现文件系统，哈希表和邻接表。下图是链表内部结构的直观展示：<br><img src="https://diycode.b0.upaiyun.com/photo/2019/c9d4e6282fe39203b7743e22b3781db5.png" alt=""></p><p><strong>下面是几种类型的链表</strong>：</p><ul><li>单链表（单向）</li><li>双链表（双向）</li></ul><p><strong>链表的基本操作</strong>：</p><ul><li>InsertAtEnd —— 在链表末尾插入指定元素</li><li>InsertAtHead —— 在链表头部插入指定元素</li><li>Delete —— 从链表中删除指定元素</li><li>DeleteAtHead —— 删除链表的第一个元素</li><li>Search —— 返回链表中的指定元素</li><li>isEmpty —— 如果链表为空，返回 true</li></ul><p><strong>常问的链表面试问题</strong>：</p><ul><li>翻转列表</li><li>检测链表中的循环</li><li>返回链表中倒数第 n 个节点</li><li>移除链表中的重复值</li></ul><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>图就是一组节点，以网络的形式互相连接。节点也被称为顶点（vertices）。一对（x,y）就叫做一个边，表示顶点 x 和顶点 y 相连。一个边可能包含权重/成本，显示从顶点 x 到 y 所需的成本。</p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/6bb75406664d92441a25b97125a59379.png" alt=""></p><p><strong>图的类型</strong>：</p><ul><li>无向图</li><li>有向图</li></ul><p>在编程语言中，图可以表示为两种形式：</p><ul><li>邻接矩阵</li><li>邻接列表</li></ul><p>常见的图遍历算法：</p><ul><li>广度优先搜索</li><li>深度优先搜索</li></ul><p>常问的图面试问题：</p><ul><li>实现广度优先搜索和深度优先搜索</li><li>检查一个图是否为树</li><li>计算一张图中的边的数量</li><li>找到两个顶点之间的最短路径</li></ul><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树是一种层级数据结构，包含了连接它们的顶点（节点）和边。树和图很相似，但二者有个很大的不同点，即树中没有循环。</p><p>树广泛应用在人工智能和复杂的算法中，为解决各种问题提供高效的存储机制。</p><p>下图是一个简单的树，以及在树型数据结构中所用的基本术语：<br><img src="https://diycode.b0.upaiyun.com/photo/2019/c96436682691e8e6df6636b6ec47510a.png" alt=""></p><p>下面是几种类型的树：</p><ul><li>N 叉树</li><li>平衡树</li><li>二叉树</li><li>二叉搜索树</li><li>平衡二叉树</li><li>红黑树</li><li>2-3 树</li></ul><p>其中，二叉树和二叉搜索树是最常用的树。</p><p><strong>常问的树面试问题</strong>：</p><ul><li>找到一个二叉树的高度</li><li>找到一个二叉搜索树中第 k 个最大值</li><li>找到距离根部“k”个距离的节点</li><li>找到一个二叉树中给定节点的祖先（ancestors）</li></ul><h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><p>字典树，也叫“前缀树”，是一种树形结构，在解决字符串相关问题中非常高效。其提供非常快速的检索功能，常用于搜索字典中的单词，为搜索引擎提供自动搜索建议，甚至能用于IP路由选择。<br>下面展示了“top”“thus”和“their”这三个词是如何存储在字典树中的：</p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/ad4396ac395523f511669768cedb52cd.png" alt=""></p><p>这些单词以从上到下的方式存储，其中绿色节点“p”，“s”和“r”分别表示“top”，“thus”和“their”的末尾。</p><p><strong>常见的字典树面试问题</strong>：</p><ul><li>计算字典树中的总字数</li><li>打印存储在字典树中的所有单词</li><li>使用字典树对数组的元素进行排序</li><li>使用字典树从字典中形成单词</li><li>构建一个T9字典</li></ul><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>#### </p><p>散列是一个用于唯一标识对象并在一些预先计算的唯一索引（称为“密钥”）存储每个对象的过程。因此，对象以“键值”对的形式存储，这些项的集合被称为“字典”。可以使用该键值搜索每个对象。有多种不同的基于哈希的数据结构，但最常用的数据结构是哈希表。</p><p>哈希表通常使用数组实现。</p><p>哈希数据结构的性能取决于以下三个因素：</p><ul><li>哈希函数</li><li>哈希表的大小</li><li>碰撞处理方法</li></ul><p>下图展示了如何在数组中映射哈希。该数组的索引是通过哈希函数计算的。</p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/3d952413d8deb2bb715420c4848c1571.png" alt=""></p><p><strong>常问的哈希面试问题</strong>：</p><ul><li>找到数组中的对称对</li><li>追踪遍历的完整路径</li><li>查看一个数组是否为另一个数组的子集</li><li>检查给定数组是否不相交</li></ul><p>以上就是你在准备编程面试前需要掌握的8种数据结构。</p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第167号问题：Two Sum II</title>
      <link href="/posts/f772505c/"/>
      <url>/posts/f772505c/</url>
      
        <content type="html"><![CDATA[<p>leetcode上第167号问题：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">Two Sum II</a></p><blockquote><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p></blockquote><blockquote><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p></blockquote><blockquote><p>说明:</p></blockquote><blockquote><ul><li>返回的下标值（index1 和 index2）不是从零开始的。</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ul></blockquote><blockquote><p>示例:</p></blockquote><blockquote><p>输入: numbers = [2, 7, 11, 15], target = 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>初始化左指针left指向数组起始，初始化右指针right指向数组结尾。</p><p>根据<strong>已排序</strong>这个特性，</p><ul><li><p>（1）如果numbers[left]与numbers[right]的和tmp小于target，说明应该增加tmp,因此left右移指向一个较大的值。</p></li><li><p>（2）如果tmp大于target，说明应该减小tmp,因此right左移指向一个较小的值。</p></li><li><p>（3）tmp等于target，则找到，返回left+1和right+1。（注意以1为起始下标）</p></li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzl02exvalg30np0cpjsz.gif" alt="Two sum"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 对撞指针// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {        int l = 0, r = numbers.size() - 1;        while(l &lt; r){            if(numbers[l] + numbers[r] == target){                int res[2] = {l+1, r+1};                return vector&lt;int&gt;(res, res+2);            }            else if(numbers[l] + numbers[r] &lt; target)                l ++;            else // numbers[l] + numbers[r] &gt; target                r --;        }    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第75号问题：Sort Colors</title>
      <link href="/posts/fe46b16f/"/>
      <url>/posts/fe46b16f/</url>
      
        <content type="html"><![CDATA[<p>leetcode上第75号问题：<a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">Sort Colors</a></p><blockquote><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p></blockquote><blockquote><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p></blockquote><blockquote><p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p></blockquote><blockquote><p>示例:</p></blockquote><blockquote><p>输入: [2,0,2,1,1,0]</p></blockquote><blockquote><p>输出: [0,0,1,1,2,2]</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>结合三路快排partition思路的应用，设定两个索引，一个从左往右滑动<code>zero</code>，一个从右往左滑动<code>two</code>，遍历<code>nums</code>，当<code>nums[i]</code>的值为1时，<code>i++</code>；当<code>nums[i]</code>的值为2时，<code>two</code>的值先减1，而后交换<code>nums[i]</code>与<code>nums[two]</code>，此时在观察<code>nums[i]</code>的值；当<code>nums[i]</code>的值为0时，<code>zero++</code>，而后交换<code>nums[i]</code>与<code>nums[zero]</code>，<code>i++</code>;当 <code>i = two</code>时，结束循环。</p><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzl014a9kug30np0cp42x.gif" alt="Sort Colors"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 三路快速排序的思想// 对整个数组只遍历了一遍// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    void sortColors(vector&lt;int&gt; &amp;nums) {        int zero = -1;          // [0...zero] == 0        int two = nums.size();  // [two...n-1] == 2        for(int i = 0 ; i &lt; two ; ){            if(nums[i] == 1){                 i ++;            }else if (nums[i] == 2){                 two--;                 swap( nums[i] , nums[two]);            }else{ // nums[i] == 0                 zero++;                 swap(nums[zero] , nums[i]);                 i++;            }        }    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分治 </tag>
            
            <tag> 快速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第20 号问题：有效的括号</title>
      <link href="/posts/37d84b80/"/>
      <url>/posts/37d84b80/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第20 号问题：<strong><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">有效的括号</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p></blockquote><blockquote><p>有效字符串需满足：</p></blockquote><blockquote><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。    </p></blockquote><blockquote><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4></blockquote><blockquote><p>输入: “()”<br>输出: true</p></blockquote><blockquote><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4></blockquote><blockquote><p>输入: “()[]{}”<br>输出: true</p></blockquote><blockquote><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a>示例 3:</h4></blockquote><blockquote><p>输入: “(]”<br>输出: false</p></blockquote><blockquote><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4:"></a>示例 4:</h4></blockquote><blockquote><p>输入: “([)]”<br>输出: false   </p></blockquote><blockquote><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5:"></a>示例 5:</h4></blockquote><blockquote><p>输入: “{[]}”<br>输出: true   </p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题让我们验证输入的字符串是否为括号字符串，包括大括号，中括号和小括号。</p><p>这里我们使用<strong>栈</strong>。</p><ul><li>遍历输入字符串</li><li>如果当前字符为左半边括号时，则将其压入栈中</li><li>如果遇到右半边括号时，<strong>分类讨论：</strong></li><li>1）如栈不为空且为对应的左半边括号，则取出栈顶元素，继续循环  </li><li>2）若此时栈为空，则直接返回false</li><li>3）若不为对应的左半边括号，反之返回false</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzzpkrjng30qo0f0n2n.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkzzqlgmij30u014awmf.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 1 号问题：Two Sum</title>
      <link href="/posts/fc90665e/"/>
      <url>/posts/fc90665e/</url>
      
        <content type="html"><![CDATA[<p>leetcode上第1号问题：<a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">Two Sum</a></p><blockquote><p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p></blockquote><blockquote><p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p></blockquote><blockquote><p>示例:</p></blockquote><blockquote><p>给定 nums = [2, 7, 11, 15], target = 9</p></blockquote><blockquote><p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用查找表来解决该问题。</p><blockquote><p>设置一个map容器record用来记录元素的值与索引</p><p>遍历数组nums</p><ul><li>每次遍历时使用临时变量complement用来保存目标值与当前值的差值</li><li>在此次遍历中查找record，查看是否有与complement一致的值，如果查找成功则返回查找值的索引值与当前变量的值i</li><li>如果未找到，则在record保存该元素与索引值i</li></ul></blockquote><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkzyntxibg30nn0dd458.gif" alt="Two Sum"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 1. Two Sum// https://leetcode.com/problems/two-sum/description/// 时间复杂度：O(n)// 空间复杂度：O(n)class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        unordered_map&lt;int,int&gt; record;        for(int i = 0 ; i &lt; nums.size() ; i ++){            int complement = target - nums[i];            if(record.find(complement) != record.end()){                int res[] = {i, record[complement]};                return vector&lt;int&gt;(res, res + 2);            }            record[nums[i]] = i;        }    }};</code></pre><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkzymcdnzj31nx0u0q5l.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查找表 </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第24号问题：Swap Nodes in Pairs</title>
      <link href="/posts/4988/"/>
      <url>/posts/4988/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第24号问题：<strong><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">Swap Nodes in Pairs</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p></blockquote><blockquote><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4></blockquote><blockquote><p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. </p><h4 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h4></blockquote><blockquote><ul><li>你的算法只能使用常数的额外空间。    </li><li>你<strong>不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</li></ul></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>该题属于基本的链表操作题。</p><ul><li>设置一个虚拟头结点<code>dummyHead</code></li><li>设置需要交换的两个节点分别为<code>node1</code>、<code>node2</code>，同时设置<code>node2</code>的下一个节点<code>next</code></li></ul><h5 id="在这一轮操作中"><a href="#在这一轮操作中" class="headerlink" title="在这一轮操作中"></a>在这一轮操作中</h5><ul><li>将<code>node2</code>节点的next设置为<code>node1</code>节点</li><li>将<code>node1</code>节点的next设置为<code>next</code>节点</li><li>将<code>dummyHead</code>节点的next设置为<code>node2</code></li><li>结束本轮操作</li></ul><p>接下来的每轮操作都按照上述进行。</p><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkzyet4u8g30qk0evqbw.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><pre><code>// 24. Swap Nodes in Pairs// https://leetcode.com/problems/swap-nodes-in-pairs/description/// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    ListNode* swapPairs(ListNode* head) {        ListNode* dummyHead = new ListNode(0);        dummyHead-&gt;next = head;        ListNode* p = dummyHead;        while(p-&gt;next &amp;&amp; p-&gt;next-&gt;next){            ListNode* node1 = p-&gt;next;            ListNode* node2 = node1-&gt;next;            ListNode* next = node2-&gt;next;            node2-&gt;next = node1;            node1-&gt;next = next;            p-&gt;next = node2;            p = node1;        }        ListNode* retHead = dummyHead-&gt;next;        delete dummyHead;        return retHead;    }};</code></pre><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkzyg6vkrj31ss0u0die.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 节点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第344号问题：Reverse String</title>
      <link href="/posts/cb301f5a/"/>
      <url>/posts/cb301f5a/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzwvxg08j311i0hot9w.jpg" alt=""></p><p>LeetCode上第344号问题：<strong><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">Reverse String</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>编写一个函数，其作用是将输入的字符串反转过来。</p></blockquote><blockquote><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h5></blockquote><blockquote><p>输入: “hello”<br>输出: “olleh”   </p></blockquote><blockquote><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h5></blockquote><blockquote><p>输入: “A man, a plan, a canal: Panama”<br>输出: “amanaP :lanac a ,nalp a ,nam A”</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接从两头往中间走，同时交换两边的字符即可</p><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkzwxdigqg30qm0ep0xp.gif" alt="动画演示"></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><h4 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h4><pre><code>// 344. Reverse String// https://leetcode.com/problems/reverse-string/description/// Two Pointers// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    string reverseString(string s) {        int i = 0, j = s.size() - 1;        while(i &lt; j){            swap(s[i], s[j]);            i ++;            j --;        }        return s;    }};</code></pre><h4 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h4><pre><code>// 344. Reverse String// https://leetcode.com/problems/reverse-string/description/// Two Pointers// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    string reverseString(string s) {         int left = 0, right = s.size() - 1;        while (left &lt; right) {           char t = s[left];            s[left++] = s[right];           s[right--] = t;        }       return s;   }};</code></pre><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzwzp763j313u0h6mxq.jpg" alt="执行结果"></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 反转 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第206号问题：Reverse Linked List</title>
      <link href="/posts/10709e63/"/>
      <url>/posts/10709e63/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzvypae1j311m0g6gms.jpg" alt=""></p><p>LeetCode上第206号问题：<strong><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">Reverse Linked List</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>反转一个单链表。</p></blockquote><blockquote><h5 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h5></blockquote><blockquote><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><h5 id="进阶"><a href="#进阶" class="headerlink" title="进阶:"></a>进阶:</h5><p>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>设置三个节点<code>pre</code>、<code>cur</code>、<code>next</code></p><ul><li>（1）每次查看<code>cur</code>节点是否为<code>NULL</code>，如果是，则结束循环，获得结果</li><li>（2）如果<code>cur</code>节点不是为<code>NULL</code>，则先设置临时变量<code>next</code>为<code>cur</code>的下一个节点</li><li>（3）让<code>cur</code>的下一个节点变成指向<code>pre</code>，而后<code>pre</code>移动<code>cur</code>，<code>cur</code>移动到<code>next</code></li><li>（4）重复（1）（2）（3）</li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzw15rnng30nj0d9wqe.gif" alt="动画演示"></p><h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><h5 id="迭代的方式处理"><a href="#迭代的方式处理" class="headerlink" title="迭代的方式处理"></a>迭代的方式处理</h5><pre><code>// 206. Reverse Linked List// https://leetcode.com/problems/reverse-linked-list/description/// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    ListNode* reverseList(ListNode* head) {        ListNode* pre = NULL;        ListNode* cur = head;        while(cur != NULL){            ListNode* next = cur-&gt;next;            cur-&gt;next = pre;            pre = cur;            cur = next;        }        return pre;    }};</code></pre><h5 id="递归的方式处理"><a href="#递归的方式处理" class="headerlink" title="递归的方式处理"></a>递归的方式处理</h5><pre><code>// 206. Reverse Linked List// https://leetcode.com/problems/reverse-linked-list/description///// 递归的方式反转链表// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    ListNode* reverseList(ListNode* head) {        // 递归终止条件        if(head == NULL || head-&gt;next == NULL)            return head;        ListNode* rhead = reverseList(head-&gt;next);        // head-&gt;next此刻指向head后面的链表的尾节点        // head-&gt;next-&gt;next = head把head节点放在了尾部        head-&gt;next-&gt;next = head;        head-&gt;next = NULL;        return rhead;    }};</code></pre><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzw3k5wkj31sn0u0gnx.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 反转 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第92号问题：Reverse Linked List II</title>
      <link href="/posts/970ebf8d/"/>
      <url>/posts/970ebf8d/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第92号问题：<strong><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">Reverse Linked List II</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p></blockquote><blockquote><h5 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h5><p>1 ≤ m ≤ n ≤ 链表长度。</p></blockquote><blockquote><h5 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h5></blockquote><blockquote><p><strong>输入</strong>: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4.<br><strong>输出</strong>: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong><a href="https://xiaozhuanlan.com/topic/7513064892" target="_blank" rel="noopener">Reverse Linked List</a></strong>的延伸题。</p><p>可以考虑取出需要反转的这一小段链表，反转完后再插入到原先的链表中。</p><p><strong>以本题为例：</strong></p><p>变换的是2,3,4这三个点，那么我们可以先取出2，用front指针指向2，然后当取出3的时候，我们把3加到2的前面，把front指针前移到3，依次类推，到4后停止，这样我们得到一个新链表4-&gt;3-&gt;2, front指针指向4。</p><p>对于原链表来说，<strong>有两个点的位置很重要</strong>，需要用指针记录下来，分别是1和5，把新链表插入的时候需要这两个点的位置。</p><ul><li>用pre指针记录1的位置</li><li>当4结点被取走后，5的位置需要记下来</li><li>这样我们就可以把倒置后的那一小段链表加入到原链表中</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzvp0nnyg30qk0ev4bt.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzvpvd7xj30vw0u0q82.jpg" alt=""></p><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkzvrexmqj31ss0u00vf.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第19号问题：Remove Nth Node From End of List</title>
      <link href="/posts/160c6ff6/"/>
      <url>/posts/160c6ff6/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第19号问题：<strong><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">Remove Nth Node From End of List</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p></blockquote><blockquote><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4></blockquote><blockquote><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</p></blockquote><blockquote><p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5</p><h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4></blockquote><blockquote><p>给定的 n 保证是有效的。</p></blockquote><blockquote><h4 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h4></blockquote><blockquote><p>你能尝试使用一趟扫描实现吗？</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>采取双重遍历肯定是可以解决问题的，但题目要求我们一次遍历解决问题，那我们的思路得发散一下。</p><p>我们可以设想假设设定了双指针<code>p</code>和<code>q</code>的话，当<code>q</code>指向末尾的<code>NULL</code>，<code>p</code>与<code>q</code>之间相隔的元素个数为<code>n</code>时，那么删除掉<code>p</code>的下一个指针就完成了要求。</p><ul><li>设置虚拟节点<code>dummyHead</code>指向<code>head</code></li><li>设定双指针<code>p</code>和<code>q</code>，初始都指向虚拟节点<code>dummyHead</code></li><li>移动<code>q</code>，直到<code>p</code>与<code>q</code>之间相隔的元素个数为<code>n</code></li><li>同时移动<code>p</code>与<code>q</code>，直到<code>q</code>指向的为<code>NULL</code></li><li>将<code>p</code>的下一个节点指向下下个节点</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkzv25jlbg30qn0ezajr.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkzv3cllbj30u012d760.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第203号问题：Remove Linked List Elements</title>
      <link href="/posts/5c7d04c/"/>
      <url>/posts/5c7d04c/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzs7u2a6j31iu0mutbi.jpg" alt=""></p><p>LeetCode上第203号问题：<strong><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">Remove Linked List Elements</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>删除链表中等于给定值 val 的所有节点。</p></blockquote><blockquote><h5 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h5></blockquote><blockquote><p>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6<br>输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>主要考察了基本的链表遍历和设置指针的知识点。</p><p>定义一个虚拟头节点<code>dummyHead</code>，遍历查看原链表，遇到与给定值相同的元素，将该元素的前后两个节点连接起来，然后删除该元素即可。</p><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzs3cu9jg30qo0f0107.gif" alt="动画演示"></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><h4 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h4><pre><code>// 203. Remove Linked List Elements// https://leetcode.com/problems/remove-linked-list-elements/description/// 使用虚拟头结点// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    ListNode* removeElements(ListNode* head, int val) {        // 创建虚拟头结点        ListNode* dummyHead = new ListNode(0);        dummyHead-&gt;next = head;        ListNode* cur = dummyHead;        while(cur-&gt;next != NULL){            if(cur-&gt;next-&gt;val == val){                ListNode* delNode = cur-&gt;next;                cur-&gt;next = delNode-&gt;next;                delete delNode;            }            else                cur = cur-&gt;next;        }        ListNode* retNode = dummyHead-&gt;next;        delete dummyHead;        return retNode;    }};</code></pre><h4 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h4><p>用递归来解。</p><p>通过递归调用到链表末尾，然后回来，需要删的元素，将链表next指针指向下一个元素即可。</p><pre><code>class Solution {public:    ListNode* removeElements(ListNode* head, int val) {        if (!head) return NULL;        head-&gt;next = removeElements(head-&gt;next, val);        return head-&gt;val == val ? head-&gt;next : head;    }};</code></pre><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkzs66gunj31ri0u0773.jpg" alt="执行结果"></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第86号问题：Partition List</title>
      <link href="/posts/8dd6b93/"/>
      <url>/posts/8dd6b93/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第86号问题：<strong><a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener">Partition List</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p></blockquote><blockquote><p>你应当保留两个分区中每个节点的初始相对位置。</p></blockquote><blockquote><h5 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h5></blockquote><blockquote><p>输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题要求我们划分链表，把所有小于给定值的节点都移到前面，大于该值的节点顺序不变，相当于一个局部排序的问题。</p><ul><li>设定两个虚拟节点，<code>dummyHead1</code>用来保存小于于该值的链表，<code>dummyHead2</code>来保存大于等于该值的链表</li><li>遍历整个原始链表，将小于该值的放于<code>dummyHead1</code>中，其余的放置在<code>dummyHead2</code>中</li><li>遍历结束后，将<code>dummyHead2</code>插入到<code>dummyHead1</code>后面</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181104095701.gif" alt="动画演示"></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181106090835.png" alt=""></p><h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p>我们会在公众号（<strong>菠了个菜</strong>）每天早上8点30分准时推送一条LeetCode上的算法题目，并给出该题目的动画解析以及参考答案，每篇文章阅读时长为五分钟左右。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分治 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 328 号问题：Odd Even Linked List</title>
      <link href="/posts/770f47b8/"/>
      <url>/posts/770f47b8/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第328号问题：<strong><a href="https://leetcode-cn.com/problems/odd-even-linked-list/" target="_blank" rel="noopener">Odd Even Linked List</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p></blockquote><blockquote><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p></blockquote><blockquote><p><strong>示例 1:</strong></p></blockquote><blockquote><p><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br><strong>输出:</strong> 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</p><p><strong>示例 2:</strong></p></blockquote><blockquote><p><strong>输入:</strong> 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL<br><strong>输出:</strong> 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</p><p><strong>说明:</strong></p></blockquote><blockquote><ul><li>应当保持奇数节点和偶数节点的相对顺序。</li><li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li></ul></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题给了我们一个链表，让我们分开奇偶节点，所有奇节点在前，偶节点在后。</p><ul><li>设定两个虚拟节点，<code>dummyHead1</code>用来保存奇节点，<code>dummyHead2</code>来保存偶节点；</li><li>遍历整个原始链表，将奇节点放于<code>dummyHead1</code>中，其余的放置在<code>dummyHead2</code>中</li><li>遍历结束后，将<code>dummyHead2</code>插入到<code>dummyHead1</code>后面</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzqr3h93g30qk0ewwo3.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzqncct3j30u00ygwmm.jpg" alt=""></p><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkzqplqhmj31sl0u0mzs.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 节点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 3 号问题：Longest Substring Without Repeating Characters</title>
      <link href="/posts/50715/"/>
      <url>/posts/50715/</url>
      
        <content type="html"><![CDATA[<p>leetcode上第3号问题：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">Longest Substring Without Repeating Characters</a></p><blockquote><p>给定一个字符串，找出不含有重复字符的最长子串的长度。</p></blockquote><blockquote><p>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 无重复字符的最长子串是 “abc”，其长度为 3。</p></blockquote><blockquote><p>示例 2:<br>输入: “bbbbb”<br>输出: 1.<br>解释: 无重复字符的最长子串是 “b”，其长度为 1。   </p></blockquote><blockquote><p>示例 3:<br>输入: “pwwkew”<br>输出: 3<br>解释: 无重复字符的最长子串是 “wke”，其长度为 3。<br>请注意，答案必须是一个子串，”pwke” 是一个子序列 而不是子串。</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>建立一个256位大小的整型数组freg，用来建立字符和其出现位置之间的映射。</p><p>维护一个滑动窗口，窗口内的都是没有重复的字符，去尽可能的扩大窗口的大小，窗口不停的向右滑动。</p><ul><li>（1）如果当前遍历到的字符从未出现过，那么直接扩大右边界；</li><li>（2）如果当前遍历到的字符出现过，则缩小窗口（左边索引向右移动），然后继续观察当前遍历到的字符；</li><li>（3）重复（1）（2），直到左边索引无法再移动；</li><li>（4）维护一个结果res，每次用出现过的窗口大小来更新结果res，最后返回res获取结果。</li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzpqfp11g30no0dbjvw.gif" alt="Longest"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 3. Longest Substring Without Repeating Characters// https://leetcode.com/problems/longest-substring-without-repeating-characters/description///// 滑动窗口// 时间复杂度: O(len(s))// 空间复杂度: O(len(charset))class Solution {public:    int lengthOfLongestSubstring(string s) {        int freq[256] = {0};        int l = 0, r = -1; //滑动窗口为s[l...r]        int res = 0;        // 整个循环从 l == 0; r == -1 这个空窗口开始        // 到l == s.size(); r == s.size()-1 这个空窗口截止        // 在每次循环里逐渐改变窗口, 维护freq, 并记录当前窗口中是否找到了一个新的最优值        while(l &lt; s.size()){            if(r + 1 &lt; s.size() &amp;&amp; freq[s[r+1]] == 0){                r++;                freq[s[r]]++;            }else {   //r已经到头 || freq[s[r+1]] == 1                freq[s[l]]--;                l++;            }            res = max(res, r-l+1);        }        return res;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第  349 号问题：Intersection of Two Arrays</title>
      <link href="/posts/6b380d52/"/>
      <url>/posts/6b380d52/</url>
      
        <content type="html"><![CDATA[<p>leetcode上第 349 号问题：<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">Intersection of Two Arrays</a></p><blockquote><p>给定两个数组，编写一个函数来计算它们的交集。</p></blockquote><blockquote><p>示例 1:<br>输入: nums1 = [1,2,2,1], nums2 = [2,2]<br>输出: [2]  </p><p>示例 2:<br>输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>输出: [9,4]</p><p>说明:  </p><ul><li>输出结果中的每个元素一定是唯一的。   </li><li>我们可以不考虑输出结果的顺序。</li></ul></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>容器类<a href="https://zh.cppreference.com/w/cpp/container/set" target="_blank" rel="noopener">set</a>的使用。</p><ul><li>遍历num1，通过set容器record存储num1的元素</li><li>遍历num2，在record中查找是否有相同的元素，如果有，用set容器resultSet进行存储</li><li>将resultSet转换为vector类型</li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzoct4m6g30nk0dbq67.gif" alt="Intersection of Two Arrays"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 349. Intersection of Two Arrays// https://leetcode.com/problems/intersection-of-two-arrays/description/// 时间复杂度: O(nlogn)// 空间复杂度: O(n)class Solution {public:    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        set&lt;int&gt; record;        for( int i = 0 ; i &lt; nums1.size() ; i ++ ){            record.insert(nums1[i]);        }        set&lt;int&gt; resultSet;        for( int i = 0 ; i &lt; nums2.size() ; i ++ ){            if(record.find(nums2[i]) != record.end()){                resultSet.insert(nums2[i]);            }        }        vector&lt;int&gt; resultVector;        for(set&lt;int&gt;::iterator iter = resultSet.begin(); iter != resultSet.end(); iter ++ ){            resultVector.push_back(*iter);        }        return resultVector;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> set </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 350 号问题：Intersection of Two Arrays II</title>
      <link href="/posts/52620/"/>
      <url>/posts/52620/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzmzoiovj31nk0lq76o.jpg" alt=""></p><p>leetcode上第350号问题：<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">Intersection of Two Arrays II</a></p><blockquote><p>给定两个数组，编写一个函数来计算它们的交集。</p></blockquote><blockquote><p>示例 1:<br>输入: nums1 = [1,2,2,1], nums2 = [2,2]<br>输出: [2,2]</p><p>示例 2:<br>输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>输出: [4,9]</p></blockquote><blockquote><p>说明：</p></blockquote><blockquote><ul><li>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。</li><li>我们可以不考虑输出结果的顺序。</li></ul></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>容器类<a href="https://zh.cppreference.com/w/cpp/container/map" target="_blank" rel="noopener">map</a>的使用。</p><ul><li>遍历num1，通过map容器record存储num1的元素与频率</li><li>遍历num2，在record中查找是否有相同的元素（该元素的存储频率大于0），如果有，用map容器resultVector进行存储，同时该元素的频率减一</li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzmwhgg2g30mi0cqac4.gif" alt=""></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 350. Intersection of Two Arrays II// https://leetcode.com/problems/intersection-of-two-arrays-ii/description/// 时间复杂度: O(nlogn)// 空间复杂度: O(n)class Solution {public:    vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        map&lt;int, int&gt; record;        for(int i = 0 ; i &lt; nums1.size() ; i ++){             record[nums1[i]] += 1;        }        vector&lt;int&gt; resultVector;        for(int i = 0 ; i &lt; nums2.size() ; i ++){            if(record[nums2[i]] &gt; 0){                resultVector.push_back(nums2[i]);                record[nums2[i]] --;            }        }        return resultVector;    }};</code></pre><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzmwek5eg30mi0cqac4.gif" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 150 号问题：逆波兰表达式求值</title>
      <link href="/posts/dfbd1df8/"/>
      <url>/posts/dfbd1df8/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第150号问题：<strong><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">逆波兰表达式求值</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>根据逆波兰表示法，求表达式的值。</p></blockquote><blockquote><p>有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p></blockquote><blockquote><h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5></blockquote><blockquote><p>整数除法只保留整数部分。<br>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。   </p><h5 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h5></blockquote><blockquote><p>输入: [“2”, “1”, “+”, “3”, “<em>“]<br>输出: 9<br>解释: ((2 + 1) </em> 3) = 9   </p><h5 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h5></blockquote><blockquote><p>输入: [“4”, “13”, “5”, “/“, “+”]<br>输出: 6<br>解释: (4 + (13 / 5)) = 6   </p><h5 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h5></blockquote><blockquote><p>输入: [“10”, “6”, “9”, “3”, “+”, “-11”, “<em>“, “/“, “</em>“, “17”, “+”, “5”, “+”]<br>输出: 22<br>解释:<br>  ((10 <em> (6 / ((9 + 3) </em> -11))) + 17) + 5<br>= ((10 <em> (6 / (12 </em> -11))) + 17) + 5<br>= ((10 <em> (6 / -132)) + 17) + 5<br>= ((10 </em> 0) + 17) + 5<br>= (0 + 17) + 5<br>= 17 + 5<br>= 22   </p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用数据结构<code>栈</code>来解决这个问题。</p><ul><li>从前往后遍历数组</li><li>遇到数字则压入栈中</li><li>遇到符号，则把栈顶的两个数字拿出来运算，把结果再压入栈中</li><li>遍历完整个数组，栈顶数字即为最终答案</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong><br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzntpqf2g30qx0f4485.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkznqdhk8j30u00wedha.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 237 号问题：Delete Node in a Linked List</title>
      <link href="/posts/497f8fc8/"/>
      <url>/posts/497f8fc8/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第237号问题：<strong><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">Delete Node in a Linked List</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p></blockquote><blockquote><p>现有一个链表 – head = [4,5,1,9]，它可以表示为:</p></blockquote><blockquote><pre><code>4 -&gt; 5 -&gt; 1 -&gt; 9##### 示例 1:</code></pre></blockquote><blockquote><p><strong>输入:</strong> head = [4,5,1,9], node = 5<br><strong>输出:</strong> [4,1,9]<br><strong>解释:</strong> 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt;  9.</p><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h5></blockquote><blockquote><p><strong>输入:</strong> head = [4,5,1,9], node = 1<br><strong>输出:</strong> [4,5,9]<br><strong>解释:</strong> 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.     </p><h5 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h5></blockquote><blockquote><ul><li>链表至少包含两个节点。    </li><li>链表中所有节点的值都是唯一的。     </li><li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。     </li><li>不要从你的函数中返回任何结果。          </li></ul></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>此题注意的点是没有给我们链表的起点，只给我们了一个要删的节点，与以往处理的情况稍许不同。</p><p><strong>这道题的处理方法是先把当前节点的值用下一个节点的值覆盖，然后我们删除下一个节点即可</strong></p><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181105171450.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181105171512.png" alt=""></p><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181105171613.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 219号问题：Contains Duplicate II</title>
      <link href="/posts/15122/"/>
      <url>/posts/15122/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzkn0d3cj316e0jywgm.jpg" alt="Contains Duplicate II"></p><p>leetcode上第219号问题：<a href="https://leetcode.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">Contains Duplicate II</a></p><blockquote><p>给出⼀个整形数组nums和⼀个整数k，是否存在索引i和j，使得nums[i] == nums[j] 且i和j之间的差不超过k</p><p>Example 1:<br>Input: nums = [1,2,3,1], k = 3<br>Output: true. </p><p>Example 2:<br>Input: nums = [1,0,1,1], k = 1<br>Output: true  </p><p>Example 3:<br>Input: nums = [1,2,3,1,2,3], k = 2<br>Output: false</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>考虑用滑动窗口与查找表来解决。</p><ul><li>设置查找表<code>record</code>，用来保存每次遍历时插入的元素，<code>record</code>的最大长度为<code>k</code></li><li>遍历数组<code>nums</code>，每次遍历的时候在<code>record</code>查找是否存在相同的元素，如果存在则返回<code>true</code>，遍历结束</li><li>如果此次遍历在<code>record</code>未查找到，则将该元素插入到<code>record</code>中，而后查看<code>record</code>的长度是否为<code>k + 1</code></li><li>如果此时<code>record</code>的长度是否为<code>k + 1</code>，则删减<code>record</code>的元素，该元素的值为<code>nums[i - k]</code></li><li>如果遍历完整个数组<code>nums</code>未查找到则返回<code>false</code></li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzkiqibwg30qn0er46k.gif" alt="动画演示"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 219. Contains Duplicate II// https://leetcode.com/problems/contains-duplicate-ii/description/// 时间复杂度: O(n)// 空间复杂度: O(k)class Solution {public:    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) {        if(nums.size() &lt;= 1)  return false;        if(k &lt;= 0)  return false;        unordered_set&lt;int&gt; record;        for(int i = 0 ; i &lt; nums.size() ; i ++){            if(record.find(nums[i]) != record.end()){                return true;            }            record.insert(nums[i]);            // 保持record中最多有k个元素            // 因为在下一次循环中会添加一个新元素,使得总共考虑k+1个元素            if(record.size() == k + 1){                record.erase(nums[i - k]);            }        }        return false;    }};</code></pre><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzkgtfhdj31sa0u0acp.jpg" alt="执行结果"></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 查找表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 199 号问题：二叉树的右视图</title>
      <link href="/posts/44435/"/>
      <url>/posts/44435/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第 199 号问题：<strong><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">二叉树的右视图</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p></blockquote><blockquote><p>示例:</p></blockquote><blockquote><p>输入: [1,2,3,null,5,null,4]<br>输出: [1, 3, 4]<br>解释:</p></blockquote><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181115113435.png" alt=""></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>与之前<a href="https://xiaozhuanlan.com/topic/8579460312" target="_blank" rel="noopener">二叉树的层次遍历</a>类似的，该问题需要用到<strong>队列</strong>,</p><ul><li>建立一个queue</li><li>遍历每层的节点时，把下一层的节点都存入到queue中</li><li>每当开始新一层节点的遍历之前，先把新一层最后一个节点值存到结果中</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzk3w6l8g30qg0esn4u.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkzk592lzj30y20u0dh3.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 144 号问题：二叉树的前序遍历</title>
      <link href="/posts/55906/"/>
      <url>/posts/55906/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第 144 号问题：<strong><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">二叉树的前序遍历</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个二叉树，返回它的 前序 遍历。</p></blockquote><blockquote><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4></blockquote><blockquote><p><strong>输入:</strong> [1,null,2,3]  </p></blockquote><p> <img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181109101353.png" alt="">   </p><blockquote><p><strong>输出:</strong> [1,2,3]<br><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用<strong>栈(Stack)</strong>的思路来处理问题。</p><p>前序遍历的顺序为<strong>根-左-右</strong>，具体算法为：</p><ul><li>把根节点push到栈中</li><li>循环检测栈是否为空，若不空，则取出栈顶元素，保存其值</li><li>看其右子节点是否存在，若存在则push到栈中</li><li>看其左子节点，若存在，则push到栈中。</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzj5lp54g30qp0ey48h.gif" alt="动画演示"></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkzj84jmxj30y20u0qc5.jpg" alt="参考代码"></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 102 号问题：二叉树的层次遍历</title>
      <link href="/posts/23450/"/>
      <url>/posts/23450/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第102 号问题：<strong><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层次遍历</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p></blockquote><blockquote><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p></blockquote><blockquote><p> <img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181112084143.png" alt=""></p><p>返回其层次遍历结果：</p></blockquote><blockquote><p>[<br>   [3],<br>   [9,20],<br>   [15,7]<br>]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>该问题需要用到<strong>队列</strong></p><ul><li>建立一个queue</li><li>先把根节点放进去，这时候找根节点的左右两个子节点</li><li>去掉根节点，此时queue里的元素就是下一层的所有节点</li><li>用for循环遍历，将结果存到一个一维向量里</li><li>遍历完之后再把这个一维向量存到二维向量里</li><li>以此类推，可以完成层序遍历</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzexxrigg30qp0ey12m.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzgwok70j30u0107whf.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 145 号问题：二叉树的后序遍历</title>
      <link href="/posts/16505/"/>
      <url>/posts/16505/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第145 号问题：<strong><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/description/" target="_blank" rel="noopener">二叉树的后序遍历</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个二叉树，返回它的 后序 遍历。</p></blockquote><blockquote><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4></blockquote><blockquote><p><strong>输入:</strong> [1,null,2,3]  </p></blockquote><p> <img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181109101353.png" alt="">   </p><blockquote><p><strong>输出:</strong> [3,2,1]<br><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用<strong>栈(Stack)</strong>的思路来处理问题。</p><p>后序遍历的顺序为<strong>左-右-根</strong>，具体算法为：</p><ul><li>先将根结点压入栈，然后定义一个辅助结点head</li><li>while循环的条件是栈不为空</li><li>在循环中，首先将栈顶结点t取出来</li><li>如果栈顶结点没有左右子结点，或者其左子结点是head，或者其右子结点是head的情况下。我们将栈顶结点值加入结果res中，并将栈顶元素移出栈，然后将head指向栈顶元素</li><li>否则的话就看如果右子结点不为空，将其加入栈</li><li>再看左子结点不为空的话，就加入栈</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong><br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzifir92g30qp0ey49p.gif" alt="后序遍历"></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkzigsvjaj31bf0u00yz.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 94 号问题：二叉树的中序遍历</title>
      <link href="/posts/5619/"/>
      <url>/posts/5619/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第 94 号问题：<strong><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个二叉树，返回它的 中序 遍历。</p></blockquote><blockquote><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4></blockquote><blockquote><p><strong>输入:</strong> [1,null,2,3]  </p></blockquote><p> <img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181109101353.png" alt="">   </p><blockquote><p><strong>输出:</strong> [1,3,2]<br><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用<strong>栈(Stack)</strong>的思路来处理问题。</p><p>中序遍历的顺序为<strong>左-根-右</strong>，具体算法为：</p><ul><li>从根节点开始，先将根节点压入栈</li><li>然后再将其所有左子结点压入栈，取出栈顶节点，保存节点值</li><li>再将当前指针移到其右子节点上，若存在右子节点，则在下次循环时又可将其所有左子结点压入栈中</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkxkmfacog30qp0eywoh.gif" alt="动画演示"></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkxkq7y97j30u00u17db.jpg" alt="参考代码"></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 中序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 2 号问题：两个数字相加</title>
      <link href="/posts/54060/"/>
      <url>/posts/54060/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第 2 号问题：<strong><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">两个数字相加</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p></blockquote><blockquote><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p></blockquote><blockquote><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5></blockquote><blockquote><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>设立一个表示进位的变量<code>carried</code>，建立一个新链表，把输入的两个链表从头往后同时处理，每两个相加，将结果加上<code>carried</code>后的值作为一个新节点到新链表后面。</p><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkxjfcatug30qh0eon5c.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkxjhpat9j30ub0u0n4r.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 上第 26 号问题：删除排序数组中的重复项</title>
      <link href="/posts/46534/"/>
      <url>/posts/46534/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第26 号问题：<strong><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">删除排序数组中的重复项</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><blockquote><p>给定数组 nums = [1,1,2], </p></blockquote><blockquote><p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p></blockquote><blockquote><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><blockquote><p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p></blockquote><blockquote><p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p></blockquote><blockquote><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用快慢指针来记录遍历的坐标。</p><ul><li>开始时这两个指针都指向第一个数字</li><li>如果两个指针指的数字相同，则快指针向前走一步</li><li>如果不同，则两个指针都向前走一步</li><li>当快指针走完整个数组后，慢指针当前的坐标加1就是数组中不同数字的个数</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkxjo8a76g30qg0esju1.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkxjmqk58j30xo0tktci.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 上第 454 号问题：4Sum II</title>
      <link href="/posts/48182/"/>
      <url>/posts/48182/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 上第 454 号问题：<strong><a href="https://leetcode-cn.com/problems/4sum-ii/" target="_blank" rel="noopener">4Sum II</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] &gt; + B[j] + C[k] + D[l] = 0。</p></blockquote><blockquote><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。</p></blockquote><blockquote><p><em>例如:</em></p></blockquote><blockquote><p>输入:<br>A = [ 1, 2]<br>B = [-2,-1]<br>C = [-1, 2]<br>D = [ 0, 2] </p></blockquote><blockquote><p>输出:<br>2 </p><p>解释:<br>两个元组如下:       </p><ol><li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0  </li><li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</li></ol></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>与<a href="https://xiaozhuanlan.com/topic/7923618450" target="_blank" rel="noopener">Two Sum</a>类似，需要用哈希表来解决问题。</p><ul><li>把A和B的两两之和都求出来，在哈希表中建立两数之和与其出现次数之间的映射</li><li>遍历C和D中任意两个数之和，只要看哈希表存不存在这两数之和的相反数就行了</li></ul><p>##动画演示</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkxffnjo7g30np0dbadt.gif" alt="4Sum II"></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><pre><code>// 454. 4Sum II// https://leetcode.com/problems/4sum-ii/description/// 时间复杂度: O(n^2)// 空间复杂度: O(n^2)class Solution {public:    int fourSumCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) {        unordered_map&lt;int,int&gt; hashtable;        for(int i = 0 ; i &lt; A.size() ; i ++){            for(int j = 0 ; j &lt; B.size() ; j ++){                 hashtable[A[i]+B[j]] += 1;            }        }        int res = 0;        for(int i = 0 ; i &lt; C.size() ; i ++){            for(int j = 0 ; j &lt; D.size() ; j ++){                if(hashtable.find(-C[i]-D[j]) != hashtable.end()){                    res += hashtable[-C[i]-D[j]];                }            }        }        return res;    }};</code></pre><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkxfhd78yj313c0i5wfd.jpg" alt="执行结果"></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 447 号问题：Number of Boomerangs</title>
      <link href="/posts/32213/"/>
      <url>/posts/32213/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第 447 号问题：<a href="https://leetcode-cn.com/problems/number-of-boomerangs/" target="_blank" rel="noopener">Number of Boomerangs</a></p><blockquote><p>给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 (i, j, k) ，其中 i 和 j 之间的距离和 &gt; i 和 k 之间的距离相等（需要考虑元组的顺序）。</p></blockquote><blockquote><p>找到所有回旋镖的数量。你可以假设 n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。</p></blockquote><blockquote><p>示例:</p></blockquote><blockquote><p>输入:<br>[[0,0],[1,0],[2,0]]   </p></blockquote><blockquote><p>输出:<br>2</p></blockquote><blockquote><p>解释:<br>两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>n最大为500，可以使用时间复杂度为 O(n^2)的算法。</p><ul><li>遍历所有的点，让每个点作为一个锚点</li><li>然后再遍历其他的点，统计和锚点距离相等的点有多少个</li><li>然后分别带入n(n-1)计算结果并累加到res中</li></ul><h5 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h5><h6 id="Tip1"><a href="#Tip1" class="headerlink" title="Tip1"></a>Tip1</h6><ul><li>如果有一个点a，还有两个点b和c，如果ab和ac之间的距离相等，那么就有两种排列方法abc和acb；</li><li>如果有三个点b，c，d都分别和a之间的距离相等，那么有六种排列方法，abc, acb, acd, adc, abd, adb；</li><li>如果有n个点和点a距离相等，那么排列方式为n(n-1)。</li></ul><h6 id="Tip2"><a href="#Tip2" class="headerlink" title="Tip2"></a>Tip2</h6><ul><li>计算距离时不进行开根运算, 以保证精度；</li><li>只有当n大于等于2时，res值才会真正增加，因为当n=1时，增加量为<code>1*(1-1)=0</code>。</li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkx8sx3zlg30qn0estfw.gif" alt=""></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 447. Number of Boomerangs// https://leetcode.com/problems/number-of-boomerangs/description/// 时间复杂度: O(n^2)// 空间复杂度: O(n)class Solution {public:    int numberOfBoomerangs(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) {        int res = 0;        for( int i = 0 ; i &lt; points.size() ; i ++ ){            // record中存储 点i 到所有其他点的距离出现的频次            unordered_map&lt;int, int&gt; record;            for(int j = 0 ; j &lt; points.size() ; j ++){                if(j != i){                    // 计算距离时不进行开根运算, 以保证精度                    record[dis(points[i], points[j])] += 1;                }            }            for(unordered_map&lt;int, int&gt;::iterator iter = record.begin() ; iter != record.end() ; iter ++){                res += (iter-&gt;second) * (iter-&gt;second - 1);            }        }        return res;    }private:    int dis(const pair&lt;int,int&gt; &amp;pa, const pair&lt;int,int&gt; &amp;pb){        return (pa.first - pb.first) * (pa.first - pb.first) +               (pa.second - pb.second) * (pa.second - pb.second);    }};</code></pre><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181030113403.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 元祖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 103 号问题：二叉树的锯齿形层次遍历</title>
      <link href="/posts/37190/"/>
      <url>/posts/37190/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第103 号问题：<strong><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">二叉树的锯齿形层次遍历</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p></blockquote><blockquote><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p></blockquote><blockquote><p> <img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181112084143.png" alt=""></p><p>返回其层次遍历结果：</p></blockquote><blockquote><p>[<br>   [3],<br>   [20,9],<br>   [15,7]<br>]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>该问题需要用到<strong>队列</strong>，与之前的<a href="https://xiaozhuanlan.com/topic/8579460312" target="_blank" rel="noopener">二叉树的层次遍历</a>类似，不同点在于在偶数层需要翻转一下。</p><ul><li>建立一个queue</li><li>先把根节点放进去，这时候找根节点的左右两个子节点</li><li>去掉根节点，此时queue里的元素就是下一层的所有节点</li><li>循环遍历，将结果存到一个一维向量里</li><li>遍历完之后再把这个一维向量存到二维向量里</li><li>如果该层为偶数层，则reverse翻转一下</li><li>以此类推，可以完成层序遍历</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkx5g05uxg30qg0esgy0.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkx56go9ij30xa0u0wgi.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建一个酷炫免费的个人博客</title>
      <link href="/posts/6993/"/>
      <url>/posts/6993/</url>
      
        <content type="html"><![CDATA[<h1 id="【新手向】从零开始搭建一个酷炫免费的个人博客"><a href="#【新手向】从零开始搭建一个酷炫免费的个人博客" class="headerlink" title="【新手向】从零开始搭建一个酷炫免费的个人博客"></a>【新手向】从零开始搭建一个酷炫免费的个人博客</h1><p>由于公众号的文章不易后续整理阅读，于是小吴昨天上午花了半个小时使用 GitHub + Hexo 搭建了一下个人博客，打算将公众号的文章搬过去，支持关键字搜索、分类标签功能。效果是下面这样子的👇</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk130ii6qg313l0ixx6q.gif" alt=""></p><p>结果后台好多小伙伴挺好奇博客是怎么搭建的，实际上这个挺简单的，小吴就从零开始分享一波如何搭建一个酷炫免费的个人博客吧，如果已经有博客的小伙伴可以留言一波网站地址：）</p><h3 id="GitHub创建个人仓库"><a href="#GitHub创建个人仓库" class="headerlink" title="GitHub创建个人仓库"></a>GitHub创建个人仓库</h3><p>登录到 GitHub ，如果没有 GitHub 帐号，请使用你的邮箱注册 GitHub 帐号：<a href="https://github.com/join?source=header-home" target="_blank" rel="noopener">https://github.com/join?source=header-home</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk21xjx8gj31420myn1f.jpg" alt="注册"></p><p>登录成功之后，点击 GitHub 中的 New repository 创建新仓库，仓库名应该为：<strong>用户名</strong> .github.io 。这里<strong>用户名</strong>使用你的 GitHub 帐号名称代替，这是固定写法。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzk2601f8kg313l0ixqca.gif" alt="创建新仓库"></p><p>ps: 因为我已经注册了同名仓库，因此第二次创建时会报错。</p><p>我的仓库名为👇：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk29gwq48j30fu03igls.jpg" alt="仓库名"></p><h3 id="Git管理"><a href="#Git管理" class="headerlink" title="Git管理"></a>Git管理</h3><p>Git 是目前世界上最先进的分布式版本控制系统（没有之一）。这是使用 Git 的目的是为了将我们的网站从本地提交上服务器（GitHub）上面去。我认为 Git 操作是程序员应该具备的一个基本操作，具体的 Git 操作细节可以查看廖雪峰的教程，讲的十分详细 <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk2hsewy8j313r0k0n5i.jpg" alt=""></p><p>安装好 Git 后，只需要进行下面的配置即可。</p><h4 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h4><p>在终端进行操作，设置 user.name 和 user.email 配置信息，我这里设置为全局。</p><pre class=" language-java"><code class="language-java">git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>name <span class="token string">"你的GitHub用户名"</span>git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>email <span class="token string">"你的GitHub注册邮箱"</span></code></pre><h4 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h4><p>通过注册的邮箱生成 ssh 密钥文件：</p><pre class=" language-bash"><code class="language-bash">ssh-keygen -t rsa -C <span class="token string">"你的GitHub注册邮箱"</span></code></pre><p>然后直接三个回车即可，默认不需要设置密码。最后得到了两个文件：<code>id_rsa</code>和<code>id_rsa.pub</code>。</p><h4 id="拷贝密钥"><a href="#拷贝密钥" class="headerlink" title="拷贝密钥"></a>拷贝密钥</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk2vog35vj30mw0f2mzq.jpg" alt="拷贝密钥"></p><p>打开 <code>id_rsa.pub 文件</code>，将里面的内容全部复制。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzk2xjwnthj30tv0b5dh4.jpg" alt="内容全部复制"></p><h4 id="粘贴到GitHub"><a href="#粘贴到GitHub" class="headerlink" title="粘贴到GitHub"></a>粘贴到GitHub</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzk36z40lzj313s0k1n08.jpg" alt="GitHub SSh"></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk376rh7yj313r0ketbj.jpg" alt="添加新的 SSH"></p><h4 id="测试GitHub-SSH"><a href="#测试GitHub-SSH" class="headerlink" title="测试GitHub SSH"></a>测试GitHub SSH</h4><p>添加好 <code>SSH Key</code>后，进行测试。</p><pre><code>ssh -T git@github.com</code></pre><p>你将会看到：</p><pre><code>The authenticity of host &#39;github.com (207.97.227.239)&#39; can&#39;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)?</code></pre><p>选择 <code>yes</code></p><pre><code>Hi MisterBooo! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk3bfd4wzj30i10213yk.jpg" alt="ssh -T"></p><p>如果看到<code>Hi</code>后面是你的用户名，就说明成功了。</p><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>Hexo 基于 Node.js，因此需要先安装 Node.js，你可以在这里进行对应电脑版本的下载：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzk3ecq45aj313u0jkju0.jpg" alt="Node.js下载"></p><p>你也可以通过命令行进行安装：</p><p>cURL:</p><pre><code>$ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</code></pre><p>Wget:</p><pre><code>$ wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</code></pre><p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p><pre><code>$ nvm install stable</code></pre><h3 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><pre><code>$ npm install -g hexo-cli</code></pre><h3 id="Hexo使用"><a href="#Hexo使用" class="headerlink" title="Hexo使用"></a>Hexo使用</h3><p>安装好 Hexo 后，马上就能使用了。首先初始化博客，输入：</p><pre><code>$ hexo init myBlog</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk3pvt34mj319f0u0qcz.jpg" alt=""></p><p>接下来，进入文件夹 <code>myBlog</code>,输入</p><pre><code>$ hexo s</code></pre><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk3s50l94j30hy054t96.jpg" alt=""></p><p>然后，打开浏览器输入地址：</p><pre><code>localhost:4000</code></pre><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk3te442qj313t0n1gxs.jpg" alt="hexo网站"></p><p>执行到这里事实上博客就已经搭建好了，接下来就是去完善它。</p><p>注意：下面的命令都是在 <code>myBlog</code>文件里进行操作的。</p><h3 id="添加文章"><a href="#添加文章" class="headerlink" title="添加文章"></a>添加文章</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk7dls02rj31840kiaco.jpg" alt="添加文章"></p><h4 id="1-直接导入文章"><a href="#1-直接导入文章" class="headerlink" title="1.直接导入文章"></a>1.直接导入文章</h4><p>你可以将你平时写的文章直接导入到 <code>_posts</code>  文件夹里，注意文章类型得是 <code>md</code>格式。</p><h4 id="2-写新文章"><a href="#2-写新文章" class="headerlink" title="2.写新文章"></a>2.写新文章</h4><p>你可以执行下列命令来创建一篇新文章。</p><pre><code>$ hexo new [layout] &lt;title&gt;</code></pre><p>你可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk7hoiy3ij30z6042q3w.jpg" alt="写新文章"></p><p>这样在 <code>_posts</code>  文件夹里也生成了一篇新的文章。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzk7j5ffx5j316c0ewmzp.jpg" alt="新的文章"></p><h3 id="生成网页"><a href="#生成网页" class="headerlink" title="生成网页"></a>生成网页</h3><p>使用 Hexo 生成静态文件快速而且简单。</p><pre><code>$ hexo generate</code></pre><p>你也可以简写成</p><pre><code>$ hexo g</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk7n3i1jyj318d0u0wpf.jpg" alt="生成文章"></p><h3 id="启动服务预览文章"><a href="#启动服务预览文章" class="headerlink" title="启动服务预览文章"></a>启动服务预览文章</h3><p>输入以下命令以启动服务器，你的网站会在 <code>http://localhost:4000</code> 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，无须重启服务器。</p><pre><code>$ hexo server</code></pre><p>你也可以简写成</p><pre><code>$ hexo s</code></pre><p>如果你想要更改端口，或是在执行时遇到了 <code>EADDRINUSE</code> 错误，可以在执行时使用 <code>-p</code> 选项指定其他端口，如下：</p><pre><code>$ hexo server -p 5000</code></pre><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzk7pthinwj315606kdhh.jpg" alt="查看文章"></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzk7rs1dp8j31iy0u0e81.jpg" alt="网站"></p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><pre><code>hexo new &quot;我的博客文章&quot; #新建文章</code></pre><pre><code>hexo generate #生成网页</code></pre><pre><code>hexo server #启动服务预览</code></pre><p>这三个命令依次就是新建一篇博客文章、生成网页、在本地预览的操作。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>Hexo 提供了快速方便的一键部署功能，只需一条命令就能将网站部署到服务器上。</p><pre><code>$ hexo deploy</code></pre><p>你也可以简写成</p><pre><code>$ hexo d</code></pre><p>在开始之前，必须先在 <code>_config.yml</code> 中修改参数，一个正确的部署配置中至少要有 <code>type</code> 参数，例如：</p><pre><code>deploy:  type: git</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk7w0wzlyj30mk0eetae.jpg" alt="config"></p><p>在<code>_config.yml</code>中进行修改。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzk7xrf4smj30y40u00yx.jpg" alt=""></p><p>这一步的目的是将 Hexo 与 GitHub 进行关联。</p><p>配置好后通过</p><pre><code>$ hexo d</code></pre><p>命令，稍等片刻，网站就已经部署好了，可以在浏览器输入<code>你的GitHub名称.github.io</code>，这样一个免费的博客就已经搭建好了。</p><h3 id="Hexo-主题"><a href="#Hexo-主题" class="headerlink" title="Hexo 主题"></a>Hexo 主题</h3><p>hexo 默认的主题可能显得有点呆板，你可以在 <a href="https://hexo.io/themes/index.html" target="_blank" rel="noopener">https://hexo.io/themes/index.html</a>进行主题的挑选更换。将下好的主题安放在<code>themes</code>文件夹内，同时在<code>_config.yml</code>中进行主题修改就好了。</p><p>经过一个小时的主题筛选，我选择了<code>hexo-theme-matery</code> 这款主题。通过<a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/" target="_blank" rel="noopener">https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/</a>文档说明，经过简单的配置，效果就出来了！</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzk9f1968uj30yk0jmtb2.jpg" alt=""></p><p>一般大佬们提供的主题都会提供文档说明，按照说明进行简单的设置就能拥有一个酷炫的页面了。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk130ii6qg313l0ixx6q.gif" alt=""></p><h3 id="Markdown-写作"><a href="#Markdown-写作" class="headerlink" title="Markdown 写作"></a>Markdown 写作</h3><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><p>世面上支持 Markdown 语法的编辑器不胜枚举，选择起来十分困难，小吴在这里推荐 Typora 这款 Markdown 写作软件。</p><p> Typora 是一款免费的 MD 编辑器，它是优雅简洁与强大开放的完美结合体。</p><p>官网直达 <a href="https://typora.io" target="_blank" rel="noopener">https://typora.io</a></p><h4 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h4><p>选择 Typora 一个最主要的原因是它对图片的良好支持。</p><p>在 Mac 上安装好 iPic 后 ，并在设置中将图片插入修改为 通过 iPic 上传 ，快捷键是 control + command + i ，就可以十分快捷优雅地完成图片插入。强调一点：图床使用默认的微博图床即可，建议不要折腾。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzk9r3q6toj30s40rwh1u.jpg" alt=""></p><p>这样，每次写作时，将图片拖入到 Typora 里，图片就能自动上传到图床上。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>申请 GitHub 账号</p></li><li><p>在 GitHub 上创建仓库</p></li><li><p>配备 Git ，同时将 SSH Key 提交到 GitHub 上</p></li><li><p>安装 Node.js</p></li><li><p>安装 Hexo</p></li><li><p>安装 Hexo 主题</p></li><li><p>使用 Markdown 软件写文章</p></li></ul><p>希望这篇文章能帮到想写博客却还没付诸行动的人，毕竟拥有一个免费且酷炫的博客还是挺简单还挺好玩的：）</p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 新手 </tag>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode上第 75 号问题： Two Sum II</title>
      <link href="/posts/34840/"/>
      <url>/posts/34840/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/10/29/166bdc86b1885e65?w=2294&amp;h=1412&amp;f=png&amp;s=261824" alt=""><br>leetcode上第75号问题：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">Two Sum II</a></p><blockquote><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p></blockquote><blockquote><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p></blockquote><blockquote><p>说明:</p></blockquote><blockquote><ul><li>返回的下标值（index1 和 index2）不是从零开始的。</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ul></blockquote><blockquote><p>示例:</p></blockquote><blockquote><p>输入: numbers = [2, 7, 11, 15], target = 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>初始化左指针left指向数组起始，初始化右指针right指向数组结尾。</p><p>根据<strong>已排序</strong>这个特性，</p><ul><li><p>（1）如果numbers[left]与numbers[right]的和tmp小于target，说明应该增加tmp,因此left右移指向一个较大的值。</p></li><li><p>（2）如果tmp大于target，说明应该减小tmp,因此right左移指向一个较小的值。</p></li><li><p>（3）tmp等于target，则找到，返回left+1和right+1。（注意以1为起始下标）</p></li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://user-gold-cdn.xitu.io/2018/10/29/166bdc5dfb63ea8d?w=853&amp;h=457&amp;f=gif&amp;s=69203" alt=""></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对撞指针</span><span class="token comment" spellcheck="true">// 时间复杂度: O(n)</span><span class="token comment" spellcheck="true">// 空间复杂度: O(1)</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">twoSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> numbers<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> res<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> res<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span>                l <span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token comment" spellcheck="true">// numbers[l] + numbers[r] > target</span>                r <span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode上第 283 号问题： Move Zeros</title>
      <link href="/posts/5847/"/>
      <url>/posts/5847/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669facb3a2bb86e?w=1240&amp;h=574&amp;f=png&amp;s=228428" alt="Move Zeros"><br>leetcode上第283号问题：<a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">Move Zeros</a></p><blockquote><p>给定一个数组nums，写一个函数，将数组中所有的0挪到数组的末尾，⽽维持其他所有非0元素的相对位置。<br>举例: nums = [0, 1, 0, 3, 12]，函数运⾏后结果为[1, 3, 12, 0, 0]</p></blockquote><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>思路：创建一个临时数组nonZeroElements，遍历nums，将nums中非0元素赋值到nonZeroElements中，而后按顺序将nonZeroElements赋值到nums上，未遍历的元素置0；</p><p>动画如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669facb3a048c12?w=420&amp;h=203&amp;f=gif&amp;s=60758" alt="image"></p><p>代码如下：</p><pre><code>// 时间复杂度: O(n)// 空间复杂度: O(n)class Solution {public:    void moveZeroes(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; nonZeroElements;        // 将vec中所有非0元素放入nonZeroElements中        for(int i = 0 ; i &lt; nums.size() ; i ++)            if(nums[i])                nonZeroElements.push_back(nums[i]);        // 将nonZeroElements中的所有元素依次放入到nums开始的位置        for(int i = 0 ; i &lt; nonZeroElements.size() ; i ++)            nums[i] = nonZeroElements[i];        // 将nums剩余的位置放置为0        for(int i = nonZeroElements.size() ; i &lt; nums.size() ; i ++)            nums[i] = 0;    }};</code></pre><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>思路：设定一个临时变量k=0，遍历数组nums，将非零元素移动到nums[k]位置，同时k++，而后将【k,….nums.size()】中的元素置零。</p><p>动画如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669facb3a3f2742?w=744&amp;h=418&amp;f=gif&amp;s=104124" alt="image"></p><p>代码如下：</p><pre><code>// 原地(in place)解决该问题// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    void moveZeroes(vector&lt;int&gt;&amp; nums) {        int k = 0; // nums中, [0...k)的元素均为非0元素        // 遍历到第i个元素后,保证[0...i]中所有非0元素        // 都按照顺序排列在[0...k)中        for(int i = 0 ; i &lt; nums.size() ; i ++)            if(nums[i])                nums[k++] = nums[i];        // 将nums剩余的位置放置为0        for(int i = k ; i &lt; nums.size() ; i ++)            nums[i] = 0;    }};</code></pre><h3 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h3><p>思路：设定一个临时变量k=0，遍历数组nums，将非零元素与之前的零元素进行交换，维护变量k的值。</p><p>动画如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669facb3a1f570c?w=744&amp;h=418&amp;f=gif&amp;s=92514" alt="image"></p><p>代码如下：</p><pre><code>// 原地(in place)解决该问题// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    void moveZeroes(vector&lt;int&gt;&amp; nums) {        int k = 0; // nums中, [0...k)的元素均为非0元素        // 遍历到第i个元素后,保证[0...i]中所有非0元素        // 都按照顺序排列在[0...k)中        // 同时, [k...i] 为 0        for(int i = 0 ; i &lt; nums.size() ; i ++)            if(nums[i])                if(k != i)                    swap(nums[k++] , nums[i]);                else                    k ++;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示桶排序</title>
      <link href="/posts/19338/"/>
      <url>/posts/19338/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解桶排序"><a href="#【图解数据结构】-一组动画彻底理解桶排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解桶排序"></a>【图解数据结构】 一组动画彻底理解桶排序</h1><p>由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 —–《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序(Bucket sort)是一种基于计数的排序算法（<strong>计数排序</strong>可参考上节的内容），工作的原理是将数据分到有限数量的桶子里，然后每个桶再分别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>设置固定数量的空桶。</p></li><li><p>把数据放到对应的桶中。</p></li><li><p>对每个不为空的桶中数据进行排序。</p></li><li><p>拼接不为空的桶中数据，得到结果。</p></li></ol><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/29/1675ceff66c00fe7?w=955&amp;h=539&amp;f=gif&amp;s=1026397" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，设置固定数量的空桶，在这里为了方便演示，设置桶的数量为 5 个空桶</p></li><li><p>遍历整个数列，找到最大值为 56 ，最小值为 2 ，每个桶的范围为 （ 56 - 2 + 1 ）/ 5 = 11</p></li><li><p>再次遍历整个数列，按照公式 floor((数字 – 最小值) / 11) 将数字放到对应的桶中</p></li><li><p>比如，数字 7 代入公式 floor((7 – 2) / 11) = 0 放入 0 号桶</p></li><li><p>数字 12 代入公式 floor((12 – 2) / 11) = 0 放入 0 号桶</p></li><li><p>数字 56 代入公式 floor((56 – 2) / 11) = 4 放入 4 号桶</p></li><li><p>当向同一个索引的桶，第二次插入数据时，判断桶中已存在的数字与新插入数字的大小，按照左到右，从小到大的顺序插入（可以使用前面讲解的<strong>插入排序</strong>）实现</p></li><li><p>比如，插入数字 19 时， 1 号桶中已经有数字 23 ，在这里使用插入排序，让 19 排在 23 前面</p></li><li><p>遍历完整个数列后，合并非空的桶，按从左到右的顺序合并0，1，2，3，4桶。</p></li><li><p>这样就完成了 <strong>桶排序</strong></p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/29/1675ceff669fd15d?w=1864&amp;h=2122&amp;f=png&amp;s=80844" alt=""></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/29/1675ceff66c62d33?w=2016&amp;h=3272&amp;f=png&amp;s=170854" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/29/1675ceff66b31247?w=2048&amp;h=2260&amp;f=png&amp;s=131496" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 桶排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示快速排序</title>
      <link href="/posts/19819/"/>
      <url>/posts/19819/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解快速排序"><a href="#【图解数据结构】-一组动画彻底理解快速排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解快速排序"></a>【图解数据结构】 一组动画彻底理解快速排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 —–《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>从数列中挑出一个元素，称为 “基准”（pivot）;</p></li><li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p></li></ol><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e00a0d10d84d?w=950&amp;h=534&amp;f=gif&amp;s=492246" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，操作数列中的所有数字</p></li><li><p>在所有数字中选择一个数字作为排序的基准（pivot）, pivot 通常是随机选择的，在这里为了演示方便，我们选择最右边的数字作为 pivot</p></li><li><p>选取好 pivot 后，在操作数列中选择最左边的数字标记为 左标记 ，最右边的数字标记为 右标记</p></li><li><p>将左边的标记向右移动</p></li><li><p>当 左标记 达到超过 pivot 的数字时，停止移动</p></li><li><p>在这里，8 &gt; 6 ,所以停止移动</p></li><li><p>然后将右边的标记向左移动</p></li><li><p>当 右标记 达到小于 pivot 的数字时，停止移动</p></li><li><p>在这里，4 &gt; 6 ,所以停止移动</p></li><li><p>当左右标记停止时，更改标记的数字</p></li><li><p>因此，左标记 的作用是找到一个大于 pivot 的数字，右标记 的作用是找到一个小于 pivot 的数字</p></li><li><p>通过交换数字，可以在数列的左边收集小于 pivot 的数字集合，右边收集大于 pivot 的数字集合</p></li><li><p>交换之后，继续移动 左标记</p></li><li><p>在这里，9 &gt; 6 ,所以停止移动</p></li><li><p>然后将右边的标记向左移动</p></li><li><p>当 右标记 碰撞到 左标记 时也停止移动</p></li><li><p>如果左右侧的标记停止时，并且都在同一个位置，将这个数字和 pivot 的数字交换</p></li><li><p>这就完成了第一次操作</p></li><li><p>小于 6 的都在 6 的左侧，大于 6 的都在 6 的右侧</p></li><li><p>然后递归对这分成的两部分都执行同样的操作</p></li><li><p>完成 快速排序</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e00a0dc023d8?w=1392&amp;h=1524&amp;f=png&amp;s=68959" alt="C++代码实现"></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e00a0cb5d352?w=1668&amp;h=2214&amp;f=png&amp;s=109067" alt="Java代码实现"></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e00a0c058ac5?w=1756&amp;h=1432&amp;f=png&amp;s=74882" alt="Python代码实现"></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e00a0e6e21b7?w=1572&amp;h=2950&amp;f=png&amp;s=139434" alt="JavaScript代码实现"></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示基数排序</title>
      <link href="/posts/56526/"/>
      <url>/posts/56526/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解基数排序"><a href="#【图解数据结构】-一组动画彻底理解基数排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解基数排序"></a>【图解数据结构】 一组动画彻底理解基数排序</h1><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序 (Radix Sort) 是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。基数排序的发明可以追溯到 1887 年赫尔曼·何乐礼在打孔卡片制表机 (Tabulation Machine)上的贡献。</p><p>基数排序法会使用到桶 (Bucket)，顾名思义，通过将要比较的位（个位、十位、百位…），将要排序的元素分配至 0~9 个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其它的比较性排序法。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零</p></li><li><p>从最低位开始，依次进行一次排序</p></li><li><p>从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列</p></li></ol><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^<br><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181128114235.gif" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>基数排序的方式可以采用 LSD (Least sgnificant digital) 或 MSD (Most sgnificant digital)</p></li><li><p>在本例中使用的是 <strong>LSD</strong></p></li><li><p>首先创建编号 0 ， 1 ，2 ，3 ，4 ，5 ， 6 ，7 ，8 ，9 这 10 个桶 </p></li><li><p>遍历整个数列，查看数字的个位数，按照先后顺序存放在对应编号的桶中</p></li><li><p>比如 321 个位数 为 1 ，存放在编号 1 桶中</p></li><li><p>数字 1 个位数 为 1 ，存放在编号 1 桶中，同时存放在 321 上面 </p></li><li><p>遍历完整个数列的个位数，将数字存放在桶中后，按照编号顺序取出数字，先放入桶中的数字先取出</p></li><li><p>然后依次遍历整个数列的十位数，按照上述个位数的操作整理数列</p></li><li><p>依次遍历整个数列的百位数，按照上述个位数的操作整理数列</p></li><li><p>这样就完成了 <strong>基数排序</strong></p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181128123735.png" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181128123743.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基数排序 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示选择排序</title>
      <link href="/posts/43330/"/>
      <url>/posts/43330/</url>
      
        <content type="html"><![CDATA[<p># </p><h1 id="【图解数据结构】-一组动画演示选择排序"><a href="#【图解数据结构】-一组动画演示选择排序" class="headerlink" title="【图解数据结构】 一组动画演示选择排序"></a>【图解数据结构】 一组动画演示选择排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 —–《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</p></li><li><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p></li><li><p>重复第二步，直到所有元素均排序完毕。</p></li></ol><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/16738f0f5824e2d8?w=955&amp;h=538&amp;f=gif&amp;s=346690" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>线性搜索数列并找到最小值，此时找到了为 2</p></li><li><p>将最小值替换为数列中左端的数字，即将 2 与 4 进行交换</p></li><li><p>此时 2 已经排序好</p></li><li><p>继续线性搜索剩余数列找到最小值，此时找到了 3</p></li><li><p>将最小值替换为数列中左端的数字，即将 3 与 4 进行交换</p></li><li><p>此时 2 与 3 已经排序好</p></li><li><p>继续线性搜索剩余数列找到最小值，此时找到了 4</p></li><li><p>如果最小值已经在左端，那么不执行任何操作，所以此时不做任何处理</p></li><li><p>此时 2 、 3  、 4 已经排序好</p></li><li><p>重复相同操作，直到所有数字都被排序</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/16738f0eff237d54?w=1148&amp;h=972&amp;f=png&amp;s=36827" alt=""></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/16738f0f0a65d4cf?w=1668&amp;h=1708&amp;f=png&amp;s=75701" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/16738f0ef955a299?w=1604&amp;h=1110&amp;f=png&amp;s=51471" alt=""></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/16738f0f0156b4cc?w=1452&amp;h=880&amp;f=png&amp;s=44413" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 选择排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一组动画演示归并排序</title>
      <link href="/posts/7604/"/>
      <url>/posts/7604/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画演示归并排序"><a href="#【图解数据结构】-一组动画演示归并排序" class="headerlink" title="【图解数据结构】 一组动画演示归并排序"></a>【图解数据结构】 一组动画演示归并排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 —–《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。</p><h2 id="归并排序（Merge-sort"><a href="#归并排序（Merge-sort" class="headerlink" title="归并排序（Merge sort"></a>归并排序（Merge sort</h2><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ul><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li><li>自下而上的迭代；</li></ul><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p></li><li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p></li><li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p></li><li><p>重复步骤 3 直到某一指针达到序列尾；</p></li><li><p>将另一序列剩下的所有元素直接复制到合并序列尾。</p></li></ol><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16733b1a9c74ce50?w=955&amp;h=538&amp;f=gif&amp;s=586156" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，将数字分割成两片区域</p></li><li><p>将数字分割成两片区域</p></li><li><p>。。。。。。</p></li><li><p>直到每片区域只有一个元素</p></li><li><p>分割完成</p></li><li><p>接下来，将分割的每片区域进行合并组合</p></li><li><p>合并时，按照数字的升序移动，使得合并后的数字在组内按升序排列</p></li><li><p>当合并包含多个数字的组时，比较开头的数字，移动其中较小的数字</p></li><li><p>比如在动画中，比较开头的 4 和 3 </p></li><li><p>其中 4 大于 3， 因此移动 3</p></li><li><p>按照同样的逻辑去比较该列剩余的头数</p></li><li><p>4 小于 7 ，所以移动 4</p></li><li><p>。。。。。。</p></li><li><p>递归的重复组的合并操作，直到所有数字都在一个组中。</p></li><li><p>完成 归并排序 啦~</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16733b1a9c8f7fff?w=1832&amp;h=1708&amp;f=png&amp;s=85502" alt="C++代码实现"></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16733b1a9db220c7?w=1668&amp;h=2444&amp;f=png&amp;s=128379" alt="Java代码实现"></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16733b1a9dd4b5f7?w=1322&amp;h=1294&amp;f=png&amp;s=64894" alt="Python代码实现"></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16733b1a9dcea382?w=1344&amp;h=1800&amp;f=png&amp;s=76855" alt="JavaScript代码实现"></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示冒泡排序</title>
      <link href="/posts/13239/"/>
      <url>/posts/13239/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画演示冒泡排序"><a href="#【图解数据结构】-一组动画演示冒泡排序" class="headerlink" title="【图解数据结构】 一组动画演示冒泡排序"></a>【图解数据结构】 一组动画演示冒泡排序</h1><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p></li><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p></li><li><p>针对所有的元素重复以上的步骤，除了最后一个。</p></li><li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p></li></ol><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181119200024.gif" alt="五分钟学算法之冒泡排序"></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>将天平放在序列的右端，并比较天平左右的数字</p></li><li><p>在这种情况下我们比较 3 和 8 </p></li><li><p>比较后如果右边的数字较小，则被交换</p></li><li><p>因为 8 大于 3 ，所以数字不用交换</p></li><li><p>比较完成后，将天平向左移动一个位置，比较数字</p></li><li><p>因为 3 大于 2 ，所以数字不用交换</p></li><li><p>比较完成后，逐一移动天平，比较数字</p></li><li><p>此时 2 小于 4 ，所以左右的数字互相交换</p></li><li><p>重复同样的操作，直到天平移动到左端</p></li><li><p>。。。。。。</p></li><li><p>天平到达左端</p></li><li><p>经过上述的操作，数列中最小的数字已经移动到左端</p></li><li><p>将天平返回右端</p></li><li><p>重复相同的操作，直到所有数字都被排序</p></li><li><p>。。。。。。</p></li><li><p>吐完泡泡了</p></li></ol><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181119201851.png" alt=""></p><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181119201910.png" alt=""></p><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181119201417.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 冒泡排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示希尔排序</title>
      <link href="/posts/23853/"/>
      <url>/posts/23853/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解希尔排序"><a href="#【图解数据结构】-一组动画彻底理解希尔排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解希尔排序"></a>【图解数据结构】 一组动画彻底理解希尔排序</h1><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</p></li><li><p>按增量序列个数 k，对序列进行 k 趟排序；</p></li><li><p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p></li></ol><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，选择增量 gap = 10/2 ，缩小增量继续以 gap = gap/2 的方式</p></li><li><p>初始增量为 gap = 10/2 = 5，整个数组分成了 5 组</p></li><li><p>按颜色划分为【 8 , 3 】，【 9 , 5 】，【 1 , 4 】，【 7 , 6 】，【 2 , 0 】</p></li><li><p>对这分开的 5 组分别使用上节所讲的插入排序</p></li><li><p>结果可以发现，这五组中的相对小元素都被调到前面了</p></li><li><p>缩小增量 gap = 5/2 = 2，整个数组分成了 2 组</p></li><li><p>【 3 , 1 , 0 , 9 , 7  】，【 5 , 6 , 8 , 4 , 2  】</p></li><li><p>对这分开的 2 组分别使用上节所讲的插入排序</p></li><li><p>此时整个数组的有序性是很明显的</p></li><li><p>再缩小增量 gap = 2/2 = 1，整个数组分成了 1 组</p></li><li><p>【 0, 2 , 1 , 4 , 3 , 5 , 7 , 6 , 9 , 0  】</p></li><li><p>此时，只需要对以上数列进行简单的微调，不需要大量的移动操作即可完成整个数组的排序</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674859d8e945f1a?w=1280&amp;h=1037&amp;f=png&amp;s=167873" alt=""></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674859d8dda4858?w=1280&amp;h=1275&amp;f=png&amp;s=248791" alt=""></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674859d902e21b0?w=1128&amp;h=1110&amp;f=png&amp;s=53723" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674859d8e52ee54?w=1280&amp;h=934&amp;f=png&amp;s=185891" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 希尔排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示堆排序</title>
      <link href="/posts/29807/"/>
      <url>/posts/29807/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解堆排序"><a href="#【图解数据结构】-一组动画彻底理解堆排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解堆排序"></a>【图解数据结构】 一组动画彻底理解堆排序</h1><h2 id="预备知识：堆结构"><a href="#预备知识：堆结构" class="headerlink" title="预备知识：堆结构"></a>预备知识：堆结构</h2><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p><h4 id="大顶堆"><a href="#大顶堆" class="headerlink" title="大顶堆"></a>大顶堆</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181125194044.png" alt=""></p><h4 id="小顶堆"><a href="#小顶堆" class="headerlink" title="小顶堆"></a>小顶堆</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181125194056.png" alt=""></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序（Heapsort）是指利用堆这种数据结构（后面的【图解数据结构】内容会讲解分析）所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ul><li><p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p></li><li><p>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p></li></ul><p>堆排序的平均时间复杂度为 Ο(nlogn)。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>创建一个堆 H[0……n-1]；</p></li><li><p>把堆首（最大值）和堆尾互换；</p></li><li><p>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</p></li><li><p>重复步骤 2，直到堆的尺寸为 1。</p></li></ol><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181125191942.gif" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，将所有的数字存储在堆中</p></li><li><p>按大顶堆构建堆，其中大顶堆的一个特性是数据将被从大到小取出，将取出的数字按照相反的顺序进行排列，数字就完成了排序</p></li><li><p>在这里数字 5 先入堆</p></li><li><p>数字 2 入堆</p></li><li><p>数字 7 入堆， 7 此时是最后一个节点，与最后一个非叶子节点（也就是数字 5 ）进行比较，由于 7 大于 5 ，所以 7 和 5 交互</p></li><li><p>按照上述的操作将所有数字入堆，然后从左到右，从上到下进行调整，构造出大顶堆</p></li><li><p>入堆完成之后，将堆顶元素取出，将末尾元素置于堆顶，重新调整结构，使其满足堆定义</p></li><li><p>堆顶元素数字 7 取出，末尾元素数字 4 置于堆顶，为了维护好大顶堆的定义，最后一个非叶子节点数字 5 与 4 比较，而后交换两个数字的位置</p></li><li><p>反复执行调整+交换步骤，直到整个序列有序</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="Go代码实现"><a href="#Go代码实现" class="headerlink" title="Go代码实现"></a>Go代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126100338.png" alt=""></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126100347.png" alt=""></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126100353.png" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126100358.png" alt=""></p><p>如果你是iOS开发者，可以在GitHub上 <a href="https://github.com/MisterBooo/Play-With-Sort-OC" target="_blank" rel="noopener">https://github.com/MisterBooo/Play-With-Sort-OC</a> 获取更直观可调试运行的源码。</p><p>你可以在公众号 <strong>五分钟学算法</strong> 获取更多排序内容。</p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示插入排序</title>
      <link href="/posts/42319/"/>
      <url>/posts/42319/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画演示插入排序"><a href="#【图解数据结构】-一组动画演示插入排序" class="headerlink" title="【图解数据结构】 一组动画演示插入排序"></a>【图解数据结构】 一组动画演示插入排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 —–《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p></li><li><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）。</p></li></ol><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181120164938.gif" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>一开始左端数字已经排序，数字 5 不动</p></li><li><p>然后，取出剩余未操作的左端数字 3 </p></li><li><p>将其与已经操作的左侧数字相比较</p></li><li><p>如果左边的数字较大，则交换两个数字</p></li><li><p>这种情况下，由于 5 大于 3 ，所以交换两个数字</p></li><li><p>重复此操作，直到出现一个较小的数字或者数字到达左端</p></li><li><p>数字 3 已经完成排序</p></li><li><p>接下来，和之前一样取出剩余未操作的左端数字 4  </p></li><li><p>与其相邻的左边数字进行比较</p></li><li><p>这种情况下，由于 5 大于 4 ，所以交换两个数字</p></li><li><p>继续操作，由于 3 小于 4 ，即出现了更小的数字，所以 4 停止移动</p></li><li><p>数字 4 已经完成排序</p></li><li><p>重复相同的操作，直到所有的数字完成排序</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="http://upload-images.jianshu.io/upload_images/1940317-ce2bac560fc4620a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="http://upload-images.jianshu.io/upload_images/1940317-e29b04076de62c3a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="http://upload-images.jianshu.io/upload_images/1940317-25d430ac861b8bdd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="http://upload-images.jianshu.io/upload_images/1940317-575eb47403e08c3f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 插入排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示计数排序</title>
      <link href="/posts/33704/"/>
      <url>/posts/33704/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解计数排序"><a href="#【图解数据结构】-一组动画彻底理解计数排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解计数排序"></a>【图解数据结构】 一组动画彻底理解计数排序</h1><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序是一种非基于比较的排序算法，其空间复杂度和时间复杂度均为O(n+k)，其中k是整数的范围。基于比较的排序算法时间复杂度最小是O(nlogn)的。该算法于1954年由 Harold H. Seward 提出。</p><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有<strong>确定范围的整数</strong>。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max</p></li><li><p>开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1)</p></li><li><p>数组 B 中 index 的元素记录的值是 A 中某元素出现的次数</p></li><li><p>最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数</p></li></ol><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126190814.gif" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，扫描一下整个序列</p></li><li><p>获得最小值为 2 ，最大值为 7</p></li><li><p>新建数组包含 2~7 的元素</p></li><li><p>再次扫描序列，将序列的值放置在新建数组中</p></li><li><p>扫描数字 5，数组中 index 为 3 的值为 5，次数为 1</p></li><li><p>扫描数字 3，数组中 index 为 1 的值为 3，次数为 1</p></li><li><p>扫描数字 4，数组中 index 为 2 的值为 4，次数为 1</p></li><li><p>扫描数字 7，数组中 index 为 5 的值为 7，次数为 1</p></li><li><p>扫描数字 2，数组中 index 为 0 的值为 2，次数为 1</p></li><li><p>扫描数字 4，数组中 index 为 2 的值为 4，次数为 2</p></li><li><p>扫描数字 3，数组中 index 为 1 的值为 3，次数为 2</p></li><li><p>按照这种节奏，扫描结束后，新建数组中存放了整个序列以及每个数字出现的次数</p></li><li><p>最后输出目标整数序列</p></li><li><p>输出数字 2，同时数组中 index 为 0 的值为 2 的元素次数变为 0</p></li><li><p>输出数字 3，同时数组中 index 为 1 的值为 3 的元素次数变为 1</p></li><li><p>同样的操作，整个序列就完全输出了</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="Go代码实现"><a href="#Go代码实现" class="headerlink" title="Go代码实现"></a>Go代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126191921.png" alt=""></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126191936.png" alt=""></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126191943.png" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126191949.png" alt=""></p><p>如果你是iOS开发者，可以在GitHub上 <a href="https://github.com/MisterBooo/Play-With-Sort-OC" target="_blank" rel="noopener">https://github.com/MisterBooo/Play-With-Sort-OC</a> 获取更直观可调试运行的源码。</p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 计数排序 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

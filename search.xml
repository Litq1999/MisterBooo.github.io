<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>植树节快到了，送你几棵程序员喜欢的树</title>
      <link href="/posts/f3ee2dcc/"/>
      <url>/posts/f3ee2dcc/</url>
      
        <content type="html"><![CDATA[<p>公历 3 月 12 日是一年一度的植树节。旨在宣传保护森林，并动员群众参加植树造林活动。说到树，程序员们肯定不陌生，趁着这个植树节到来之时普及一下程序员们经常遇见的树。</p><p>程序猿最爱树了。</p><h3 id="1-二叉搜索树"><a href="#1-二叉搜索树" class="headerlink" title="1. 二叉搜索树"></a>1. 二叉搜索树</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>二叉搜索树又称二叉查找树，亦称为二叉排序树。设 x 为二叉查找树中的一个节点，x 节点包含关键字 key，节点x 的 key 值记为 key[x] 。如果 y 是 x 的左子树中的一个节点，则 key[y] &lt;= key[x] ；如果 y 是 x 的右子树的一个节点，则 key[y] &gt;= key[x] 。</p><h4 id="查找性能"><a href="#查找性能" class="headerlink" title="查找性能"></a>查找性能</h4><p>当数据数目为 N，树高度保持 logN 附近。则平均查找长度与 logN 成正比，查找平均时间复杂度为 O(logN) 。 当先后插入的关键字有序时，二叉搜索树退化成单支树结构。此时树高 N 。平均查找长度为 (N+1)/2 ，查找的平均时间复杂度为 O(N) 。</p><h4 id="插入性能"><a href="#插入性能" class="headerlink" title="插入性能"></a>插入性能</h4><p>插入效率与查找效率一致。  </p><h4 id="删除性能"><a href="#删除性能" class="headerlink" title="删除性能"></a>删除性能</h4><p>删除节点时，若节点为叶子节点，或者节点只有单一子树，则时间复杂度为 O(1) 。若节点既有左子树又有右子树，则需要执行递归过程，对应时间复杂度为 O(logN) 。</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>二叉排序树就既有链表的好处，也有数组的好处，因此 <strong>在处理大批量的动态的数据是比较有用</strong>。</p><h4 id="种树"><a href="#种树" class="headerlink" title="种树"></a>种树</h4><h3 id="2-平衡二叉树"><a href="#2-平衡二叉树" class="headerlink" title="2. 平衡二叉树"></a>2. 平衡二叉树</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>平衡二叉树<strong>是一种特殊的二叉搜索树。平衡二叉树保证节点平衡因子的绝对值不超过1，保证了树的平衡</strong>。</p><h4 id="查找性能-1"><a href="#查找性能-1" class="headerlink" title="查找性能"></a>查找性能</h4><p>平衡二叉树是严格平衡的，那么查找过程与二叉搜索树一样，只是平衡二叉树不会出现最差的单支树情形。因此查找效率最好，最坏情况时间复杂度为 O(logN) 。</p><h4 id="插入性能-1"><a href="#插入性能-1" class="headerlink" title="插入性能"></a>插入性能</h4><p>插入数据之前需要进行查找操作，查找到插入位置。插入数据后需要进行旋转操作，旋转操作复杂度为常量级。因此插入数据的时间复杂度与查找相同为 O(logN)。</p><h4 id="删除性能-1"><a href="#删除性能-1" class="headerlink" title="删除性能"></a>删除性能</h4><p>删除数据同样需要查找数据，在删除数据后需要进行调整。一次删除最多需要需要O(logN)次旋转，因此删除数据的时间复杂度为O(logN)+O(logN)=O(2logN)。</p><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>SGI/STL的 set/map 底层都是用红黑树（平衡二叉树的一种）实现的。</p><h4 id="种树-1"><a href="#种树-1" class="headerlink" title="种树"></a>种树</h4><h3 id="3-红黑树"><a href="#3-红黑树" class="headerlink" title="3. 红黑树"></a>3. 红黑树</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>平衡二叉树的严格平衡策略以牺牲建立查找结构(插入，删除操作)的代价，换来了稳定的O(logN) 的查找时间复杂度。红黑树采用了折中策略，即不牺牲太大的建立查找结构的代价，同时又能保证稳定高效的查找效率。</p><h4 id="查找性能-2"><a href="#查找性能-2" class="headerlink" title="查找性能"></a>查找性能</h4><p>由于红黑树的性质(最长路径长度不超过最短路径长度的 2 倍)，可以说明红黑树虽然不像平衡二叉树一样是严格平衡的，但平衡性能还是要比二叉搜索树要好。其查找代价基本维持在 O(logN) 左右，但在最差情况下(最长路径是最短路径的 2 倍少 1)，比平衡二叉树效率低一些。</p><h4 id="插入性能-2"><a href="#插入性能-2" class="headerlink" title="插入性能"></a>插入性能</h4><p>红黑树插入结点时，需要旋转操作和变色操作。但由于只需要保证红黑树基本平衡就可以了。因此插入结点最多只需要2次旋转，这一点和平衡二叉树的插入操作一样，但是变色操作的时间复杂度为O(logN)。</p><h4 id="删除性能-2"><a href="#删除性能-2" class="headerlink" title="删除性能"></a>删除性能</h4><p>红黑树的删除操作代价要比平衡二叉树要好的多，删除一个结点最多只需要 3 次旋转操作，保证了删除时间复杂度维持在常量级。</p><h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><p>应用场景有很多。</p><ul><li>Java 中的 TreeSet ,TreeMap，HashMap</li><li>C++ 的 STL中的 map 和 set 都是用红黑树实现的</li><li>epoll 在内核中的实现，用红黑树管理事件块</li><li>nginx 中，用红黑树管理 timer 等</li><li>linux 进程调度 Completely Fair Schedule r,用红黑树管理进程控制块</li></ul><h4 id="种树-2"><a href="#种树-2" class="headerlink" title="种树"></a>种树</h4><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1g0xi5lwqncj30nc0bldg3.jpg" alt=""></p><h3 id="4-B-树"><a href="#4-B-树" class="headerlink" title="4. B 树"></a>4. B 树</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p><strong>B树</strong>是一种多路平衡查找树，在相同数据数目情形下，B树的高度更小，这样就减少了磁盘的IO次数，在文件系统以及数据库索引等场景下提升了查找效率。</p><h4 id="查找性能-3"><a href="#查找性能-3" class="headerlink" title="查找性能"></a>查找性能</h4><p>B树的查找分成两种：一种是从一个结点查找另一结点的地址的时候，需要定位磁盘地址(查找地址)，查找代价极高。另一种是将结点中的有序关键字序列放入内存，进行优化查找(可以用折半)，相比查找代价极低。而B树的高度很小，因此在这一背景下，B树比任何二叉结构查找树的效率都要高很多。</p><h4 id="插入性能-3"><a href="#插入性能-3" class="headerlink" title="插入性能"></a>插入性能</h4><p>B树的插入会发生结点的分裂操作。当插入操作引起了 s 个节点的分裂时，磁盘访问的次数为 h (读取搜索路径上的节点) ＋2s (回写两个分裂出的新节点) ＋1（回写新的根节点或插入后没有导致分裂的节点）。因此，所需要的磁盘访问次数是 h+2s+1，最多可达到 3h+1。因此插入的代价较大。</p><h4 id="删除性能-3"><a href="#删除性能-3" class="headerlink" title="删除性能"></a>删除性能</h4><p>B树的删除会发生结点合并操作。最坏情况下磁盘访问次数是 3h＝（找到包含被删除元素需要h次读访问）+（获取第2至h层的最相邻兄弟需要h-1次读访问）+（在第3至h层的合并需要h-2次写访问）+（对修改过的根节点和第2层的两个节点进行3次写访问）。</p><h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><p>B树/B+树主要用于磁盘文件组织 数据索引和数据库索引等场景。</p><h4 id="种树-3"><a href="#种树-3" class="headerlink" title="种树"></a>种树</h4><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1g0xi5pbb3aj30zk0h20vh.jpg" alt=""></p><h3 id="5-B-树"><a href="#5-B-树" class="headerlink" title="5. B+ 树"></a>5. B+ 树</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>B+树是B-树的一种变体，B+树相比B-树的特点：</p><blockquote><p>（1）索引节点的key值均会出现在叶子节点中。<br>（2）索引节点中的key值在叶子节点中或者为最大值或者为最小值。<br>（3）叶子节点使用单链表的形式链接起来。</p></blockquote><h4 id="查找性能-4"><a href="#查找性能-4" class="headerlink" title="查找性能"></a><strong>查找性能</strong></h4><p>  （1）在相同数量的待查数据下，B+树查找过程中需要调用的磁盘IO操作要少于普通B-树。由于B+树所在的磁盘存储背景下，因此B+树的查找性能要好于B-树。<br>  （2）B+树的查找效率更加稳定，因为所有叶子结点都处于同一层中，而且查找所有关键字都必须走完从根结点到叶子结点的全部历程。因此同一颗B+树中，任何关键字的查找比较次数都是一样的。而B树的查找是不稳定的。 </p><h4 id="插入性能-4"><a href="#插入性能-4" class="headerlink" title="插入性能"></a>插入性能</h4><p>B+树的插入过程与B树类似，性能也基本一致。</p><h4 id="删除性能-4"><a href="#删除性能-4" class="headerlink" title="删除性能"></a>删除性能</h4><p>删除性能与B树也基本一致。</p><h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><p>B树/B+树主要用于磁盘文件组织 数据索引和数据库索引等场景。</p><h4 id="种树-4"><a href="#种树-4" class="headerlink" title="种树"></a>种树</h4><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1g0xi6kyqwjj30x00ctmy5.jpg" alt=""></p><h3 id="6-霍夫曼树"><a href="#6-霍夫曼树" class="headerlink" title="6. 霍夫曼树"></a>6. 霍夫曼树</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p>给定 n 个权值作为 n 个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为<strong>霍夫曼树(Huffman Tree)</strong>。</p><p>霍夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p><h4 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h4><p>霍夫曼树主要用于霍夫曼编码，进行数据压缩领域。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1g0xhzkipmpg30qd0e4goy.gif" alt="霍夫曼编码"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>我是一个 4 年 iOSer</title>
      <link href="/posts/c78711ba/"/>
      <url>/posts/c78711ba/</url>
      
        <content type="html"><![CDATA[<p>很多粉丝经常在后台询问小吴的本职工作是什么，很多人以为我是算法工程师或者是研究算法的人，也有一些人猜测我是做后台开发。今天就正面回答一下吧：我是一名移动开发工程师。</p><p><strong>我是一个工作 4 年多的 iOS 开发者</strong>。</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1g0z6zg1wiyj31xr0u0n64.jpg" alt="我的 GitHub"></p><p>这四年来我分析过 SDWebImage ，理解了什么叫好的设计模式。</p><p>我啃过 AFNetworking 的源码，明白了 RunLoop 的用处。</p><p>我惊叹过 YYKit ，为什么会有这么精巧的代码。</p><p>这四年来养成的一个最大习惯就是写博客了，最早的一篇博客写于 2016 年 5 月 18 日 。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1g0z7ujueqpj31340gw0w2.jpg" alt=""></p><p>我写博客有个习惯，喜欢配图，配大量的图。因为我发现 iOS 大佬写文章都是配很多图的，要想成为大佬，肯定要去模仿大佬。</p><p>这个大佬就是 <strong>戴铭</strong> ： 可能是 iOS 程序员里最会画图的一个。</p><p>来看一些图：</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1g0z7z3adpxj30zk0m8wn8.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1g0z7zg0b13j30zk0m8tla.jpg" alt=""></p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1g0z804vv9dj30zk0m8ake.jpg" alt=""></p><p>可以说，我是 <strong>戴铭</strong> 大佬的一个粉丝，一直在模仿。恰巧大佬在极客时间出了一个专栏 《iOS 开发高手课》，甚是开心，特此来安利一下。</p><p>下面是介绍。</p><p>###戴铭是谁</p><p><strong>戴铭，GMTC 全球大前端技术大会的专题出品人及讲师之一</strong>，前滴滴出行技术专家，在组件化方案落地、工程动态化、大前端建设、应用开发阶段效率的提升、上线后各种难点问题的解决等方面的经验非常丰富。非常热爱分享，经常将一些技术总结通过代码发到 GitHub上。为了方便大家构建更加清晰的知识脉络，还特地整理了一张脑图。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1g0z86ybb46j30u00ykgz9.jpg" alt=""></p><p>极客时间的品牌我一向比较认可，专栏品质很有保障，《iOS 开发高手课》也是戴铭老师对移动开发这么些年沉淀下来的技术，详细而系统的输出。我看了目录，主要分为基础、应用开发、原理、前端与原生共舞的4个模块，你将获得：</p><p>1、资深iOS开发专家为你构建完整知识脉络</p><p>2、领略专家级大型开发项目，增强面试竞争力</p><p>3、深入iOS 核心技术与原理，从源头上掌控新技术</p><p>4、精美手绘图解知识点帮助你轻松学习</p><p>目前专栏刚上新，限时优惠 <strong>¥68</strong>（原价 ¥99）。</p><h3 id="扫码订阅"><a href="#扫码订阅" class="headerlink" title="扫码订阅"></a>扫码订阅</h3><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1g0z88cst2nj30u01hdqds.jpg" alt=""></p><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3><pre class=" language-c++"><code class="language-c++">NSLog("Hello World");</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法学习，如果有什么秘诀的话，那就都在这里了：）</title>
      <link href="/posts/66700a6e/"/>
      <url>/posts/66700a6e/</url>
      
        <content type="html"><![CDATA[<h3 id="1）不要完美主义！"><a href="#1）不要完美主义！" class="headerlink" title="1）不要完美主义！"></a>1）不要完美主义！</h3><p>我观察到的大多数同学犯得最最最最大的“错误”，就是在学习上“完美主义”。乃至后续很多其他的问题，在我看来都和这个问题是直接相关的。</p><p>举个最经典的例子，也是我经常举的例子，背英语单词（在这里我们先不聊背英语单词是不是好的英语学习方法，我们只看如果我们想要背英语单词的话，应该怎么背）。我发现很多同学拿着红宝书，第一个list都没翻过去就放弃了。这是因为每天背完第一个 list 以后，第二天会发现：第一个list还是有很多单词没掌握，然后就继续背第一个list。然后一周后，发现自己第一个 list 都搞不定，觉得英语好难，彻底放弃了。这就是“完美主义”：不把第一个list“彻底”掌握不肯继续前进。这样是不对的。背了一个list，能多记一个词，都是进步。就算一个词都没记住，模糊有了印象，也是一种进步。我们不应该过度着眼于我们还不够完美。学习不是要么 0 分，要么 100 分的。80 分是收获；60 分是收获；20 分也是收获。有收获最重要。但是因为着眼于自己的不完美，最终放弃了，那就是彻底的 0 分了。</p><p>仔细想，这种“完美主义害死人”的例子特别多。我看到过很多同学，其实是在学习的路上，被自己的“完美主义”逼得“放弃了”——由于学习中有一点没有做好，遭受到了一点点挫折，最终就放弃了整个学习计划。每个人都一定要接受自己的不完美。想开一点：我们都不是小升初考了满分，才能上初中的；也不是中考考了满分，才能读高中的；更不是高考考了满分，才能念大学的；将来也不会是大学所有科目都是满分，才能出来工作。<strong>不完美其实是常态，根本不会影响我们学习更多更深入的内容。但是在自学过程中，很多同学却要求自己在自己制定的每一步计划中都达到“完美”，才进行下一步。最终结果，通常都是“放弃”：（</strong></p><p>可能有的同学会跳出来反驳我：学习当然要认真啊！在这里，我必须强调，我所说的“不要完美主义”，和“学习认真”是不冲突的。什么是“完美主义”，什么又是“囫囵吞枣”，这是一个“度”，每个人其实不一样。不要“完美主义”，不代表学习可以草率前行。每个人都必须要找到适合自己的学习节奏。我的经验是：在一些情况下，问自己一句：是不是自己又犯“完美主义”的毛病了：）</p><h3 id="2）不要过度“学习路径依赖”，学习要冲着自己的目标去。"><a href="#2）不要过度“学习路径依赖”，学习要冲着自己的目标去。" class="headerlink" title="2）不要过度“学习路径依赖”，学习要冲着自己的目标去。"></a>2）不要过度“学习路径依赖”，学习要冲着自己的目标去。</h3><p>什么意思？就是现在信息太发达了，对于大多数领域的知识，网上会有很多所谓的“学习路径”。我不是说这些学习路径没有用，但是不能“过度”依赖这些所谓的学习路径。</p><p>比如，很多同学想学机器学习，大多数学习路径都会告诉你，机器学习需要数学基础。于是，很多同学就转而学习数学去了，非要先把数学学好再去学机器学习。可是发现数学怎么也学不好（在这里，可能完美主义的毛病又犯了），而机器学习却一点儿都没学。最终放弃了机器学习，非常可惜。其实，如果真正去接触机器学习，就会发现，至少在入门阶段，机器学习对数学的要求没有那么高。正因为如此，我一直建议：只要你在本科接触过高数，线数，概率这些科目的基础概念，想学机器学习，就去直接学习机器学习。学习过程中发现自己的数学不够用，再回头补数学。在这种情况下，数学学习得也更有目标性，其实效果更好。</p><p>类似这样的例子还有很多，很多同学想学习做 iOS app，就先去精通 Swift 语言，或者想做android app，就先去精通 java 语言。在我看来大可不必。以我的经验，只要你有一门编译型语言基础，大概看一下这些语言的基础语法，就可以直接上手 iOS 或者 android app 的开发了。先能做出一个最基本的 app，在这个过程中，就会意识到语言特性的意义，再回头深入研究语言也不迟。此时还能结合真实的开发任务去理解语言特性，比没有上手 app 开发，抽象地理解语言特性，有意义的多。</p><p>虽然我一再强调对预算法的学习，语言不重要，但还是有很多同学表示，要先把 C++ 学透，再回来把课程中的算法学好。这是完全没必要的。事实上，在我的这两门课程中，我看到的收获最大的同学，是那些能够把课程中的算法思想理解清楚，然后用自己熟悉的语言去实现的同学：）</p><p>依然是：<strong>不要“过度”学习路径依赖</strong>，什么叫“过度”，每个人的标准不一样。每个人都需要寻找自己的那个“度”。</p><h3 id="3）-不要迷信权威的“好”教材。"><a href="#3）-不要迷信权威的“好”教材。" class="headerlink" title="3） 不要迷信权威的“好”教材。"></a>3） 不要迷信权威的“好”教材。</h3><p>不是说权威教材不好，而是每一本教材都有其预设的读者群，如果你不在这个预设的读者群的范畴里，教材再好也没用。最简单的例子：再好的高数教材，对于小学生来说，都是一堆废纸。</p><p>我经常举的一个例子是《算法导论》。我个人建议如果你是研究生或者博士生，已经有了一定的算法底子，才应该去阅读《算法导论》，我在我的课程的问答区，也谈过如何学习使用算法导论。但是对大多数本科同学，尤其是第一次接触算法的同学，《算法导论》实在不是一个好的教材。但很可惜，很多同学在学习中有上面的两个毛病，既过度路径依赖，别人说《算法导论》好，学习算法要走学《算法导论》这个路径，自己就不探索其他更适合自己的学习路径了，一头扎进《算法导论》里；同时还“完美主义”，对于《算法导论》的前几章，学习的事无巨细，但其实接触了很多在初学算法时没必要学习的内容。最后终于觉得自己学不下去了，放弃了对“算法”整个学科的学习。认为算法太难了。</p><p>诚然，算法不容易，但是，一上来就抱着《算法导论》啃，实在是选择了一条完全没必要的，更难的，甚至可能是根本走不通的路。对于一个领域的学习，了解市面上有什么好的教材是必要的，单也不能迷信权威教材。每个人必须要去探索学习如何寻找适合自己的学习材料。</p><h3 id="4）不要看不起“薄薄”的“傻”教材，这些你看不起的学习材料，可能是你入门某个领域的关键。"><a href="#4）不要看不起“薄薄”的“傻”教材，这些你看不起的学习材料，可能是你入门某个领域的关键。" class="headerlink" title="4）不要看不起“薄薄”的“傻”教材，这些你看不起的学习材料，可能是你入门某个领域的关键。"></a>4）不要看不起“薄薄”的“傻”教材，这些你看不起的学习材料，可能是你入门某个领域的关键。</h3><p>很多同学问我最初学习算法的是什么教材，我告诉他们是这本教材：<a href="https://book.douban.com/subject/1173877/" target="_blank" rel="noopener">《算法设计与分析基础》</a> 。在这里，我完全没有推荐这本教材的意思。事实上，现在我有点儿“鄙视”这本教材。因为我在学习它的过程中，发现这本教材有很多错误（帮助它纠正错误其实也提高了我的水平：）当然，现在这本书的版本可能也和我当时学习的版本不同了，大部分错误应该已经纠正了。）但它确实是我的一本很重要的算法启蒙教材。关键原因是，它够薄。</p><p>在大多数时候，如果有人问我教材推荐，基本上我的回答都是，如果是入门水平：随便找一本在京东，亚马逊，豆瓣上，评分不太差的“薄”的教材，就 ok 了。在这里，关键字是够“薄”。因为“薄”的教材能让你以最快的速度看完，对整个学科有一个全盘的认识：这个领域是做什么的？解决什么问题了？整体解决问题的思路是怎样？解决问题的方法大致是怎样划分的？一些最基础的方法具体是怎样的。这些在初学阶段是至关重要！是让你全盘把握整个领域脉络的。虽然通过这么一本薄薄的教材，你的脉络把握肯定不够全面细致，但比没有强太多！我看过不少同学，一上来学习《算法导论》，关于复杂度分析的笔记做了好几页，然后就放弃了，可是连什么是动态规划都不知道。这样完全没有对“算法”这个领域有全面的认识，甚至可以说根本没有学过“算法”！先用薄教材入门，再找“厚”教材，细细体会其中的细节，是我百试不爽的学习方法。</p><p>另外，在这里，我还要强调“入门教材”，很多教材虽然够“薄”，但不是“入门教材”。大家要注意。</p><h3 id="5）不要迷信单一教材。"><a href="#5）不要迷信单一教材。" class="headerlink" title="5）不要迷信单一教材。"></a>5）不要迷信单一教材。</h3><p>很多同学理解了要找“薄”教材入门的道理，却还是非要我推荐一本具体的“薄”教材，说实话，很多时候这让我有点儿哭笑不得。因为我随便推荐一本，我确实不敢保证它是“最好的”，“最适合你的”，但是各个领域那么多教材，我又不可能都一一看过，一一比较过。最最重要的是，我的学习经验告诉我，在大多数情况下，学习不是一本固定教材可以搞定的。非要找到一本“最适合自己的”教材，然后就一头扎进去，其实是不科学的。我印象很深刻，我读本科的时候，那会儿申请了一个项目，要做一个网站（<a href="http://xn--asp-2s0eu9im33b3uboz4ck4kk16cp2a.net/" target="_blank" rel="noopener">那时候服务端都用ASP.NET</a>），我一口气从图书馆借了10本ASP.NET的教材，然后以一本最薄的书为主干去看，发现这本书介绍不清楚的概念，马上就从其他书里找答案。通常不同的作者对同一个事物从不同的角度做解读，是能够帮助你更深刻的认识一个概念的。基本上一个月的时间，我就从一个完全的网站搭建小白，做出了这个项目需要的那个网站。这个习惯我一直延续，研究生的时候，对什么领域感兴趣了，第一件事就是到图书馆，借十本相关书籍回来翻看。</p><p>但是，大多数同学喜欢仅仅扎进一本书里，一旦选定了自己的学习材料，就对其他材料充耳不闻，甚至是排斥的心理。这种做法，一方面又是“完美主义”的表现——非要把这本教材学透；另一方面，其实也是“犯懒”的表现，不愿意多翻翻，多看看，自己多比较比较，自己去寻找最适合自己的材料，一味地盲目相信所谓“大神”的推荐，殊不知，这些推荐，不一定是更适合自己的材料；更何况，还有很多大神，明明是靠不出名的“薄”教材入的门，但给别人做推荐的时候，就突然变成自己是算法奇才，自幼阅读《算法导论》而所成的神话了：）</p><h3 id="6）实践"><a href="#6）实践" class="headerlink" title="6）实践"></a>6）实践</h3><p>前面说了很多和教材选择相关的话题，但对于计算机领域的学习来说，教材的意义其实远远小于实践的意义。如果仅仅是看学习材料就是学习的话，那么慕课网的视频后期处理人员就是水平最高的工程师了。因为每段视频，他们都需要看一遍。但是，很显然，仅仅是看视频，是无法学到知识的。对于计算机领域的学习来说，真正动手实践去编程是异常重要的。怎么夸大其中的作用都不过分。这就好比学游泳，必须下水去游泳；或者学开车，必须亲自上路。否则你说的再头头是道，一个小学生文化水平的人，只要他开过车，游过泳，都能在这两个领域瞬间秒杀你。</p><p>很多同学都说我的算法讲得好，其实，我一直认为，这其中的一个最简单的秘诀就是：我带领大家把大多数算法都非常细致的实现了一遍；或者对其中的应用进行了非常具体的实践。反观大多数高校教育，对于算法或者机器学习这种一定程度偏理论的学习，通常非常不强调实践。最终的结果是学习者只是接受了很多抽象的概念，但对其中具体的实现细节，却是云里雾里。我见过太多同学，都明白什么是 O(n^2) 复杂度，什么是 O(nlogn) 的复杂度，却问我对于 100 万的数据规模，为什么自己的选择排序运行起来就没反应了。答案很简单：O(n^2) 的复杂度太慢了，100 万的数据规模太大了，一般家用计算机转选择排序一时半会儿是转不完的。这些同学一定理解 O(n^2) 的算法比 O(nlogn) 的算法慢，却没有真正实践过，不知道这个差距到底是多少。</p><p>在我的课程中，经常遇到有些同学提出这样的问题：这个算法的某句话（或者某段逻辑），为什么要写成A的样子，而不是B的样子？这种问题其实很好，但我觉得解决方法也很简单，实际的去把算法改写成B的样子，实际的运行试试看，看会发生什么。如果发生了错误，仔细分析一下，为什么会有错误？如果没有错误，具体比较一下：A和B两种不同的写法，为什么都正确？又有什么区别？真正的学习上的提高，就发生在这个过程中。我当然可以告诉给同学们一个结果，但是自己亲自实践一遍，相比阅读我给出的一个答案，自己对其中问题理解的深刻程度，是完全不可比拟的。</p><p>###7）debug非常非常重要。</p><p>我看到的另一类“经典”问题就是：老师，这个代码为什么错了，然后贴一大段代码。这种问题背后，依然是，透露着学习方法的不对劲：提问的同学懒得 debug 。在计算机领域，debug 近乎和实践是一个意思。如果只是把材料上的代码“抄”一遍，这不叫实践，这叫抄代码。小学生也能做。但是“抄”一遍，不小心没抄对，发生了错误，然后自己一点一点调试，找到错误的根源，这叫真的实践。小学生不能做。（当然，我更推崇的是：自己理解了算法的逻辑，按照自己的理解，把算法写出来：）</p><p>不过很多同学不喜欢 debug，我当然理解。其实谁都不喜欢 debug ，但是，debug 才是最重要的能力。（通常在一个领域里，你最不喜欢做的事情，就是这个领域的核心竞争力：）是计算机领域异常重要的一项技能。我见过的所有计算机领域的“高手”，不管是在哪个细分领域，都无一例外，是个 debug 好手。我经常告诉大家，在实际工作中，其实 debug 的时间要占你真正编程时间的 70%。如果你做一个项目，根本不需要 debug ，要么是你的项目对你来说太简单了，要么是你根本没有接触到这个项目的核心。</p><p>debug 不仅仅是找到代码错误，解决错误的手段，其实更是一个重要的学习手段。通过 debug，看看自己写的程序执行逻辑，哪里和自己设想的不一致？再回头看自己哪里想错了，或者想漏了，分析一下自己为什么想错了，或者想漏了，等等等等，依然是，进步就是发生在这个过程的。</p><p>在我的算法课程中，很多同学对递归想不明白，我的建议都是：用一个小数据量，一步步跟踪程序，看看程序到底是怎么运行的。通常这么做，1 个小时的时间，就足以让你深刻理解递归程序的运转逻辑。可是，很多同学懒得花这1个小时的时间，最终的结果是，花了一个下午，对着代码生看，硬想，最终还是没有理解程序的运转逻辑。</p><h3 id="8）量变到质变。"><a href="#8）量变到质变。" class="headerlink" title="8）量变到质变。"></a>8）量变到质变。</h3><p>还有很多同学，对于算法的一些问题，会问：老师，你是怎么想到用这样的方法的？对于这类问题，我的回答一般都是：你见的还不够多。</p><p>不知道是不是受高中阶段学习的影响，有一些同学特别执着于就着一个单一的问题，寻找其中的“解题路径”。当然，我不是说这是完全错误的，但也有一个“度”。我的经验是：与其把时间花在这里，不如去见更多问题。比如动态规划，是算法学习的一个难点，很多同学在学会了背包问题的解法之后，总是执着于去追寻：是怎么想到这种状态定义的方法的。可能是我个人水平有限，我无法清楚地解释是如何想到这种状态定义的方法的。但是我的经验告诉我：再去看，去实践 100 个动态规划相关的问题，然后回头看背包问题，你会发现这种状态定义的方式非常自然。仅仅对着一个问题思考，很多时候都是死胡同。你见识的还不够多，就不足以帮助你总结出更加“普遍”的问题解决的规律。当你见得足够多的时候，一切就都变得很自然，所谓的“量变到质变”。</p><p>不过，大多数同学在这个环节都会“犯懒”，企图通过一个问题就理解问题的本质，这其实和企图通过一本教材就精通一个领域的想法是一样的，是不现实的，不可能的。同时，这里又包含着学习过程中的“完美主义”的思想，遇到一个问题一定要把它想的无比透彻。但是我的经验告诉我：大多数问题，其实都是需要“回头看”的。随着你对一个领域理解的越深入，回头再去看那些曾经的问题，都会产生新的视角，对于很多曾经想不明白的问题也豁然开朗。这也是“进步”的根源。如果卡在一个问题上不前进，不给自己“回头看”的机会，甚至最后是放弃了，就什么也没有学会了。</p><p>所以，很多时候，你发现对一些问题“百思不得其解”，或许不是因为自己“笨”，而是因为“还不够努力”：）</p><h3 id="9）最后，一定要相信时间的力量。"><a href="#9）最后，一定要相信时间的力量。" class="headerlink" title="9）最后，一定要相信时间的力量。"></a>9）最后，一定要相信时间的力量。</h3><p>有一天，在我的一个算法课程群里，有个滴滴的后端大神发招聘，结果大家七嘴八舌的就议论开了，大致主题思想就是：自己什么时候能够成为滴滴的后端大神。这位滴滴的后端大神今年 32 岁；大多数议论的同学，其实连 22 岁都不到。我告诉他们，其实 10 年后，你们就是大神。</p><p>这其实很好理解，回想十年前，也就是 12 岁的你，和现在的你比较，是不是天壤之别？如果把你扔到一堆 12 岁的小朋友中间，22 岁的你是不是就是个大神？同理，32 岁的人，已经在业界摸爬滚打了那么多年，扔回到22岁的大学生中间，当然是大神：）</p><p>很多时候，所谓的“大神”并不神秘，很多时候，仔细观察，会发现时间有着不可磨灭的作用。只要你没有虚度时间，每天都在进步，通常结果都不会太差的。如果再加上一点点机遇，可能就不仅仅是大神。</p><p>愿大家也早日成为大神。</p><p>作者：liuyubobobo</p><p>链接：<a href="https://www.imooc.com/article/26624" target="_blank" rel="noopener">https://www.imooc.com/article/26624</a></p><p>来源：慕课网</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>几道和散列（哈希）表有关的面试题</title>
      <link href="/posts/5bbaf11f/"/>
      <url>/posts/5bbaf11f/</url>
      
        <content type="html"><![CDATA[<h3 id="散列表概念"><a href="#散列表概念" class="headerlink" title="散列表概念"></a>散列表概念</h3><p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p><p>更加详细的介绍请戳这：</p><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p>题目来源于 LeetCode 上第 1 号问题： Two Sum。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><strong>示例:</strong></p><pre><code>给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>使用<strong>散列表</strong>来解决该问题。</p><p>首先设置一个 map 容器 record 用来记录元素的值与索引，然后遍历数组 nums 。</p><ul><li>每次遍历时使用临时变量 complement 用来保存目标值与当前值的差值</li><li>在此次遍历中查找 record ，查看是否有与 complement 一致的值，如果查找成功则返回查找值的索引值与当前变量的值i</li><li>如果未找到，则在 record 保存该元素与索引值 i</li></ul><h3 id="动画描述"><a href="#动画描述" class="headerlink" title="动画描述"></a>动画描述</h3><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1g137n7rcxpg30qh0eun3j.gif" alt="两数之和"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre class=" language-c++"><code class="language-c++">// 1. Two Sum// 时间复杂度：O(n)// 空间复杂度：O(n)class Solution {public:    vector<int> twoSum(vector<int>& nums, int target) {        unordered_map<int,int> record;        for(int i = 0 ; i < nums.size() ; i ++){            int complement = target - nums[i];            if(record.find(complement) != record.end()){                int res[] = {i, record[complement]};                return vector<int>(res, res + 2);            }            record[nums[i]] = i;        }    }};</code></pre><h2 id="2-无重复字符的最长子串"><a href="#2-无重复字符的最长子串" class="headerlink" title="2. 无重复字符的最长子串"></a>2. 无重复字符的最长子串</h2><p>题目来源于 LeetCode 上第 3 号问题：  Longest Substring Without Repeating Characters 。</p><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>建立一个 HashMap ，建立每个字符和其最后出现位置之间的映射，然后再定义两个变量 res 和 left ，其中 res 用来记录最长无重复子串的长度，left 指向该无重复子串左边的起始位置的前一个，一开始由于是前一个，所以在初始化时就是 -1。</p><p>接下来遍历整个字符串，对于每一个遍历到的字符，如果该字符已经在 HashMap 中存在了，并且如果其映射值大于 left 的话，那么更新 left 为当前映射值，然后映射值更新为当前坐标i，这样保证了left始终为当前边界的前一个位置，然后计算窗口长度的时候，直接用 i-left 即可，用来更新结果 res 。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><pre class=" language-c++"><code class="language-c++">class Solution {public:    int lengthOfLongestSubstring(string s) {        int res = 0, left = -1, n = s.size();        unordered_map<int, int> m;        for (int i = 0; i < n; ++i) {            if (m.count(s[i]) && m[s[i]] > left) {                left = m[s[i]];              }            m[s[i]] = i;            res = max(res, i - left);                    }        return res;    }};</code></pre><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>此题也可以使用滑动窗口的概念来处理。</p><p>建立一个 256 位大小的整型数组 freg ，用来建立字符和其出现位置之间的映射。</p><p>维护一个滑动窗口，窗口内的都是没有重复的字符，去尽可能的扩大窗口的大小，窗口不停的向右滑动。</p><ul><li>（1）如果当前遍历到的字符从未出现过，那么直接扩大右边界；</li><li>（2）如果当前遍历到的字符出现过，则缩小窗口（左边索引向右移动），然后继续观察当前遍历到的字符；</li><li>（3）重复（1）（2），直到左边索引无法再移动；</li><li>（4）维护一个结果 res，每次用出现过的窗口大小来更新结果 res ，最后返回 res 获取结果。</li></ul><h3 id="动画描述-1"><a href="#动画描述-1" class="headerlink" title="动画描述"></a>动画描述</h3><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1g137lmow1xg30qf0ev77z.gif" alt="无重复字符的最长子串"></p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><pre class=" language-c++"><code class="language-c++">// 3. Longest Substring Without Repeating Characters// 滑动窗口// 时间复杂度: O(len(s))// 空间复杂度: O(len(charset))class Solution {public:    int lengthOfLongestSubstring(string s) {        int freq[256] = {0};        int l = 0, r = -1; //滑动窗口为s[l...r]        int res = 0;        // 整个循环从 l == 0; r == -1 这个空窗口开始        // 到l == s.size(); r == s.size()-1 这个空窗口截止        // 在每次循环里逐渐改变窗口, 维护freq, 并记录当前窗口中是否找到了一个新的最优值        while(l < s.size()){            if(r + 1 < s.size() && freq[s[r+1]] == 0){                r++;                freq[s[r]]++;            }else {   //r已经到头 || freq[s[r+1]] == 1                freq[s[l]]--;                l++;            }            res = max(res, r-l+1);        }        return res;    }};</code></pre><h2 id="3-三数之和"><a href="#3-三数之和" class="headerlink" title="3. 三数之和"></a>3. 三数之和</h2><p>题目来源于 LeetCode 上第 15 号问题： 3Sum 。</p><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c =</em> 0 ？找出所有满足条件且不重复的三元组。</p><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>题目需要我们找出三个数且和为 0 ，那么除了三个数全是 0 的情况之外，肯定会有负数和正数，所以一开始可以先选择一个数，然后再去找另外两个数，这样只要找到两个数且和为第一个选择的数的相反数就行了。也就是说需要枚举 a 和 b ，将 c 的存入 map 即可。</p><p>需要注意的是返回的结果中，不能有有重复的结果。这样的代码时间复杂度是 O(n^2)。在这里可以先将原数组进行排序，然后再遍历排序后的数组，这样就可以使用双指针以线性时间复杂度来遍历所有满足题意的两个数组合。</p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><pre class=" language-c++"><code class="language-c++">class Solution {public:    vector<vector<int>> threeSum(vector<int>& nums) {        vector<vector<int>> res;        sort(nums.begin(), nums.end());        if (nums.empty() || nums.back() < 0 || nums.front() > 0) return {};        for (int k = 0; k < nums.size(); ++k) {            if (nums[k] > 0) break;            if (k > 0 && nums[k] == nums[k - 1]) continue;            int target = 0 - nums[k];            int i = k + 1, j = nums.size() - 1;            while (i < j) {                if (nums[i] + nums[j] == target) {                    res.push_back({nums[k], nums[i], nums[j]});                    while (i < j && nums[i] == nums[i + 1]) ++i;                    while (i < j && nums[j] == nums[j - 1]) --j;                    ++i; --j;                } else if (nums[i] + nums[j] < target) ++i;                else --j;            }        }        return res;    }};</code></pre><h2 id="4-重复的-DNA-序列"><a href="#4-重复的-DNA-序列" class="headerlink" title="4. 重复的 DNA 序列"></a>4. 重复的 DNA 序列</h2><p>题目来源于 LeetCode 上第 187 号问题：  Repeated DNA Sequences 。</p><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。</p><p>编写一个函数来查找 DNA 分子中所有出现超过一次的 10 个字母长的序列（子串）。</p><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>首先，先将  A , C , G , T 的 ASCII 码用二进制来表示：</p><p>A: 0100 0<strong>001</strong>　　C: 0100 0<strong>011</strong>　　G: 0100 0<strong>111</strong>　　T: 0101 0<strong>100</strong></p><p>通过观察发现每个字符的后三位都不相同，因此可以用<strong>末尾的三位</strong>来区分这四个字符。</p><p>题目要求是查找 10 个字母长的序列，这里我们将每个字符用三位来区分的话，10 个字符就需要 30 位 ，在32位机上也 OK 。</p><p>为了提取出后 30 位，需要使用 <strong>mask</strong> ，取值为 0x7ffffff（二进制表示含有 27 个 1） ，先用此 mask 可取出<strong>整个序列</strong>的后 27 位，然后再向左平移三位可取出 10 个字母长的序列 （ 30 位）。</p><p>为了保存子串的频率，这里使用<strong>哈希表</strong>。</p><p>首先当取出第十个字符时，将其存在哈希表里，和该字符串出现频率映射，之后每向左移三位替换一个字符，查找新字符串在哈希表里出现次数，如果之前刚好出现过一次，则将当前字符串存入返回值的数组并将其出现次数加一，如果从未出现过，则将其映射到 1。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><pre class=" language-c++"><code class="language-c++">class Solution {public:    vector<string> findRepeatedDnaSequences(string s) {        vector<string> res;        if (s.size() <= 10) return res;        int mask = 0x7ffffff, cur = 0;        unordered_map<int, int> m;        for (int i = 0; i < 9; ++i) {            cur = (cur << 3) | (s[i] & 7);        }        for (int i = 9; i < s.size(); ++i) {            cur = ((cur & mask) << 3) | (s[i] & 7);            if (m.count(cur)) {                if (m[cur] == 1) res.push_back(s.substr(i - 9, 10));                ++m[cur];             } else {                m[cur] = 1;            }        }        return res;    }};</code></pre><h2 id="5-两个数组的交集"><a href="#5-两个数组的交集" class="headerlink" title="5. 两个数组的交集"></a>5. 两个数组的交集</h2><p>题目来源于 LeetCode 上第 349 号问题：  Intersection of Two Arrays。</p><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个数组，编写一个函数来计算它们的交集。</p><h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><p>容器类 set 的使用。</p><ul><li>遍历 num1，通过 set 容器 record 存储 num1 的元素</li><li>遍历 num2，在 record 中查找是否有相同的元素，如果有，用 set 容器 resultSet 进行存储</li><li>将 resultSet 转换为 vector 类型</li></ul><h3 id="动画描述-2"><a href="#动画描述-2" class="headerlink" title="动画描述"></a>动画描述</h3><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1g139vl6ud8g30qh0ewgoz.gif" alt="两个数组的交集"></p><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><pre class=" language-c++"><code class="language-c++">// 时间复杂度: O(nlogn)// 空间复杂度: O(n)class Solution {public:    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {        set<int> record;        for( int i = 0 ; i < nums1.size() ; i ++ ){            record.insert(nums1[i]);        }        set<int> resultSet;        for( int i = 0 ; i < nums2.size() ; i ++ ){            if(record.find(nums2[i]) != record.end()){                resultSet.insert(nums2[i]);            }        }        vector<int> resultVector;        for(set<int>::iterator iter = resultSet.begin(); iter != resultSet.end(); iter ++ ){            resultVector.push_back(*iter);        }        return resultVector;    }};</code></pre><h2 id="6-两个数组的交集-II"><a href="#6-两个数组的交集-II" class="headerlink" title="6. 两个数组的交集 II"></a>6. 两个数组的交集 II</h2><p>题目来源于 LeetCode 上第 350 号问题：  Intersection of Two Arrays II。</p><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个数组，编写一个函数来计算它们的交集。</p><p><strong>示例 1:</strong></p><pre><code>输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2]</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9]</code></pre><h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><p>与上题 <strong>两个数组的交集</strong> 类似。只不过这里使用的是 map 。</p><ul><li>遍历 num1，通过 map 容器 record 存储 num1 的元素与频率；</li><li>遍历 num2 ，在 record 中查找是否有相同的元素（该元素的存储频率大于 0 ），如果有，用 map 容器resultVector 进行存储，同时该元素的频率减一。</li></ul><h3 id="动画描述-3"><a href="#动画描述-3" class="headerlink" title="动画描述"></a>动画描述</h3><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1g13a1qnv8pg30qh0ewacr.gif" alt="两个数组的交集 II"></p><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><pre class=" language-c++"><code class="language-c++">// 时间复杂度: O(nlogn)// 空间复杂度: O(n)class Solution {public:    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {        map<int, int> record;        for(int i = 0 ; i < nums1.size() ; i ++){             record[nums1[i]] += 1;        }        vector<int> resultVector;        for(int i = 0 ; i < nums2.size() ; i ++){            if(record[nums2[i]] > 0){                resultVector.push_back(nums2[i]);                record[nums2[i]] --;            }        }        return resultVector;    }};</code></pre><h2 id="7-回旋镖的数量"><a href="#7-回旋镖的数量" class="headerlink" title="7. 回旋镖的数量"></a>7. 回旋镖的数量</h2><p>题目来源于 LeetCode 上第 447 号问题：  Number of Boomerangs 。</p><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定平面上 <em>n</em> 对不同的点，“回旋镖” 是由点表示的元组 <code>(i, j, k)</code> ，其中 <code>i</code> 和 <code>j</code> 之间的距离和 <code>i</code> 和 <code>k</code> 之间的距离相等（<strong>需要考虑元组的顺序</strong>）。</p><p>找到所有回旋镖的数量。你可以假设 <em>n</em> 最大为 <strong>500</strong>，所有点的坐标在闭区间 <strong>[-10000, 10000]</strong> 中。</p><h3 id="题目解析-6"><a href="#题目解析-6" class="headerlink" title="题目解析"></a>题目解析</h3><p>n 最大为 500，可以使用时间复杂度为 O(n^2)的算法。</p><ul><li>遍历所有的点，让每个点作为一个锚点</li><li>然后再遍历其他的点，统计和锚点距离相等的点有多少个</li><li>然后分别带入 n(n-1) 计算结果并累加到 res 中</li></ul><p>注意点：</p><ul><li><p>如果有一个点a，还有两个点 b 和 c ，如果 ab 和 ac 之间的距离相等，那么就有两种排列方法 abc 和 acb ；</p></li><li><p>如果有三个点b，c，d 都分别和 a 之间的距离相等，那么有六种排列方法，abc, acb, acd, adc, abd, adb；</p></li><li><p>如果有 n 个点和点 a 距离相等，那么排列方式为 n(n-1)；</p></li><li><p>计算距离时不进行开根运算, 以保证精度；</p></li><li><p>只有当 n 大于等于 2 时，res 值才会真正增加，因为当n=1时，增加量为<code>1 * ( 1 - 1 ) = 0</code> 。</p></li></ul><h3 id="动画描述-4"><a href="#动画描述-4" class="headerlink" title="动画描述"></a>动画描述</h3><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1g138uidu4yg30qh0ew44f.gif" alt="回旋镖的数量"></p><h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><pre class=" language-c++"><code class="language-c++">// 时间复杂度: O(n^2)// 空间复杂度: O(n)class Solution {public:    int numberOfBoomerangs(vector<pair<int, int>>& points) {        int res = 0;        for( int i = 0 ; i < points.size() ; i ++ ){            // record中存储 点i 到所有其他点的距离出现的频次            unordered_map<int, int> record;            for(int j = 0 ; j < points.size() ; j ++){                if(j != i){                    // 计算距离时不进行开根运算, 以保证精度                    record[dis(points[i], points[j])] += 1;                }            }            for(unordered_map<int, int>::iterator iter = record.begin() ; iter != record.end() ; iter ++){                res += (iter->second) * (iter->second - 1);            }        }        return res;    }private:    int dis(const pair<int,int> &pa, const pair<int,int> &pb){        return (pa.first - pb.first) * (pa.first - pb.first) +               (pa.second - pb.second) * (pa.second - pb.second);    }};</code></pre><p>### </p><h2 id="8-四数相加-II"><a href="#8-四数相加-II" class="headerlink" title="8. 四数相加 II"></a>8. 四数相加 II</h2><p>题目来源于 LeetCode 上第 454 号问题： 4Sum II 。</p><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 <code>(i, j, k, l)</code> ，使得 <code>A[i] + B[j] + C[k] + D[l] = 0</code>。</p><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28- 1 之间，最终结果不会超过 2^31 - 1 。</p><h3 id="题目解析-7"><a href="#题目解析-7" class="headerlink" title="题目解析"></a>题目解析</h3><p>与 <strong>Two Sum</strong> 极其类似，使用哈希表来解决问题。</p><ul><li>把 A 和 B 的两两之和都求出来，在哈希表中建立两数之和与其出现次数之间的映射；</li><li>遍历 C 和 D 中任意两个数之和，只要看哈希表存不存在这两数之和的相反数就行了。</li></ul><h3 id="动画描述-5"><a href="#动画描述-5" class="headerlink" title="动画描述"></a>动画描述</h3><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1g13a7h7zvxg30qh0ewq73.gif" alt="四数相加 II"></p><h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><pre class=" language-c++"><code class="language-c++">// 时间复杂度: O(n^2)// 空间复杂度: O(n^2)class Solution {public:    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {        unordered_map<int,int> hashtable;        for(int i = 0 ; i < A.size() ; i ++){            for(int j = 0 ; j < B.size() ; j ++){                 hashtable[A[i]+B[j]] += 1;            }        }        int res = 0;        for(int i = 0 ; i < C.size() ; i ++){            for(int j = 0 ; j < D.size() ; j ++){                if(hashtable.find(-C[i]-D[j]) != hashtable.end()){                    res += hashtable[-C[i]-D[j]];                }            }        }        return res;    }};</code></pre><p>### </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统总结</title>
      <link href="/posts/25519ab6/"/>
      <url>/posts/25519ab6/</url>
      
        <content type="html"><![CDATA[<h1 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h1><ul><li>进程是操作系统分配和管理资源的单位，线程是CPU调度和管理的单位，是CPU调度的最小单元。它们拥有的资源也不相同</li><li>进程拥有独立的地址空间，而线程间共享地址空间</li><li>进程创建的开销比较大，线程创建的开销小</li><li>一个进程拥有多个线程，线程可以创建线程</li></ul><h1 id="死锁的必要条件，怎么处理死锁"><a href="#死锁的必要条件，怎么处理死锁" class="headerlink" title="死锁的必要条件，怎么处理死锁"></a>死锁的必要条件，怎么处理死锁</h1><p>答案： <strong>死锁是指多个进程因循环等待资源而造成无法执行的现象。死锁会造成进程无法执行，同时会造成系统资源的极大浪费(资源无法释放)。</strong></p><h2 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h2><ul><li><strong>互斥使用</strong>：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li><li><strong>不可抢占</strong>：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li><li><strong>请求和保持</strong>：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li><li><strong>循环等待</strong>：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li></ul><h2 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h2><p>银行家算法：判断此次请求是否造成死锁若会造成死锁，则拒绝该请求。</p><h1 id="内存管理方式"><a href="#内存管理方式" class="headerlink" title="内存管理方式"></a>内存管理方式</h1><ul><li>段存</li><li>储页存储</li><li>段页存储</li></ul><h1 id="内存为程序分配空间分配方式"><a href="#内存为程序分配空间分配方式" class="headerlink" title="内存为程序分配空间分配方式"></a>内存为程序分配空间分配方式</h1><h2 id="一-：连续分配方式"><a href="#一-：连续分配方式" class="headerlink" title="一 ：连续分配方式"></a>一 ：连续分配方式</h2><p>首先讲连续分配方式。连续分配方式出现的时间比较早，曾广泛应用于20世纪60~70年代的OS中，但是它至今仍然在内存管理方式中占有<strong>一席之地，原因在于它实现起来比较方便，所需的硬件支持最少。连续分配方式又可细分为四种：单一连续分配、固定分区分配、动态分区分配和动态重定位分区分配。</strong></p><h3 id="固定分配"><a href="#固定分配" class="headerlink" title="固定分配"></a>固定分配</h3><p>其中固定分区分配方式，因为分区固定，所以缺乏灵活性，即当程序太小时，会造成内存空间的浪费（内部碎片）；程序太大时，一个分区又不足以容纳，致使程序无法运行（外部碎片）。但尽管如此，当一台计算机去控制多个相同对象的时候，由于这些对象内存大小相同，所以完全可以采用这种内存管理方式，而且是最高效的。这里我们可以看出存储器管理机制的多面性：即没有那种存储器管理机制是完全没有用的，在适合的场合下，一种被认为最不合理的分配方案却可能称为最高效的分配方案。一切都要从实际问题出发，进行设计。</p><h3 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h3><p>为了解决固定分区分配方式的缺乏灵活性，出现了动态分配方式。动态分配方式采用一些寻表（Eg：空闲链表）的方式，查找能符合程序需要的空闲内存分区。但代价是增加了系统运行的开销，而且内存空闲表本身是一个文件，必然会占用一部分宝贵的内存资源，而且有些算法还会增加内存碎片。</p><h3 id="重定向分配"><a href="#重定向分配" class="headerlink" title="重定向分配"></a>重定向分配</h3><p>可重定位分区分配通过对程序实现成定位，从而可以将内存块进行搬移，将小块拼成大块，将小空闲“紧凑”成大空闲，腾出较大的内存以容纳新的程序进程。</p><h2 id="二：基本分页存储管理方式"><a href="#二：基本分页存储管理方式" class="headerlink" title="二：基本分页存储管理方式"></a>二：基本分页存储管理方式</h2><p>连续分配方式会形成许多“碎片”，虽然可以通过“紧凑”方式将许多碎片拼接成可用的大块空间，但须为之付出很大开销。所以提出了“离散分配方式”的想法。如果离散分配的基本单位是页，则称为分页管理方式；如果离散分配的基本单位是段，则称为分段管理方式。</p><ul><li><strong>分页存储管理是将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页，并为各页加以编号，从0开始，如第0页、第1页等</strong>。相应地，也把内存空间分成与页面相同大小的若干个存储块，称为(物理)块或页框(frame)，也同样为它们加以编号，如0#块、1#块等等。在为进程分配内存时，以块为单位将进程中的若干个页分别装入到多个可以不相邻接的物理块中。由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”。</li><li>在分页系统中，允许将进程的各个页离散地存储在内存不同的物理块中（所以能实现离散分配方式），但系统应能保证进程的正确运行，即能在内存中找到每个页面所对应的物理块。为此，<strong>系统又为每个进程建立了一张页面映像表，简称页表。在进程地址空间内的所有页，依次在页表中有一页表项，其中记录了相应页在内存中对应的物理块号</strong>。在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射。</li><li>为了能够将用户地址空间中的逻辑地址，变换为内存空间中的物理地址，<strong>在系统中必须设置地址变换机构。地址变换任务是借助于页表来完成的</strong>。</li><li>页表的功能可由一组专门的寄存器来实现。由于寄存器成本较高，且大多数现代计算机的页表又很大，使页表项总数可达几千甚至几十万个，显然这些页表项不可能都用寄存器来实现，因此，页表大多驻留在内存中。因为一个进程可以通过它的PCB来时时保存自己的状态，等到CPU要处理它的时候才将PCB交给寄存器，所以，系统中虽然可以运行多个进程，但也只需要一个页表寄存器就可以了。</li><li>由于页表是存放在内存中的，这使得CPU在每存取一个数据时，都要两次访问内存。为了提高地址变换速度，在地址变化机构中增设了一个具有<strong>并行查询能力的告诉缓冲寄存器，又称为“联想寄存器</strong>”（Associative Lookaside Buffer）。</li><li>在单级页表的基础上，为了适应非常大的逻辑地址空间，出现了两级和多级页表，但是，他们的原理和单级页表是一样的，只不过为了适应地址变换层次的增加，需要在地址变换机构中增设外层的页表寄存器。</li><li></li></ul><h2 id="三：基本分段存储管理方式"><a href="#三：基本分段存储管理方式" class="headerlink" title="三：基本分段存储管理方式"></a>三：基本分段存储管理方式</h2><p>分段存储管理方式的目的，主要是为了满足用户（程序员）在编程和使用上多方面的要求，其中有些要求是其他几种存储管理方式所难以满足的。因此，这种存储管理方式已成为当今所有存储管理方式的基础。</p><ul><li>方便编程；</li><li>信息共享：分页系统中的“页”只是存放信息的物理单位（块），并无完整的意义，不便于实现共享；然而段却是信息的逻辑单位。由此可知，为了实现段的共享，希望存储器管理能与用户程序分段的组织方式相适应。</li><li>信息保护；</li><li>动态增长；</li><li>动态链接。</li></ul><p>分段管理方式和分页管理方式在实现思路上是很相似的，只不过他们的基本单位不同。分段有段表，也有地址变换机构，为了提高检索速度，同样增设联想寄存器（具有并行查询能力的告诉缓冲寄存器）。所以有些具体细节在这个不再赘述。</p><h2 id="分页和分段的主要区别："><a href="#分页和分段的主要区别：" class="headerlink" title="分页和分段的主要区别："></a>分页和分段的主要区别：</h2><p>1、两者相似之处：<strong>两者都采用离散分配方式，且都要通过地址映射机构来实现地址变换</strong>。 2、两者不同之处：</p><ul><li>（1）页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率。或者说，分页仅仅是由于系统管理的需要而不是用户的需要。段则是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。</li><li>（2）页的大小固定且由系统决定，而段的长度却不固定。</li><li>（3）分页的作业地址空间是一维的，即单一的线性地址空间；而分段的作业地址空间则是二维的</li></ul><h2 id="四：段页式存储管理方式"><a href="#四：段页式存储管理方式" class="headerlink" title="四：段页式存储管理方式"></a>四：段页式存储管理方式</h2><p>前面所介绍的分页和分段存储管理方式都各有优缺点。分页系统能有效地提高内存利用率，而分段系统则能很好地满足用户需求。<strong>我们希望能够把两者的优点结合，于是出现了段页式存储管理方式。</strong> 　　 　　段页式系统的基本原理，是分段和分页原理的结合，即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。<strong>在段页式系统中，地址结构由段号、段内页号和页内地址三部分所组成</strong>。 　　 　　和前两种存储管理方式相同，段页式存储管理方式同样需要增设联想寄存器。 　　离散分配方式基于将一个进程直接分散地分配到许多不相邻的分区中的思想，分为分页式存储管理，分段存储管理和段页式存储管理. 分页式存储管理旨在提高内存利用率，满足系统管理的需要，分段式存储管理则旨在满足用户(程序员)的需要，在实现共享和保护方面优于分页式存储管理，而段页式存储管理则是将两者结合起来，取长补短，即具有分段系统便于实现，可共享，易于保护，可动态链接等优点，又能像分页系统那样很好的解决外部碎片的问题，以及为各个分段可离散分配内存等问题，显然是一种比较有效的存储管理方式。</p><h1 id="页面置换算法："><a href="#页面置换算法：" class="headerlink" title="页面置换算法："></a>页面置换算法：</h1><ul><li>FIFO算法：先入先出，即淘汰最早调入的页面。</li><li>OPT(MIN)算法：选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小。可惜，MIN需要知道将来发生的事，只能在理论中存在，实际不可应用。</li><li>LRU(Least-Recently-Used)算法：用过去的历史预测将来，选最近最长时间没有使用的页淘汰(也称最近最少使用)。性能最接近OPT。与页面使用时间有关。</li><li>LFU(Least Frequently Used)算法：即最不经常使用页置换算法，要求在页置换时置换引用计数最小的页，因为经常使用的页应该有一个较大的引用次数。与页面使用次数有关。</li></ul><h1 id="内部碎片和外部碎片的区别"><a href="#内部碎片和外部碎片的区别" class="headerlink" title="内部碎片和外部碎片的区别"></a>内部碎片和外部碎片的区别</h1><p>（1）内部碎片：由于采用分页的方式分配出去的内存的单位是页，而程序使用的内存不一定占满一页从而产生的未使用的内存称为内部碎片；</p><p>（2）外部碎片：即传统的内存碎片，分配过的内存被回收之后由于太小不能被利用的即为外部碎片。</p><h1 id="进程的几种状态"><a href="#进程的几种状态" class="headerlink" title="进程的几种状态"></a>进程的几种状态</h1><p>进程的基本状态：</p><ul><li>阻塞态：等待某个事件的完成</li><li>就绪态：等待系统分配处理器以便运行</li><li>执行态：占有处理器正在运行</li></ul><p>执行态 -&gt; 阻塞态：往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。</p><p>阻塞态 -&gt; 就绪态：则是等待的条件已满足，只需分配到处理器后就能运行。</p><p>执行态 -&gt; 就绪态：不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时候就变成就绪态。例如时间片用完，或有更高优先级的进程来抢占处理器等。</p><p>就绪态 -&gt; 执行态：系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态</p><h1 id="IPC几种通信方式"><a href="#IPC几种通信方式" class="headerlink" title="IPC几种通信方式"></a>IPC几种通信方式</h1><ul><li>（1）管道（PIPE）和命名管道（FIFO）——比如shell的重定向。</li><li>（2）信号（Signal）——比如杀死某些进程kill -9，比如使用命令nohup使进程忽略SIGHUP信号，让进程在终端退出后，运行在系统后台。信号是一种软件中断。</li><li>（3）消息队列（Message Queue）——相比共享内存会慢一些，缓冲区有限制，但不用加锁，适合命令等小块数据。</li><li>（4）共享内存（Shared Memory）——最快的IPC方式，同一块物理内存映射到进程A、B各自的进程地址空间，可以看到对方的数据更新，需要注意同步机制，比如互斥锁、信号量。适合传输大量数据。</li><li>（5）信号量（Semaphore）。 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。不是用于交换大批数据,而用于多线程之间的同步.常作为一种锁机制,防止某进程在访问资源时其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步和互斥。如对信号量执行PV操作，实现生产者与消费者之间的同步。</li><li>（6）套接字（Socket）——Socket网络编程，网络中不同主机间的进程间通信，属高级进程间通信。</li></ul><h1 id="什么是虚拟内存"><a href="#什么是虚拟内存" class="headerlink" title="什么是虚拟内存"></a>什么是虚拟内存</h1><p><strong>虚拟内存的基本思想是每个程序都拥有自己的地址空间，这个空间被分割成多个块，每块成称为一页或者页面，每一页有连续的地址范围，这些页被映射到物理内存中，但不是所有页都必须在物理内存中才能运行</strong>。当程序引用自己地址空间的内容时，由硬件执行必要的映射，如果引用不在内存中的地址时，<strong>由操作系统负责将缺失部分装入物理内存中并重新执行失败的指令</strong>。</p><p>虚拟内存是计算机系统内存管理的一种技术。 它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率。</p><p>需要注意的是：虚拟内存不只是“用磁盘空间来扩展物理内存”的意思——这只是扩充内存级别以使其包含硬盘驱动器而已。<strong>把内存扩展到磁盘只是使用虚拟内存技术的一个结果，它的作用也可以通过覆盖或者把处于不活动状态的程序以及它们的数据全部交换到磁盘上等方式来实现。对虚拟内存的定义是基于对地址空间的重定义的，即把地址空间定义为“连续的虚拟内存地址”，以借此“欺骗”程序，使它们以为自己正在使用一大块的“连续”地址。</strong></p><h1 id="虚拟地址、逻辑地址、线性地址、物理地址的区别"><a href="#虚拟地址、逻辑地址、线性地址、物理地址的区别" class="headerlink" title="虚拟地址、逻辑地址、线性地址、物理地址的区别"></a>虚拟地址、逻辑地址、线性地址、物理地址的区别</h1><p><strong>虚拟地址</strong>：指的是由程序产生的由段选择符和段内偏移地址两个部分组成的地址。为什么叫它是虚拟的地址呢？因为这两部分组成的地址并没有直接访问物理内存，而是要通过分段地址的变换机构处理或映射后才会对应到相应的物理内存地址。</p><p><strong>逻辑地址</strong>：指由程序产生的与段相关的偏移地址部分。不过有些资料是直接把逻辑地址当成虚拟地址，两者并没有明确的界限。</p><p><strong>线性地址</strong>：指的是虚拟地址到物理地址变换之间的中间层，是处理器可寻指的内存空间（称为线性地址空间）中的地址。程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址。如果启用了分页机制，那么线性地址可以再经过变换产生物理地址。若是没有采用分页机制，那么线性地址就是物理地址。</p><p><strong>物理地址</strong>：指的是现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果！</p><h1 id="线程间同步的方式"><a href="#线程间同步的方式" class="headerlink" title="线程间同步的方式"></a>线程间同步的方式</h1><ul><li>Linux多线程同步方式</li><li>互斥量（mutex）</li><li>读写锁（reader-writer lock）</li><li>自旋锁（spin lock）</li><li>条件变量（condition）</li><li>信号量（semaphore）。如同进程一样，线程也可以通过信号量来实现同步</li><li>屏障（barrier）</li></ul><p>这里要注意两点： （1）互斥量可通过pthread_mutex_setpshared接口设置，用于进程间同步。条件变量在初始化时，也可以通过接口pthread_condattr_setpshared指定该条件变量可用于进程间同步。 （2）不要把Windows提供的多线程同步方式临界区结构对象（CRITICAL_SECTION）记在Linux名下。临界区结构对象分别用EnterCriticalSection()和LeaveCriticalSection()函数去标识和释放一个临界区。</p><h1 id="常见的进程调度策略"><a href="#常见的进程调度策略" class="headerlink" title="常见的进程调度策略"></a>常见的进程调度策略</h1><h2 id="调度的分类"><a href="#调度的分类" class="headerlink" title="调度的分类"></a>调度的分类</h2><p><strong>非抢占式</strong>：分派程序一旦把处理器分配给某个进程就让他一直运行下去，直到进程完成或发生调度进程调度某事件而阻塞时，才把处理机分配给另一个进程</p><p><strong>抢占式</strong>：操作系统将正在运行的进程强行暂停，由调度程序将CPU分配给其他就绪进程的调度方式。</p><h1 id="常见调度策略"><a href="#常见调度策略" class="headerlink" title="常见调度策略"></a>常见调度策略</h1><ul><li>(1)FCFS:调度的顺序就是任务到达就绪队列的顺序，对短作业不公平</li><li>(2)SJF:短作业优先调度</li><li>(3)HRN:最高响应比优先法（响应比：R=1+W/T W:作业在等待队列中等待的时间，T:估计作业执行的时间）</li><li>(4)优先权调度:每个任务关联一个优先级，调度优先级最高的任务</li><li>(5)Round Robin(RR):设置一个时间片，按时间片来轮转调度</li></ul><h1 id="中断的概念"><a href="#中断的概念" class="headerlink" title="中断的概念"></a>中断的概念</h1><p><strong>中断（英语：Interrupt）是指 处理器接收到来自硬件或软件的信号，提示发生了某个事件，应该被注意，这种情况就称为中断</strong>。通常，在接收到来自外围硬件（相对于中央处理器和内存）的异步信号，或来自软件的同步信号之后，处理器将会进行相应的 硬件／软件 处理。发出这样的信号称为进行中断请求（interrupt request，IRQ）。硬件中断导致处理器通过一个运行信息切换（context switch）来保存执行状态（以程序计数器和程序状态字等寄存器信息为主）；软件中断则通常作为CPU指令集中的一个指令，以可编程的方式直接指示这种运行信息切换，并将处理导向一段中断处理代码。中断在计算机多任务处理，尤其是即时系统中尤为有用。</p><h2 id="硬件中断"><a href="#硬件中断" class="headerlink" title="硬件中断"></a>硬件中断</h2><p>由硬件发出或产生的中断称为硬中断，按硬中断事件的来源和实现手段可将中断划分为外中断和内中断：</p><h3 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h3><p>又称为中断或异步中断，是指 来自处理器以外的中断信号，包括时钟中断、键盘中断、外部设备中断等。外中断又分为可屏蔽中断和不可屏蔽中断，各个中断具有不同的优先级，表示事件的紧急程度，在处理高一级中断时，往往会部分或全部屏蔽低等级中断。</p><h3 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h3><p>又称为异常或同步中断（产生时必须考虑与处理器时钟同步），是指来自处理器内部的中断信号，通常是由于程序执行过程中，发现与当前指令关联的、不正常的或错误的事件。内中断可以细分为</p><ul><li>访管中断，由执行系统调用而引起的。</li><li>硬件故障中断，如电源失效、总线超时等。</li><li>程序性中断，如非法操作、地址越界、除数为0和浮点溢出等。</li></ul><h2 id="软件中断"><a href="#软件中断" class="headerlink" title="软件中断"></a>软件中断</h2><p><strong>是一条CPU指令，用以产生一个中断</strong>，由于软中断指令通常要运行一个切换CPU至内核态（Kernel Mode/Ring 0）的子例程，它常被用作实现系统调用（System call）。处理器通常含有一个内部中断屏蔽位，并允许通过软件来设定。一旦被设定，所有外部中断都将被系统忽略。这个屏蔽位的访问速度显然快于中断控制器上的中断屏蔽寄存器，因此可提供更快速地中断屏蔽控制。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/posts/0/"/>
      <url>/posts/0/</url>
      
        <content type="html"><![CDATA[<h1 id="十大经典排序算法视频解析版（Python语言）"><a href="#十大经典排序算法视频解析版（Python语言）" class="headerlink" title="十大经典排序算法视频解析版（Python语言）"></a>十大经典排序算法视频解析版（Python语言）</h1><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><h4 id="1-1-算法步骤"><a href="#1-1-算法步骤" class="headerlink" title="1.1 算法步骤"></a>1.1 算法步骤</h4><ul><li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p></li><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p></li><li><p>针对所有的元素重复以上的步骤，除了最后一个。</p></li><li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p></li></ul><h4 id="1-2-动画视频演示"><a href="#1-2-动画视频演示" class="headerlink" title="1.2 动画视频演示"></a>1.2 动画视频演示</h4><h4 id="1-3-参考代码"><a href="#1-3-参考代码" class="headerlink" title="1.3 参考代码"></a>1.3 参考代码</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>    <span class="token keyword">return</span> arr</code></pre><h3 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h3><h4 id="2-1-算法步骤"><a href="#2-1-算法步骤" class="headerlink" title="2.1 算法步骤"></a>2.1 算法步骤</h4><ul><li><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</p></li><li><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p></li><li><p>重复第二步，直到所有元素均排序完毕。</p></li></ul><h4 id="2-2-动画视频演示"><a href="#2-2-动画视频演示" class="headerlink" title="2.2 动画视频演示"></a>2.2 动画视频演示</h4><h4 id="2-3-参考代码"><a href="#2-3-参考代码" class="headerlink" title="2.3 参考代码"></a>2.3 参考代码</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 记录最小数的索引</span>        minIndex <span class="token operator">=</span> i        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">:</span>                minIndex <span class="token operator">=</span> j        <span class="token comment" spellcheck="true"># i 不是最小数时，将 i 和最小数进行交换</span>        <span class="token keyword">if</span> i <span class="token operator">!=</span> minIndex<span class="token punctuation">:</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token keyword">return</span> arr</code></pre><h3 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h3><h4 id="3-1-算法步骤"><a href="#3-1-算法步骤" class="headerlink" title="3.1 算法步骤"></a>3.1 算法步骤</h4><ul><li><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p></li><li><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p></li></ul><h4 id="3-2-动画视频演示"><a href="#3-2-动画视频演示" class="headerlink" title="3.2 动画视频演示"></a>3.2 动画视频演示</h4><h4 id="3-3-参考代码"><a href="#3-3-参考代码" class="headerlink" title="3.3 参考代码"></a>3.3 参考代码</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        preIndex <span class="token operator">=</span> i<span class="token number">-1</span>        current <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">while</span> preIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> arr<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span> <span class="token operator">></span> current<span class="token punctuation">:</span>            arr<span class="token punctuation">[</span>preIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span>            preIndex<span class="token operator">-=</span><span class="token number">1</span>        arr<span class="token punctuation">[</span>preIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> current    <span class="token keyword">return</span> arr</code></pre><h3 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h3><h4 id="4-1-算法步骤"><a href="#4-1-算法步骤" class="headerlink" title="4.1 算法步骤"></a>4.1 算法步骤</h4><ul><li><p>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</p></li><li><p>按增量序列个数 k，对序列进行 k 趟排序；</p></li><li><p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p></li></ul><h4 id="4-2-动画视频演示"><a href="#4-2-动画视频演示" class="headerlink" title="4.2 动画视频演示"></a>4.2 动画视频演示</h4><h4 id="4-3-参考代码"><a href="#4-3-参考代码" class="headerlink" title="4.3 参考代码"></a>4.3 参考代码</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">shellSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">import</span> math    gap <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>gap <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        gap <span class="token operator">=</span> gap<span class="token operator">*</span><span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">while</span> gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>gap<span class="token punctuation">,</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            j <span class="token operator">=</span> i<span class="token operator">-</span>gap            <span class="token keyword">while</span> j <span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">and</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">:</span>                arr<span class="token punctuation">[</span>j<span class="token operator">+</span>gap<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                j <span class="token operator">-=</span> gap            arr<span class="token punctuation">[</span>j <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> temp        gap <span class="token operator">=</span> math<span class="token punctuation">.</span>floor<span class="token punctuation">(</span>gap <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> arr<span class="token punctuation">}</span></code></pre><h3 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h3><h4 id="5-1-算法步骤"><a href="#5-1-算法步骤" class="headerlink" title="5.1 算法步骤"></a>5.1 算法步骤</h4><ul><li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p></li><li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p></li><li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p></li><li><p>重复步骤 3 直到某一指针达到序列尾；</p></li><li><p>将另一序列剩下的所有元素直接复制到合并序列尾。</p></li></ul><h4 id="5-2-动画视频演示"><a href="#5-2-动画视频演示" class="headerlink" title="5.2 动画视频演示"></a>5.2 动画视频演示</h4><h4 id="5-3-参考代码"><a href="#5-3-参考代码" class="headerlink" title="5.3 参考代码"></a>5.3 参考代码</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">import</span> math    <span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> arr    middle <span class="token operator">=</span> math<span class="token punctuation">.</span>floor<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span>    left<span class="token punctuation">,</span> right <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>middle<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>middle<span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> merge<span class="token punctuation">(</span>mergeSort<span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> mergeSort<span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">while</span> left <span class="token operator">and</span> right<span class="token punctuation">:</span>        <span class="token keyword">if</span> left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>left<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>right<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> left<span class="token punctuation">:</span>        result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>left<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> right<span class="token punctuation">:</span>        result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>right<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result</code></pre><h3 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h3><h4 id="6-1-算法步骤"><a href="#6-1-算法步骤" class="headerlink" title="6.1 算法步骤"></a>6.1 算法步骤</h4><ul><li><p>从数列中挑出一个元素，称为 “基准”（pivot）;</p></li><li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p></li></ul><h4 id="6-2-动画视频演示"><a href="#6-2-动画视频演示" class="headerlink" title="6.2 动画视频演示"></a>6.2 动画视频演示</h4><h4 id="6-3-参考代码"><a href="#6-3-参考代码" class="headerlink" title="6.3 参考代码"></a>6.3 参考代码</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token operator">=</span>None<span class="token punctuation">,</span> right<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>    left <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">if</span> <span class="token operator">not</span> isinstance<span class="token punctuation">(</span>left<span class="token punctuation">,</span><span class="token punctuation">(</span>int<span class="token punctuation">,</span> float<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">else</span> left    right <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">if</span> <span class="token operator">not</span> isinstance<span class="token punctuation">(</span>right<span class="token punctuation">,</span><span class="token punctuation">(</span>int<span class="token punctuation">,</span> float<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">else</span> right    <span class="token keyword">if</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>        partitionIndex <span class="token operator">=</span> partition<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span>        quickSort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> partitionIndex<span class="token number">-1</span><span class="token punctuation">)</span>        quickSort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> partitionIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span>    <span class="token keyword">return</span> arr<span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>    pivot <span class="token operator">=</span> left    index <span class="token operator">=</span> pivot <span class="token operator">+</span> <span class="token number">1</span>    i <span class="token operator">=</span> index    <span class="token keyword">while</span>  i <span class="token operator">&lt;=</span> right<span class="token punctuation">:</span>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span><span class="token punctuation">:</span>            swap<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> index<span class="token punctuation">)</span>            index <span class="token operator">+=</span> <span class="token number">1</span>        i <span class="token operator">+=</span> <span class="token number">1</span>    swap<span class="token punctuation">(</span>arr<span class="token punctuation">,</span>pivot<span class="token punctuation">,</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token keyword">def</span> <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span></code></pre><h3 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h3><h4 id="7-1-算法步骤"><a href="#7-1-算法步骤" class="headerlink" title="7.1 算法步骤"></a>7.1 算法步骤</h4><ul><li><p>创建一个堆 H[0……n-1]；</p></li><li><p>把堆首（最大值）和堆尾互换；</p></li><li><p>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</p></li><li><p>重复步骤 2，直到堆的尺寸为 1。</p></li></ul><h4 id="7-2-动画视频演示"><a href="#7-2-动画视频演示" class="headerlink" title="7.2 动画视频演示"></a>7.2 动画视频演示</h4><h4 id="7-3-参考代码"><a href="#7-3-参考代码" class="headerlink" title="7.3 参考代码"></a>7.3 参考代码</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">import</span> math    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>math<span class="token punctuation">.</span>floor<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        heapify<span class="token punctuation">(</span>arr<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">:</span>    left <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span>    right <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">2</span>    largest <span class="token operator">=</span> i    <span class="token keyword">if</span> left <span class="token operator">&lt;</span> arrLen <span class="token operator">and</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">:</span>        largest <span class="token operator">=</span> left    <span class="token keyword">if</span> right <span class="token operator">&lt;</span> arrLen <span class="token operator">and</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">:</span>        largest <span class="token operator">=</span> right    <span class="token keyword">if</span> largest <span class="token operator">!=</span> i<span class="token punctuation">:</span>        swap<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> largest<span class="token punctuation">)</span>        heapify<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> largest<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">heapSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> arrLen    arrLen <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    buildMaxHeap<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        swap<span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span>        arrLen <span class="token operator">-=</span><span class="token number">1</span>        heapify<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> arr</code></pre><h3 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8. 计数排序"></a>8. 计数排序</h3><h4 id="8-1-算法步骤"><a href="#8-1-算法步骤" class="headerlink" title="8.1 算法步骤"></a>8.1 算法步骤</h4><ul><li><p>花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max</p></li><li><p>开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1)</p></li><li><p>数组 B 中 index 的元素记录的值是 A 中某元素出现的次数</p></li><li><p>最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数</p></li></ul><h4 id="8-2-动画视频演示"><a href="#8-2-动画视频演示" class="headerlink" title="8.2 动画视频演示"></a>8.2 动画视频演示</h4><h4 id="8-3-参考代码"><a href="#8-3-参考代码" class="headerlink" title="8.3 参考代码"></a>8.3 参考代码</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">countingSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> maxValue<span class="token punctuation">)</span><span class="token punctuation">:</span>    bucketLen <span class="token operator">=</span> maxValue<span class="token operator">+</span><span class="token number">1</span>    bucket <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>bucketLen    sortedIndex <span class="token operator">=</span><span class="token number">0</span>    arrLen <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>arrLen<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> bucket<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            bucket<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>        bucket<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>bucketLen<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">while</span> bucket<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>            arr<span class="token punctuation">[</span>sortedIndex<span class="token punctuation">]</span> <span class="token operator">=</span> j            sortedIndex<span class="token operator">+=</span><span class="token number">1</span>            bucket<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>    <span class="token keyword">return</span> arr</code></pre><h3 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9. 桶排序"></a>9. 桶排序</h3><h4 id="9-1-算法步骤"><a href="#9-1-算法步骤" class="headerlink" title="9.1 算法步骤"></a>9.1 算法步骤</h4><ul><li><p>设置固定数量的空桶。</p></li><li><p>把数据放到对应的桶中。</p></li><li><p>对每个不为空的桶中数据进行排序。</p></li><li><p>拼接不为空的桶中数据，得到结果</p></li></ul><h4 id="9-2-动画视频演示"><a href="#9-2-动画视频演示" class="headerlink" title="9.2 动画视频演示"></a>9.2 动画视频演示</h4><h4 id="9-3-参考代码"><a href="#9-3-参考代码" class="headerlink" title="9.3 参考代码"></a>9.3 参考代码</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">BucketSort</span><span class="token punctuation">(</span>Lst<span class="token punctuation">)</span><span class="token punctuation">:</span>    Bucket <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span>max<span class="token punctuation">(</span>Lst<span class="token punctuation">)</span> <span class="token operator">-</span> min<span class="token punctuation">(</span>Lst<span class="token punctuation">)</span> <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 创建并初始化桶</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>Lst<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>               <span class="token comment" spellcheck="true"># 把所有的元素放入桶中，即把对应的元素 +1</span>        Bucket<span class="token punctuation">[</span>Lst<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>min<span class="token punctuation">(</span>Lst<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>    temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>Bucket<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 取出桶中的元素</span>        <span class="token keyword">if</span> Bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>            temp <span class="token operator">+=</span> <span class="token punctuation">[</span>min<span class="token punctuation">(</span>Lst<span class="token punctuation">)</span> <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">*</span> Bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token keyword">return</span> temp</code></pre><h3 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10. 基数排序"></a>10. 基数排序</h3><h4 id="10-1-算法步骤"><a href="#10-1-算法步骤" class="headerlink" title="10.1 算法步骤"></a>10.1 算法步骤</h4><ul><li><p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零</p></li><li><p>从最低位开始，依次进行一次排序</p></li><li><p>从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列</p></li></ul><h4 id="10-2-动画视频演示"><a href="#10-2-动画视频演示" class="headerlink" title="10.2 动画视频演示"></a>10.2 动画视频演示</h4><h4 id="10-3-参考代码"><a href="#10-3-参考代码" class="headerlink" title="10.3 参考代码"></a>10.3 参考代码</h4><pre class=" language-Python"><code class="language-Python">def radix_sort(list, d = 3): # 默认三位数，如果是四位数，则d=4，以此类推    for i in range(d):  # d轮排序        s = [[] for k in range(10)]  # 因每一位数字都是0~9，建10个桶        for j in list:            s[int(j / (10 ** i)) % 10].append(j)          re = [a for b in s for a in b]    return re</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——2-3-4树</title>
      <link href="/posts/566c1253/"/>
      <url>/posts/566c1253/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法——2-3-4树"><a href="#数据结构与算法——2-3-4树" class="headerlink" title="数据结构与算法——2-3-4树"></a>数据结构与算法——2-3-4树</h1><h3 id="1）引言"><a href="#1）引言" class="headerlink" title="1）引言"></a>1）引言</h3><p>在上一篇文章中介绍了 2-3 树的定义以及插入删除操作。本篇文章将在 2-3 树的基础上更进一步，介绍比 2-3 树更为复杂的数据结构 <strong>2-3-4树</strong> 。之所以介绍 2-3-4 树是因为 2-3-4 树与极为重要的红黑树有着等价关系，通过先学习2-3-4 树为后面学习红黑树打下基础，增进对于红黑树的理解。</p><h3 id="2）-2-3-4树"><a href="#2）-2-3-4树" class="headerlink" title="2） 2-3-4树"></a>2） 2-3-4树</h3><p>2-3 树不再是单纯的二叉树了，因为 2-3 树中除了 2- 节点之外还存在 3- 节点。在 2-3 树的基础上进一步扩展， 2-3-4 树在 2-3 树的基础上添加 4- 节点。4- 节点可以存储 3 个键值，最多可以拥有 4 棵子树。</p><h3 id="3）定义"><a href="#3）定义" class="headerlink" title="3）定义"></a>3）定义</h3><p>（1）每个节点每个节点有 1、2 或 3 个 key ，分别称为 2- 节点，3- 节点，4- 节点。<br>（2）所有叶子节点到根节点的长度一致（也就是说叶子节点都在同一层）。<br>（3）每个节点的 key 从左到右保持了从小到大的顺序，两个 key 之间的子树中所有的 key 一定大于它的父节点的左 key ，小于父节点的右 key 。</p><p>例如图 3.1 所示的一棵 2-3-4 树：<br><img src="https://diycode.b0.upaiyun.com/photo/2019/31a4ad7a67f4b3ef31702d58560ddaeb.png" alt="图3.1"></p><h3 id="4）-查找"><a href="#4）-查找" class="headerlink" title="4） 查找"></a>4） 查找</h3><p>2-3-4 树的查找类似了二叉树的查找过程，通过键值的比较来决定遍历方向。</p><p>例如在图3.1所示树中查找22：<br><img src="https://diycode.b0.upaiyun.com/photo/2019/b7e615464fafe41bed102cc65191d814.png" alt=""></p><p>例如在图 3.1 所示树中查找 15 ：</p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/a5c59046add70e07f2dac17c6126b58c.png" alt=""></p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/3013fe5fbfd5107fdd64afe78c86cf4c.png" alt=""></p><h3 id="5）-插入"><a href="#5）-插入" class="headerlink" title="5） 插入"></a>5） 插入</h3><p>如果 2-3-4 树中已存在当前插入的 key ，则插入失败，否则最终一定是在叶子节点中进行插入操作，因为查找过程的结束位置在叶子节点。</p><h4 id="5-1-非-4-节点插入"><a href="#5-1-非-4-节点插入" class="headerlink" title="5.1 非 4- 节点插入"></a>5.1 非 4- 节点插入</h4><p>如果待插入的节点不是 4- 节点，那么直接在该节点插入。<br>例如在 2- 节点插入：</p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/f7e82297b59b83bd9580f3a1f178b537.png" alt=""><br><img src="https://diycode.b0.upaiyun.com/photo/2019/ade8e3625b045353cf37760c0d38d07a.png" alt=""></p><p>例如在 3- 节点插入：<br><img src="https://diycode.b0.upaiyun.com/photo/2019/ea5acf773027d90c148038429c1e8a4f.png" alt=""><br><img src="https://diycode.b0.upaiyun.com/photo/2019/c45ddc7002638dca06497e3ede47bec8.png" alt=""></p><h4 id="5-2-4-节点插入"><a href="#5-2-4-节点插入" class="headerlink" title="5.2 4- 节点插入"></a>5.2 4- 节点插入</h4><p>如果待插入的节点是个 4- 节点，那么应该先分裂该节点然后再插入。一个 4- 节点可以分裂成一个根节点和两个子节点（这三个节点各含一个 key ）然后在子节点中插入，我们把分裂形成的根节点中的 key 看成向上层插入的 key ，然后重复 5.1 和 5.2 。</p><p><strong>图解：</strong><br><img src="https://diycode.b0.upaiyun.com/photo/2019/ce2fc06277592c02ed7a82adcc1f544e.png" alt=""><br><img src="https://diycode.b0.upaiyun.com/photo/2019/d108470ceaa0c9b8a4548f811aaaad4c.png" alt=""></p><h4 id="5-3-根节点分裂"><a href="#5-3-根节点分裂" class="headerlink" title="5.3 根节点分裂"></a>5.3 根节点分裂</h4><p>如果是在 4 节点中进行插入，每次插入会多出一个分支，如果插入操作导致根节点分裂，则 2-3-4 树会生长一层。</p><p><strong>图解：</strong><br><img src="https://diycode.b0.upaiyun.com/photo/2019/5e716bbdb4ae864f5f6454788ee65d6c.png" alt=""><br><img src="https://diycode.b0.upaiyun.com/photo/2019/ea450212cef53281b7f093891a2ff917.png" alt=""><br><img src="https://diycode.b0.upaiyun.com/photo/2019/ebc5a8bd187bdabcb483709be8f5fe61.png" alt=""><br><img src="https://diycode.b0.upaiyun.com/photo/2019/d5c93792c0da471c29e3a51cf3a54570.png" alt=""><br><img src="https://diycode.b0.upaiyun.com/photo/2019/e4cc4ea9b6d85471bfbdba1047211093.png" alt=""><br><img src="https://diycode.b0.upaiyun.com/photo/2019/ffcc7f58b7d00175b9e27a03afdb756a.png" alt=""></p><h3 id="6）-删除"><a href="#6）-删除" class="headerlink" title="6） 删除"></a>6） 删除</h3><p>执行删除之前需要对删除 key 进行查找，若查找失败则无法删除。查找成功，才可删除 key 。删除节点情况有以下几种：</p><h4 id="6-1-删除的节点不为-2-节点"><a href="#6-1-删除的节点不为-2-节点" class="headerlink" title="6.1 删除的节点不为 2- 节点"></a>6.1 删除的节点不为 2- 节点</h4><p>删除的节点不为 2- 节点，则将要删除的目标 key 直接删除即可。</p><p><strong>图解：</strong><br><img src="https://diycode.b0.upaiyun.com/photo/2019/fb15c616d169d2cf531a52a7f7193154.png" alt=""><br><img src="https://diycode.b0.upaiyun.com/photo/2019/30f7f3d7b5810bf506a1dbdc6c0bc682.png" alt=""></p><h4 id="6-2-删除非叶子节点"><a href="#6-2-删除非叶子节点" class="headerlink" title="6.2 删除非叶子节点"></a>6.2 删除非叶子节点</h4><p>当删除的节点是非叶子节点，无论待删除节点的 key 是多少个，先使用中序遍历找到待删除节点的后继节点，然后将后继节点与待删除节点位置互换，此时就将问题转化为删除节点为叶子节点（平衡树的非叶子节点中序遍历后继节点肯定叶子节点），如果该叶子是非 2- 节点，则与 2.4.1 一样，如果该节点是 2- 节点，则跟后面的 2.4.3 情形一样。</p><p><strong>图解：</strong><br><img src="https://diycode.b0.upaiyun.com/photo/2019/b69c16d767a96f8e140119959f130742.png" alt=""><br><img src="https://diycode.b0.upaiyun.com/photo/2019/405515d2395eaa77e651d659c04e9a55.png" alt=""></p><h4 id="6-3-删除的叶子节点为-2-节点"><a href="#6-3-删除的叶子节点为-2-节点" class="headerlink" title="6.3 删除的叶子节点为 2- 节点"></a>6.3 删除的叶子节点为 2- 节点</h4><p>当删除的叶子节点是 2- 节点，则将节点删除后，需要对树进行调整，调整规则如下：</p><p>1）当前节点的父节点是 2- 节点，兄弟节点不为 2- 节点，则将兄弟节点的一个 key 上移成父节点，而父节点下移成子节点，此时树满足 2-3-4 树，完成调整。</p><p>（2）当前节点的父节点是 2-节点，兄弟节点也为 2- 节点，则此时将父节点与兄弟节点合并，将合并后的节点看成当前节点，然后重复的判断，即判断合并后的当前节点的兄弟节点与父节点的情况，然后走对应的（1）（2）（3）处理，直到满足 2-3-4 树，完成调整。</p><p>（3）当前节点的父节点不为 2- 节点，即此时有两个或三个兄弟节点，此时需要根据相邻兄弟节点情形进行调整，规则如下：</p><blockquote><p>（3）-a：若当前节点的相邻兄弟节点为非 3 个 key ，则父节点的一个 key 下移，与相邻兄弟节点合并，此时树满足2-3树，完成调整。<br>（3）-b：若当前节点的相邻兄弟节点为 3 个 key ，则父节点的一个 key 下移成 1 个 key 的节点，相邻兄弟节点的一个 key 上移与父节点合并，此时树满足 2-3-4 树，完成调整。</p></blockquote><p><strong>图解：</strong><br><img src="https://diycode.b0.upaiyun.com/photo/2019/06c6211b94d0448a674110bca658aa7b.png" alt=""><br><img src="https://diycode.b0.upaiyun.com/photo/2019/6af4d48342ac3f713056b8f8acb722a8.png" alt=""></p><p><strong>图解：</strong><br><img src="https://diycode.b0.upaiyun.com/photo/2019/1f4c59d6d50c60e1eec51152e264d9cc.png" alt=""><br><img src="https://diycode.b0.upaiyun.com/photo/2019/a61e102f4d2fe54f05850f986d2349d5.png" alt=""></p><p><strong>图解：</strong><br><img src="https://diycode.b0.upaiyun.com/photo/2019/7e18eb4b8079e3e59d2a4641f63704ca.png" alt=""><br><img src="https://diycode.b0.upaiyun.com/photo/2019/e33f1712069cca999db1c8280c79bed1.png" alt=""></p><h3 id="7）-结语"><a href="#7）-结语" class="headerlink" title="7） 结语"></a>7） 结语</h3><p>本篇文章主要介绍了 2-3-4 树的性质，以及插入删除等操作。介绍 2-3-4 树的目的主要是为了为后续学习红黑树和B- 树打下一个基础。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法——2-3树</title>
      <link href="/posts/95cad743/"/>
      <url>/posts/95cad743/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构与算法——2-3树"><a href="#数据结构与算法——2-3树" class="headerlink" title="数据结构与算法——2-3树"></a>数据结构与算法——2-3树</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前面讲到了二叉搜索树(BST)和二叉平衡树(AVL)，二叉搜索树在最好的情况下搜索的时间复杂度为O(logn)，但如果插入节点时，插入元素序列本身就是有序的，那么BST树就退化成一个线性表了，搜索的时间复杂度为O(n)。<br>如果想要减少比较次数，就需要降低树的高度。在插入和删除节点时，要保证插入节点后不能使叶子节点之间的深度之差大于 1，这样就能保证整棵树的深度最小，这就是AVL树解决BST搜索性能降低的策略。但由于每次插入或删除节点后，都可能会破坏AVL的平衡，而要动态保证AVL的平衡需要很多操作，这些操作会影响整个数据结构的性能，除非是在树的结构变化特别少的情形下，否则AVL树平衡带来的搜索性能提升有可能还不足为了平衡树所带来的性能损耗。<br>因此，引入了 2-3 树来提升效率。2-3 树本质也是一种平衡搜索树，但 2-3 树已经不是一棵二叉树了，因为 2-3 树允许存在 3 这种节点，3- 节点中可以存放两个元素，并且可以有三个子节点。</p><h3 id="2-3-树定义"><a href="#2-3-树定义" class="headerlink" title="2-3 树定义"></a>2-3 树定义</h3><p>2-3 树的定义如下：<br>（1）2-3 树要么为空要么具有以下性质：<br>（2）对于 2- 节点，和普通的 BST 节点一样，有一个数据域和两个子节点指针，两个子节点要么为空，要么也是一个2-3树，当前节点的数据的值要大于左子树中所有节点的数据，要小于右子树中所有节点的数据。<br>（3）对于 3- 节点，有两个数据域 a 和 b 和三个子节点指针，左子树中所有的节点数据要小于a，中子树中所有节点数据要大于 a 而小于 b ，右子树中所有节点数据要大于 b 。<br>例如图 2.1 所示的树为一棵 2-3 树：</p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/a35c4aed00843dbb6aef8157483b7a9e.png" alt="图2.1"></p><h3 id="2-3-树性质"><a href="#2-3-树性质" class="headerlink" title="2-3 树性质"></a>2-3 树性质</h3><p>性质：<br>（1）对于每一个结点有 1 或者 2 个关键码。<br>（2）当节点有一个关键码的时，节点有 2 个子树。<br>（3）当节点有 2 个关键码时，节点有 3 个子树。<br>（4）所有叶子点都在树的同一层。</p><h3 id="2-3树查找"><a href="#2-3树查找" class="headerlink" title="2-3树查找"></a>2-3树查找</h3><p>2-3 树的查找类似二叉搜索树的查找过程，根据键值的比较来决定查找的方向。</p><p>例如在图 2.1 所示的 2-3 树中查找键为H的节点：<br><img src="https://diycode.b0.upaiyun.com/photo/2019/6916e37e045c6e88efb5c8611f4f20c1.png" alt="img"></p><p>例如在图 2.1 所示的 2-3 树中查找键为 B 的节点：<br><img src="https://diycode.b0.upaiyun.com/photo/2019/f65b244cd8bdc1b3b6052e396eaf33ab.png" alt="img"></p><p>###2-3树插入</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>在树的插入之前需要对带插入的节点进行一次查找操作，若树中已经有此节点则不予插入，若没有查找到此节点则记录未命中查找结束时访问的最后一个节点。<br>空树的插入最简单，创建一个节点即可，这里不予赘述。<br>对于非空树插入主要分为4种情况：<br>（1）向 2- 节点中插入新节点<br>（2）向一棵只含 3- 节点的树中插入新节点<br>（3）向一个父节点为 2- 节点的 3- 节点中插入新节点<br>（4）向一个父节点为 3- 节点的 3- 节点中插入新节点</p><h4 id="向2-节点中插入新节点"><a href="#向2-节点中插入新节点" class="headerlink" title="向2-节点中插入新节点"></a>向2-节点中插入新节点</h4><p><strong>操作步骤：如果未命中查找结束于一个 2-节点，直接将 2- 节点替换为一个 3- 节点，并将要插入的键保存在其中。</strong></p><p><strong>图解：</strong><br><img src="https://diycode.b0.upaiyun.com/photo/2019/ccff8feed38e2fd2db5e51918f26c9d3.png" alt="img"></p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/bd768163785f4e33e5f3316d5f1cc3e8.png" alt="img"></p><h4 id="向一棵只含-3-节点的树中插入新节点"><a href="#向一棵只含-3-节点的树中插入新节点" class="headerlink" title="向一棵只含 3- 节点的树中插入新节点"></a>向一棵只含 3- 节点的树中插入新节点</h4><p><strong>操作步骤：先临时将新键存入唯一的 3- 节点中，使其成为一个 4- 节点，再将它转化为一颗由 3 个 2- 节点组成的 2-3 树，分解后树高会增加 1。</strong></p><p><strong>图解：</strong></p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/668493ecbe13fb8da90a0c7ed8229c66.png" alt="img"></p><h4 id="向一个父节点为-2-节点的-3-节点中插入新节点"><a href="#向一个父节点为-2-节点的-3-节点中插入新节点" class="headerlink" title="向一个父节点为 2- 节点的 3- 节点中插入新节点"></a>向一个父节点为 2- 节点的 3- 节点中插入新节点</h4><p><strong>操作步骤：先构造一个临时的 4- 节点并将其分解，分解时将中键移动到父节点中(中键移动后，其父节点中的位置由键的大小确定)</strong></p><p><strong>图解：</strong></p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/46fa0c9c05446a180e1958f3111b577f.png" alt="img"><br><img src="https://diycode.b0.upaiyun.com/photo/2019/79b4a6a6eca96acafffc5c2b442c052d.png" alt="img"></p><p>####向一个父节点为3-节点的3-节点中插入新节点</p><p><strong>操作步骤：插入节点后一直向上分解构造的临时4-节点并将中键移动到更高层双亲节点，直到遇到一个-2节点并将其替换为一个不需要继续分解的3-节点，或是到达树根(3-节点)。</strong></p><p><strong>图解：</strong></p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/fc4c8bd91d7e386238e6047b941ad429.png" alt="img"><br><img src="https://diycode.b0.upaiyun.com/photo/2019/235f51e0c838c7099db14d254a900444.png" alt="img"><br><img src="https://diycode.b0.upaiyun.com/photo/2019/285db0d032c3aae2c0e205fc017e75ec.png" alt="img"></p><h4 id="分解根节点"><a href="#分解根节点" class="headerlink" title="分解根节点"></a>分解根节点</h4><p><strong>操作步骤：如果从插入节点到根节点的路径上全是3-节点（包含根节点在内），根节点将最终被替换为一个临时的4-节点，将临时的4-节点分解为3个2-节点，分解后树高会增加1。</strong></p><p><strong>图解：</strong><br><img src="https://diycode.b0.upaiyun.com/photo/2019/4454c2d88df1f441e6ead6a550407fcd.png" alt="img"></p><h3 id="2-3树删除"><a href="#2-3树删除" class="headerlink" title="2-3树删除"></a>2-3树删除</h3><p>删除之前，先要对2-3树进行一次命中的查找，查找成功才可以进行删除操作。<br>删除节点大概分为3种情形</p><p>（1）删除非叶子节点。<br>（2）删除不为2-节点的叶子节点。<br>（3）删除为2-节点的叶子节点。</p><h4 id="删除非叶子节点"><a href="#删除非叶子节点" class="headerlink" title="删除非叶子节点"></a>删除非叶子节点</h4><p><strong>操作步骤：使用中序遍历下的直接后继节点key来覆盖当前待删除节点key，再删除用来覆盖的后继节点key。</strong></p><p><strong>图解：</strong><br><img src="https://diycode.b0.upaiyun.com/photo/2019/6aea6353a9c8e042c9f3fdf28c3cf2c6.png" alt="img"></p><h4 id="删除不为2-节点的叶子节点"><a href="#删除不为2-节点的叶子节点" class="headerlink" title="删除不为2-节点的叶子节点"></a>删除不为2-节点的叶子节点</h4><p>操作步骤：删除不为2-节点的叶子节点，直接删除节点即可。**</p><p><strong>图解：</strong><br><img src="https://diycode.b0.upaiyun.com/photo/2019/9eed47e91cdd721035760525f230f12c.png" alt="img"></p><h4 id="删除为2-节点的叶子节点"><a href="#删除为2-节点的叶子节点" class="headerlink" title="删除为2-节点的叶子节点"></a>删除为2-节点的叶子节点</h4><p>删除为2-节点的叶子节点的步骤相对复杂，删除节点后需要做出相应判断，并根据判断结果调整树结构。主要分为四种情形：</p><h5 id="删除节点为2-节点，父节点为2-节点，兄弟节点为3-节点"><a href="#删除节点为2-节点，父节点为2-节点，兄弟节点为3-节点" class="headerlink" title="删除节点为2-节点，父节点为2-节点，兄弟节点为3-节点"></a>删除节点为2-节点，父节点为2-节点，兄弟节点为3-节点</h5><p><strong>操作步骤：当前待删除节点的父节点是2-节点、兄弟节点是3-节点，将父节点移动到当前待删除节点位置，再将兄弟节点中最接近当前位置的key移动到父节点中。</strong></p><p><strong>图解：</strong><br><img src="https://diycode.b0.upaiyun.com/photo/2019/caa28467e8dcb3bf694a322263512500.png" alt="img"></p><h5 id="删除节点为2-节点，父节点为2-节点，兄弟节点为2-节点"><a href="#删除节点为2-节点，父节点为2-节点，兄弟节点为2-节点" class="headerlink" title="删除节点为2-节点，父节点为2-节点，兄弟节点为2-节点"></a>删除节点为2-节点，父节点为2-节点，兄弟节点为2-节点</h5><p><strong>操作步骤：当前待删除节点的父节点是2-节点、兄弟节点也是2-节点，先通过移动兄弟节点的中序遍历直接后驱到兄弟节点，以使兄弟节点变为3-节点；再进行6.3.1的操作。</strong></p><p><strong>图解：</strong></p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/aaea050b8cd1be3572097b35a04e8926.png" alt="img"><br><img src="https://diycode.b0.upaiyun.com/photo/2019/fd41e34febe4651d4f9ca5d53c1325dc.png" alt="img"></p><h5 id="删除节点为2-节点，父节点为3-节点"><a href="#删除节点为2-节点，父节点为3-节点" class="headerlink" title="删除节点为2-节点，父节点为3-节点"></a>删除节点为2-节点，父节点为3-节点</h5><p><strong>操作步骤：当前待删除节点的父节点是3-节点，拆分父节点使其成为2-节点，再将再将父节点中最接近的一个拆分key与中孩子合并，将合并后的节点作为当前节点。</strong></p><p><strong>图解：</strong><br><img src="https://diycode.b0.upaiyun.com/photo/2019/ba52aba6e18ae595ee9aa499523f9d4d.png" alt="img"></p><h5 id="2-3树为满二叉树，删除叶子节点"><a href="#2-3树为满二叉树，删除叶子节点" class="headerlink" title="2-3树为满二叉树，删除叶子节点"></a>2-3树为满二叉树，删除叶子节点</h5><p><strong>操作步骤：若2-3树是一颗满二叉树，将2-3树层树减少，并将当前删除节点的兄弟节点合并到父节点中，同时将父节点的所有兄弟节点合并到父节点的父节点中，如果生成了4-节点，再分解4-节点。</strong></p><p><strong>图解：</strong><br><img src="https://diycode.b0.upaiyun.com/photo/2019/669908519dceaa20120985b6bfc5b0cf.png" alt="img"></p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>2-3 树作为一种平衡查找树，查询效率比普通的二叉排序树要稳定许多。但是2-3树需要维护两种不同类型的结点，查找和插入操作的实现需要大量的代码，而且它们所产生的额外开销可能会使算法比标准的二叉查找树更慢。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知否？知否？情人眼里出代码</title>
      <link href="/posts/74c8c47d/"/>
      <url>/posts/74c8c47d/</url>
      
        <content type="html"><![CDATA[<p>今天是  <strong>0214</strong> ，打乱一下数字就是 <strong>1024</strong>，程序员最喜欢的一个数字之一。</p><p>当然，除此之外，今天也是一年一度的 <strong>情人节</strong>。</p><p>这个日子肯定少不了表白。那程序员怎么去表白？当然是 <strong>写—代—码</strong>！</p><p>每到情人节，脑洞大开的程序员们就纷纷出动，想出了各种别出心裁的表白代码。虽然结局不一定美好，但这些也是一种撩妹手段。</p><h3 id="从古"><a href="#从古" class="headerlink" title="从古"></a>从古</h3><p><strong>采葛: 一日不见，如三月兮</strong></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1g04l8eup3lj30sy0e8mzd.jpg" alt="彼采葛兮，一日不见，如三月兮"></p><p><strong>顾城 ：《门前》</strong></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1g04l45v4xvj316k0km77y.jpg" alt="门前"></p><h3 id="至今"><a href="#至今" class="headerlink" title="至今"></a>至今</h3><p><strong>春风十里不如你</strong></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1g04l475790j30uy0i2jtp.jpg" alt="春风十里不如你"></p><p><strong>舒婷：致橡树</strong></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1g04m4gbfjmj30uz0u0gyv.jpg" alt="致橡树"></p><p>### </p><h3 id="一见钟情"><a href="#一见钟情" class="headerlink" title="一见钟情"></a>一见钟情</h3><p><strong>一见钟情，相濡以沫，不忘初心，真爱永恒</strong></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1g04lmmmkdhj30tk0i276n.jpg" alt="一见钟情，相濡以沫，不忘初心，真爱永恒"></p><p><strong>直到死之前，每天爱你多一点</strong></p><p>  <img src="https://ws1.sinaimg.cn/large/006tNc79gy1g04kw9bqa0j30hq0bowff.jpg" alt="直到死之前，每天爱你多一点"></p><h3 id="爱你一万年"><a href="#爱你一万年" class="headerlink" title="爱你一万年"></a>爱你一万年</h3><p><strong>爱你爱到天荒地老</strong></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1g04l5fjvwbj30sk0bojsu.jpg" alt="爱你爱到天荒地老"></p><p><strong>山无陵， 江水为竭， 冬雷震震， 夏雨雪， 天地合， 乃敢与君绝！</strong></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1g04ljgxa5bj31g00jcq6x.jpg" alt="山无陵， 江水为竭， 冬雷震震， 夏雨雪， 天地合， 乃敢与君绝！"></p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法科普：有趣的游程编码</title>
      <link href="/posts/f20cf9ac/"/>
      <url>/posts/f20cf9ac/</url>
      
        <content type="html"><![CDATA[<p>​    </p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1g04j23vtvyj30p00andkv.jpg" alt="游程编码"></p><p>在这个大数据时代，我们保存的数据量有时候往往是非常庞大的，存储它将会耗费非常多的内存，读取速度也相对减慢了。</p><p>因此常常需要对数据进行压缩编码存储，等到要用到这个数据的时候再解压缩就行，这样不仅可以节约大量的存储空间，而且节省了系统读取和反应的时间。</p><p>栅格数据压缩编码的方法有很多种，包括链式编码、行程编码、块式编码和四叉树编码。今天我们就来讲一下行程编码（也叫游程编码）。</p><p>首先从一个简单的例子开始：编码一个在  5 * 5 方块上使用三种颜色绘制的图像。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1g03y4jdn48j31gm0tewg4.jpg" alt="图 1"></p><p>根据方块不同的颜色匹配不同的字母。这里使用 <strong>Y</strong> 代表黄色，使用 <strong>G</strong> 代表绿色，使用 <strong>B</strong> 代表蓝色。</p><p>那么，根据这样的规则，图 1 的图形编码就变成了 25 个字母，如图 2 所示。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1g03y89g99gj31go0taabl.jpg" alt="图 2"></p><p>接下来，我们通过使用 <strong>游程编码</strong> 的方式来表示这个图像，以便使用 25 个字符以下的字符来表示。</p><p><strong>游程编码是一种将代码和重复的次数作为一组来编码的方法。</strong></p><p>例如，我们可以通过将第一个 “YYYY” 的部分表示未 “Y4”，这样就可以将其 <strong>缩短两个字符</strong> 。</p><p>按照这种操作，图 2 的 25 个字符就能缩短为 20 个字符了。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1g03ye9nrtrg30qb0er0yk.gif" alt="动图 3"></p><p>这样，如果我们知道每行有 5 个方块，原始图像就可以从代码中提取出来了。这种还原的操作也就是我们俗称的 <strong>解压</strong>。</p><p>当然，游程编码也不是万能的，它也有它的适用性与局限性。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1g03yhf9he1j31gs0ti0uj.jpg" alt="图 4"></p><p>观察图 4 的图像与对应的代码，可以发现：虽然使用 <strong>游程编码</strong> 使得总体的字符数减少，但对于那些不具备相同颜色的部分，在进行游程编码后，字符数反而会增加。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1g03yjnvkzdj31gs0to0up.jpg" alt="图 5"></p><p>特别的，如果对连续性极其差的数据进行游程编码，字符数不减反增：数据翻倍到 50 个字符了。</p><p>当然，对于具有连续性的数据进行游程编码，那压缩量就十分可观了。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1g03ynh4hb1j31h60tsjss.jpg" alt="图 6"></p><p>因此，根据要编码的数据，游程编码可能具有压缩效果，也可能不具有压缩效果。</p><p>所以，对一定数量连续的数据使用游程编码才是正确的使用时机。</p><p>再举个例子，考虑一下在单色传单上使用游程编码。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1g03yqg0i2hg30qb0erq7f.gif" alt="动图 7"></p><p>如动图 7 所示，使用 W （White）和 B（Black）字母来表示每个方块。</p><p>按照这样的逻辑，一开始只需要 25 个字符就能表示完毕。</p><p>如果使用 <strong>游程编码</strong>，那么最终的表达结果是需要 26 个字符表示。所以，在这种情况下，使用  <strong>游程编码</strong> 是没有意义的。</p><p>但仔细观察，在黑白图像中仅仅使用了黑和白这两种颜色。因此，在连续的白色方块之后必定出现的是黑色方块。那么即使没有字母 W 和字母 B，依旧可以通过代码还原恢复图像。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1g03yvjaqqhj31g00tqtak.jpg" alt="图 8"></p><p>如图 8 所示，通过省略字母 W 和字母 B，仅仅只需要 13 个字符就能表示图像，相对于之前的需要 26 个字符表示压缩了一半的大小。</p><p>当然，这样显示是有一个要求的，那就是 <strong>代码的第一个数字必须是白色方块的连续数</strong>。只有使用了这个规则，才能通过代码还原出之前的图像。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1g03yzth26pj31h40ts40c.jpg" alt="图 9"></p><p>所以，对于图 9 这种开头是黑色方块的图像的代码，需要在代码的开头处添加 0 ，这样就也遵守了 <strong>代码的第一个数字必须是白色方块的连续数</strong>这条规则。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生活中用过的那些高级算法知识</title>
      <link href="/posts/a0e8c677/"/>
      <url>/posts/a0e8c677/</url>
      
        <content type="html"><![CDATA[<h3 id="打牌排序"><a href="#打牌排序" class="headerlink" title="打牌排序"></a>打牌排序</h3><p>绝大部分小伙伴在打牌的时候使用 插入排序，而我就不一样，带四个桶去打牌！！！</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzrvalqxjdg30nk0d8do4.gif" alt=""></p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>前几天去交房租，房东突然问我：</p><p>小吴呀，你是程序员，问你个问题哈，我孩子的玩具现在多起来了，弄的满屋子都是，然后他要玩什么玩具又找不到，一直在哇哇叫，能不能通过算法的知识去解决这个问题？</p><p>这难不倒我。根据小孩子的习惯，他们一般会集中喜欢玩某些玩具，这样你可以专门拿一个箱子作为“缓存”，把最近玩的玩具都往里放，这样好找，只要当“缓存”满了的时候做分类就好了。</p><p>房东笑而不语，推开门。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzrvamnvj7g306v057qv5.gif" alt="缓存"></p><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>昨天去书店挑选要送的书，抱着一堆书出来，可能有一本没有消磁，于是警报响了。</p><p>我一本一本拿出来靠近警报看到底是哪一本。。。</p><p>保安大哥一把抢过来，鄙视的看着我，然后把所有的书分成两堆，果然只有一堆警报会响，然后把响的那一堆再分成两堆。。。log(N)的时间找出了没消磁的那本。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzrvmlnuxhg305k05ktyb.gif" alt="二分法"></p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>总算抢到火车票了，出发的时候发现票不见了，我打开行李箱查找，结果半天找不到，同行的朋友就喷我：票放哪了你心里没点 B 树。我一想，说的对呀，我可以用 B 树来查找，结果还是不知道怎么找。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzrvapv4ysj30al03odfs.jpg" alt="B树"></p><h3 id="蒙特卡洛"><a href="#蒙特卡洛" class="headerlink" title="蒙特卡洛"></a>蒙特卡洛</h3><p>后来，我想起了我的票可能落在厕所。于是我决定用蒙特卡洛的方法在同样的位置随机模拟车票滑落，仔细观察路径。</p><p>我先取出回广州的车票，松手，就看它飘进了路边的下水道。</p><p>就这样，我付出两张车票的代价，终于明白，无风时在那个地方掉火车票，它会落进下水道。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzrw2u9u3xg30aw0aiu0x.gif" alt="蒙特卡洛"></p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> 新手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解什么是平衡二叉树（AVL）</title>
      <link href="/posts/65aa991e/"/>
      <url>/posts/65aa991e/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>Wiki:在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">计算机科学</a>中，<strong>AVL树</strong>是最早被发明的<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91" target="_blank" rel="noopener">自平衡二叉查找树</a>。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为<strong>高度平衡树</strong>。查找、插入和删除在平均和最坏情况下的<a href="https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" target="_blank" rel="noopener">时间复杂度</a>都是 O(logn）。增加和删除元素的操作则可能需要借由一次或多次<a href="https://zh.wikipedia.org/wiki/%E6%A0%91%E6%97%8B%E8%BD%AC" target="_blank" rel="noopener">树旋转</a>，以实现树的重新平衡。AVL 树得名于它的发明者 <a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%A5%A5%E5%B0%94%E5%90%89%C2%B7%E9%98%BF%E6%9D%B0%E5%B0%94%E6%9D%BE-%E9%9F%A6%E5%88%A9%E6%96%AF%E5%9F%BA" target="_blank" rel="noopener">G. M. Adelson-Velsky</a> 和 <a href="https://zh.wikipedia.org/w/index.php?title=Evgenii_Landis&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">Evgenii Landis</a>，他们在1962年的论文《An algorithm for the organization of information》中公开了这一数据结构。</p></blockquote><h3 id="1-为什么要有平衡二叉树"><a href="#1-为什么要有平衡二叉树" class="headerlink" title="1 为什么要有平衡二叉树"></a>1 为什么要有平衡二叉树</h3><p>二叉搜索树一定程度上可以提高搜索效率，但是当原序列有序时，例如序列 A = {1，2，3，4，5，6}，构造二叉搜索树如图 1.1。依据此序列构造的二叉搜索树为右斜树，同时二叉树退化成单链表，搜索效率降低为 O(n)。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzofsmoafpj31hc0u0t8y.jpg" alt="图 1.1"></p><p>在此二叉搜索树中查找元素 6 需要查找 6 次。</p><p>二叉搜索树的查找效率取决于树的高度，因此保持树的高度最小，即可保证树的查找效率。同样的序列 A，将其改为图 1.2 的方式存储，查找元素 6 时只需比较 3 次，查找效率提升一倍。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzofyo9w0wj31k60mcjrg.jpg" alt="图 1.2"></p><p>可以看出当节点数目一定，保持树的左右两端保持平衡，树的查找效率最高。</p><p><strong>这种左右子树的高度相差不超过 1 的树为平衡二叉树。</strong></p><h3 id="2-定义"><a href="#2-定义" class="headerlink" title="2. 定义"></a>2. 定义</h3><p><strong>平衡二叉查找树</strong>：简称平衡二叉树。由前苏联的数学家 <strong>A</strong>delse-<strong>V</strong>elskil 和 <strong>L</strong>andis 在 1962 年提出的高度平衡的二叉树，根据科学家的英文名也称为 AVL 树。它具有如下几个性质：</p><ol><li>可以是空树。</li><li>假如不是空树，任何一个节点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。</li></ol><p>平衡之意，如天平，即两边的分量大约相同。</p><p>例如图 2.1 不是平衡二叉树，因为节点 60 的左子树不是平衡二叉树。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzogeu6pn5j31ke0nyq35.jpg" alt="图 2.1"></p><p>图 2.2 也不是平衡二叉树，因为虽然任何一个节点的左子树与右子树都是平衡二叉树，但高度之差已经超过 1 。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzogewh2naj31kc0n6t8w.jpg" alt="图 2.2"></p><p>图 2.3 是平衡二叉树。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzqme36qn7j31h40rmac6.jpg" alt="图 2.3"></p><h3 id="3-平衡因子"><a href="#3-平衡因子" class="headerlink" title="3. 平衡因子"></a>3. 平衡因子</h3><p><strong>定义：</strong>某节点的左子树与右子树的高度(深度)差即为该节点的平衡因子（BF,Balance Factor），平衡二叉树中不存在平衡因子大于 1 的节点。在一棵平衡二叉树中，节点的平衡因子只能取 0 、1 或者 -1 ，分别对应着左右子树等高，左子树比较高，右子树比较高。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzogqxlo4zj31k80lc3yl.jpg" alt="图 3.1"></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzogscuvtzj31jy0kwaa5.jpg" alt="图 3.2"></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzogsc9r7xj31jw0laglp.jpg" alt="图 3.3"></p><h3 id="4-节点结构"><a href="#4-节点结构" class="headerlink" title="4. 节点结构"></a>4. 节点结构</h3><p>定义平衡二叉树的节点结构：</p><pre class=" language-c++"><code class="language-c++">typedef struct AVLNode *Tree;typedef int ElementType;struct AVLNode{    int depth; //深度，这里计算每个节点的深度，通过深度的比较可得出是否平衡    Tree parent; //该节点的父节点    ElementType val; //节点值    Tree lchild;    Tree rchild;    AVLNode(int val=0) {        parent = NULL;        depth = 0;        lchild = rchild = NULL;        this->val=val;    }};</code></pre><h3 id="5-AVL树插入时的失衡与调整"><a href="#5-AVL树插入时的失衡与调整" class="headerlink" title="5. AVL树插入时的失衡与调整"></a>5. AVL树插入时的失衡与调整</h3><p>图 5.1 是一颗平衡二叉树</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzolcmx1qqj31b00g6glk.jpg" alt="图 5.1 "></p><p>在此平衡二叉树插入节点 99 ，树结构变为： </p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzolopfxzxg30q60be41k.gif" alt="动图 5.2"></p><p>在动图 5.2 中，节点 66 的左子树高度为 1，右子树高度为 3，此时平衡因子为 -2，树失去平衡。</p><p>在动图 5.2 中，以节点 66 为父节点的那颗树就称为 <strong>最小失衡子树</strong>。</p><p><strong>最小失衡子树</strong>：在新插入的节点向上查找，以第一个平衡因子的<strong>绝对值</strong>超过 1 的节点为根的子树称为最小不平衡子树。也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的。而这个时候，我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。</p><p><strong>平衡二叉树的失衡调整主要是通过旋转最小失衡子树来实现的</strong>。根据旋转的方向有两种处理方式，<strong>左旋</strong> 与 <strong>右旋</strong> 。</p><p>旋转的目的就是减少高度，通过降低整棵树的高度来平衡。哪边的树高，就把那边的树向上旋转。</p><h4 id="5-1-左旋"><a href="#5-1-左旋" class="headerlink" title="5.1 左旋"></a>5.1 左旋</h4><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzolu39ojoj31gw0lumx9.jpg" alt="图 5.1.1"></p><p>以图 5.1.1 为例，加入新节点 99 后， 节点 66 的左子树高度为 1，右子树高度为 3，此时平衡因子为 -2。为保证树的平衡，此时需要对节点 66 做出旋转，因为右子树高度高于左子树，对节点进行左旋操作，流程如下：</p><p>（1）节点的右孩子替代此节点位置<br>（2）右孩子的左子树变为该节点的右子树<br>（3）节点本身变为右孩子的左子树</p><p>整个操作流程如动图 5.1.2 所示。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzom2pmmr5g30q50ekdiy.gif" alt="动图 5.1.2"></p><ul><li>节点的右孩子替代此节点位置 —— 节点 66 的右孩子是节点 77 ，将节点 77 代替节点 66 的位置</li><li>右孩子的左子树变为该节点的右子树 —— 节点 77 的左子树为节点 75，将节点 75 挪到节点 66 的右子树位置</li><li>节点本身变为右孩子的左子树 —— 节点 66 变为了节点 77 的左子树</li></ul><h4 id="5-2-右旋"><a href="#5-2-右旋" class="headerlink" title="5.2 右旋"></a>5.2 右旋</h4><p>右旋操作与左旋类似，操作流程为：</p><p>（1）节点的左孩子代表此节点<br>（2）节点的左孩子的右子树变为节点的左子树<br>（3）将此节点作为左孩子节点的右子树。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzomfzo5eag30q50ek40u.gif" alt="动图 5.2.1"></p><h3 id="6-AVL树的四种插入节点方式"><a href="#6-AVL树的四种插入节点方式" class="headerlink" title="6. AVL树的四种插入节点方式"></a>6. AVL树的四种插入节点方式</h3><p>假设一颗 AVL 树的某个节点为 A，有四种操作会使 A 的左右子树高度差大于 1，从而破坏了原有 AVL 树的平衡性。平衡二叉树插入节点的情况分为以下四种：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzqpwcjzy5j318i0akq3t.jpg" alt="图 6.0"></p><p>具体分析如下：</p><h4 id="6-1-A的左孩子的左子树插入节点-LL"><a href="#6-1-A的左孩子的左子树插入节点-LL" class="headerlink" title="6.1 A的左孩子的左子树插入节点(LL)"></a>6.1 A的左孩子的左子树插入节点(LL)</h4><p>只需要执行一次右旋即可。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzomzssf3ng30q50ekmyt.gif" alt="动图 6.1"></p><p>实现代码如下：</p><pre class=" language-c++"><code class="language-c++">//LL型调整函数//返回:新父节点Tree LL_rotate(Tree node){    //node为离操作节点最近的失衡的节点    Tree parent=NULL,son;    //获取失衡节点的父节点    parent=node->parent;    //获取失衡节点的左孩子    son=node->lchild;    //设置son节点右孩子的父指针    if (son->rchild!=NULL)  son->rchild->parent=node;    //失衡节点的左孩子变更为son的右孩子    node->lchild=son->rchild;    //更新失衡节点的高度信息    update_depth(node);    //失衡节点变成son的右孩子    son->rchild=node;    //设置son的父节点为原失衡节点的父节点    son->parent=parent;    //如果失衡节点不是根节点，则开始更新父节点    if (parent!=NULL){        //如果父节点的左孩子是失衡节点，指向现在更新后的新孩子son        if (parent->lchild==node){            parent->lchild=son;        }else{             //父节点的右孩子是失衡节点              parent->rchild=son;        }     }    //设置失衡节点的父亲    node->parent=son;    //更新son节点的高度信息    update_depth(son);    return son;}</code></pre><h4 id="6-2-A的右孩子的右子树插入节点-RR"><a href="#6-2-A的右孩子的右子树插入节点-RR" class="headerlink" title="6.2 A的右孩子的右子树插入节点(RR)"></a>6.2 A的右孩子的右子树插入节点(RR)</h4><p>只需要执行一次左旋即可。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzonjzgewgg30q50ek0uh.gif" alt="动图 6.2"></p><p>实现代码如下：</p><pre class=" language-c++"><code class="language-c++">//RR型调整函数//返回新父节点Tree RR_rotate(Tree node){    //node为离操作节点最近的失衡的节点    Tree parent=NULL,son;    //获取失衡节点的父节点    parent=node->parent;    //获取失衡节点的右孩子    son=node->rchild;    //设置son节点左孩子的父指针    if (son->lchild!=NULL){          son->lchild->parent=node;    }    //失衡节点的右孩子变更为son的左孩子    node->rchild=son->lchild;    //更新失衡节点的高度信息    update_depth(node);    //失衡节点变成son的左孩子    son->lchild=node;    //设置son的父节点为原失衡节点的父节点    son->parent=parent;    //如果失衡节点不是根节点，则开始更新父节点    if (parent!=NULL){        //如果父节点的左孩子是失衡节点，指向现在更新后的新孩子son        if (parent->lchild==node){            parent->lchild=son;        }else{            //父节点的右孩子是失衡节点            parent->rchild=son;        }     }    //设置失衡节点的父亲    node->parent=son;    //更新son节点的高度信息    update_depth(son);    return son;}</code></pre><h4 id="6-3-A的左孩子的右子树插入节点-LR"><a href="#6-3-A的左孩子的右子树插入节点-LR" class="headerlink" title="6.3 A的左孩子的右子树插入节点(LR)"></a>6.3 A的左孩子的右子树插入节点(LR)</h4><p>若 A 的左孩子节点 B 的右子树 E 插入节点 F ，导致节点 A 失衡，如图：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzonocvbarj31gm0k4jrh.jpg" alt="图 6.3"></p><p>A 的平衡因子为 2 ，若仍按照右旋调整，则变化后的图形为这样：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzonqswj1cj31gy0j074a.jpg" alt="图 6.3.1"></p><p>经过右旋调整发现，调整后树仍然失衡，说明这种情况单纯的进行右旋操作不能使树重新平衡。那么这种插入方式需要执行两步操作，使得旋转之后为 <strong>原来根节点的左孩子的右孩子作为新的根节点</strong>。</p><p>（1）对失衡节点 A 的左孩子 B 进行左旋操作，即上述 RR 情形操作。<br>（2）对失衡节点 A 做右旋操作，即上述 LL 情形操作。</p><p>调整过程如下：</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzoo8glkatj31gq0l0t8v.jpg" alt="图 6.3.2"></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzoo8g596dj31gw0jit8t.jpg" alt="图 6.3.3"></p><p>也就是说，经过这两步操作，使得 <strong>原来根节点的左孩子的右孩子 E 节点成为了新的根节点</strong>。</p><p>代码实现：</p><pre class=" language-c++"><code class="language-c++">//LR型，先左旋转，再右旋转//返回：新父节点Tree LR_rotate(Tree node){    RR_rotate(node->lchild);    return LL_rotate(node);}</code></pre><h4 id="6-4-A的右孩子的左子树插入节点-RL"><a href="#6-4-A的右孩子的左子树插入节点-RL" class="headerlink" title="6.4 A的右孩子的左子树插入节点(RL)"></a>6.4 A的右孩子的左子树插入节点(RL)</h4><p>右孩子插入左节点的过程与左孩子插入右节点过程类似，也是需要执行两步操作，使得旋转之后为 <strong>原来根节点的右孩子的左孩子作为新的根节点</strong>。</p><p>（1）对失衡节点 A 的右孩子 C 进行右旋操作，即上述 LL 情形操作。<br>（2）对失衡节点 A 做左旋操作，即上述 RR 情形操作。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzqmh6y5ohj31me0mc3yl.jpg" alt="图 6.4"></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzooj35wnqj31gs0jsmxb.jpg" alt="图 6.4.1"></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzooj2th5lj31gc0jqwel.jpg" alt="图 6.4.2"></p><p>也就是说，经过这两步操作，使得 <strong>原来根节点的右孩子的左孩子 D 节点成为了新的根节点</strong>。</p><p>代码实现：</p><pre class=" language-c++"><code class="language-c++">//RL型，先右旋转，再左旋转//返回:新父节点Tree RL_rotate(Tree node){    LL_rotate(node->rchild);    return RR_rotate(node);}</code></pre><p><strong>补充</strong>：</p><p>上述四种插入方式的代码实现的辅助代码如下：</p><pre class=" language-c++"><code class="language-c++">//更新当前深度void update_depth(Tree node){    if (node==NULL){        return;    }else{        int depth_Lchild=get_balance(node->lchild); //左孩子深度        int depth_Rchild=get_balance(node->rchild); //右孩子深度        node->depth=max(depth_Lchild,depth_Rchild)+1;    }}//获取当前节点的深度int get_balance(Tree node){    if (node==NULL){         return 0;    }    return node->depth;}//返回当前平衡因子int is_balance(Tree node){    if (node==NULL){         return 0;    }else{         return get_balance(node->lchild)-get_balance(node->rchild);     }}</code></pre><h4 id="6-5-小总结"><a href="#6-5-小总结" class="headerlink" title="6.5 小总结"></a>6.5 小总结</h4><ol><li>在所有的不平衡情况中，都是按照先 <strong>寻找最小不平衡树</strong>，然后 <strong>寻找所属的不平衡类别</strong>，再 <strong>根据 4 种类别进行固定化程序的操作</strong>。</li><li>LL , LR ，RR ，RL其实已经为我们提供了最后哪个节点作为新的根指明了方向。如 LR 型最后的根节点为原来的根的左孩子的右孩子，RL 型最后的根节点为原来的根的右孩子的左孩子。只要记住这四种情况，可以很快地推导出所有的情况。</li><li>维护平衡二叉树，最麻烦的地方在于平衡因子的维护。建议读者们根据小吴提供的图片和动图，自己动手画一遍，这样可以更加感性的理解操作。</li></ol><h3 id="7-AVL树的四种删除节点方式"><a href="#7-AVL树的四种删除节点方式" class="headerlink" title="7. AVL树的四种删除节点方式"></a>7. AVL树的四种删除节点方式</h3><p>AVL 树和二叉查找树的删除操作情况一致，都分为四种情况：</p><p>（1）删除叶子节点<br>（2）删除的节点只有左子树<br>（3）删除的节点只有右子树<br>（4）删除的节点既有左子树又有右子树</p><p>只不过 AVL 树在删除节点后需要重新<strong>检查平衡性并修正</strong>，同时，删除操作与插入操作后的平衡修正区别在于，插入操作后只需要对插入栈中的弹出的第一个非平衡节点进行修正，而删除操作需要修正栈中的所有非平衡节点。</p><p>删除操作的大致步骤如下：</p><ul><li>以前三种情况为基础尝试删除节点，并将访问节点入栈。</li><li>如果尝试删除成功，则依次检查栈顶节点的平衡状态，遇到非平衡节点，即进行旋转平衡，直到栈空。</li><li>如果尝试删除失败，证明是第四种情况。这时先找到被删除节点的右子树最小节点并删除它，将访问节点继续入栈。</li><li>再依次检查栈顶节点的平衡状态和修正直到栈空。</li></ul><p>对于删除操作造成的非平衡状态的修正，可以这样理解：对左或者右子树的删除操作相当于对右或者左子树的插入操作，然后再对应上插入的四种情况选择相应的旋转就好了。</p><h4 id="7-1-删除叶子节点"><a href="#7-1-删除叶子节点" class="headerlink" title="7.1 删除叶子节点"></a>7.1 删除叶子节点</h4><p>处理步骤：</p><p>  ①、将该节点直接从树中删除；</p><p>  ②、其父节点的子树高度的变化将导致父节点平衡因子的变化，通过向上检索并推算其父节点是否失衡；</p><p>  ③、如果其父节点未失衡，则继续向上检索推算其父节点的父节点是否失衡…如此反复②的判断，直到根节点 ；如果向上推算过程中发现了失衡的现象，则进行 ④ 的处理；</p><p>  ④、如果其父节点失衡，则判断是哪种失衡类型 [LL、LR、RR、RL] ，并对其进行相应的平衡化处理。如果平衡化处理结束后，发现与原来以父节点为根节点的树的高度发生变化，则继续进行 ② 的检索推算；如果与原来以父节点为根节点的高度一致时，则可说明父节点的父节点及祖先节点的平衡因子将不会有变化，因此可以退出处理；</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzqnvf8q5mg30qe0epach.gif" alt="动图 7.1.1"></p><p>具体数字演示：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzqne0cjl8g30qe0epdi7.gif" alt="动图 7.1"></p><h4 id="7-2-amp-7-3-删除的节点只有左子树或右子树"><a href="#7-2-amp-7-3-删除的节点只有左子树或右子树" class="headerlink" title="7.2  &amp; 7.3 删除的节点只有左子树或右子树"></a>7.2  &amp; 7.3 删除的节点只有左子树或右子树</h4><p>处理步骤：</p><p>  ①、将左子树（右子树）替代原有节点 C 的位置；</p><p>  ②、节点  C 被删除后，则以 C 的父节点  B 为起始推算点，依此向上检索推算各节点（父、祖先）是否失衡；</p><p>  ③、如果其父节点未失衡，则继续向上检索推算其父节点 的父节点 是否失衡…如此反复 ② 的判断，直到根节点 ；如果向上推算过程中发现了失衡的现象，则进行 ④ 的处理；</p><p> ④、如果其父节点失衡，则判断是哪种失衡类型 [LL、LR、RR、RL] ，并对其进行相应的平衡化处理。如果平衡化处理结束后，发现与原来以父节点为根节点的树的高度发生变化，则继续进行 ② 的检索推算；如果与原来以父节点为根节点的高度一致时，则可说明父节点的父节点及祖先节点的平衡因子将不会有变化，因此可以退出处理；</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzqovwao9xg30qe0epwfv.gif" alt="动图 7.2"></p><h4 id="7-4-删除的节点既有左子树又有右子树"><a href="#7-4-删除的节点既有左子树又有右子树" class="headerlink" title="7.4 删除的节点既有左子树又有右子树"></a>7.4 删除的节点既有左子树又有右子树</h4><p>处理步骤：</p><p>  ①、找到被删节点 B 和替代节点 BLR (节点 B 的前继节点或后继节点 —— 在此选择 <strong>前继</strong>)；</p><p>  ②、将替代节点 BLR 的值赋给节点 B ，再把替代节点 BLR 的左孩子 BLRL 替换替代节点 BLR 的位置；</p><p>  ③、以 BLR 的父节点 BL 为起始推算点，依此向上检索推算父节点或祖先节点是否失衡；</p><p>  ④、如果其父节点未失衡，则继续向上检索推算其父节点的父节点是否失衡…如此反复③的判断，直到根节点；如果向上推算过程中发现了失衡的现象，则进行⑤的处理；</p><p>  ⑤、如果其父节点失衡，则判断是哪种失衡类型  [LL、LR、RR、RL]  ，并对其进行相应的平衡化处理。如果平衡化处理结束后，发现与原来以父节点为根节点的树的高度发生变化，则继续进行 ② 的检索推算；如果与原来以父节点为根节点的高度一致时，则可说明父节点的父节点及祖先节点的平衡因子将不会有变化，因此可以退出处理；</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzqpk97lodg30qe0epju1.gif" alt="动图 7.4"></p><p>注：在这里，小吴并没有给出 AVL 的删除操作的代码，也没有给出平衡性修复的动画，因为我并不打算过多去讨论它，更复杂的删除操作过程将放在后续的 <strong>红黑树</strong> 中进行讨论。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过对 AVL 的插入操作和删除操作可以看出，平衡二叉树的优势在于不会出现普通二叉查找树的最差情况，即退化成链表结构，但为了保证高度平衡（对称），动态插入和删除的代价也随之增加。</p><p>AVL 的旋转问题看似复杂，但实际上如果你亲自用笔纸操作一下还是很好理解的。</p>]]></content>
      
      
      <categories>
          
          <category> 高级算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>啥是佩奇排名算法</title>
      <link href="/posts/17626341/"/>
      <url>/posts/17626341/</url>
      
        <content type="html"><![CDATA[<h3 id="佩奇排名介绍"><a href="#佩奇排名介绍" class="headerlink" title="佩奇排名介绍"></a>佩奇排名介绍</h3><p>佩奇排名是根据页面之间的链接结构计算页面的值的一种算法。下面我们通过动画来理解进行计算的具体流程。</p><p>假设一个正方形表示一个 WEB 页面，一个箭头表示一个页面之间的链接。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdce7fb77a8?w=2110&amp;h=1184&amp;f=png&amp;s=88799" alt="此图表明下面 3 页包含指向上面 1 页的链接"></p><p>在佩奇排名算法中，网页指向的链接越多，页面被确定为越重要。</p><p>因此，在这里，确定首页最重要。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdce863e479?w=958&amp;h=535&amp;f=gif&amp;s=29656" alt="确定首页最重要"></p><p>实际上，每个页面的重要性都是通过计算来量化的。</p><h4 id="基本的计算方法思想"><a href="#基本的计算方法思想" class="headerlink" title="基本的计算方法思想"></a>基本的计算方法思想</h4><p>1.未链接的页面分数为 1</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdce88b9013?w=1920&amp;h=1078&amp;f=png&amp;s=78229" alt="未链接的页面分数为 1"></p><p>2.有链接的页面得分为正在链接的页面的总得分</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdce8d11b44?w=1918&amp;h=1078&amp;f=png&amp;s=90471" alt=".有链接的页面得分为正在链接的页面的总得分"></p><p>3.当有多个网页的链接时，链接分数均匀分布</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdcea312ae5?w=958&amp;h=535&amp;f=gif&amp;s=74616" alt="链接分数均匀分布"></p><p>4.来自高度链接网页的链接具有很高的价值</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdceae34912?w=1914&amp;h=1088&amp;f=png&amp;s=91417" alt=""></p><p>该图中心页面有三个独立页面指向它的链接，所以它的分数是 3 。<br>首页有一个很大的分数，因为链接是从分数为 3 的页面指向它的。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd163c0dcd?w=958&amp;h=535&amp;f=gif&amp;s=118317" alt=""></p><p>在动画中的六个页面中，判断最上面的页面是最重要的页面—-这是佩奇排名的基本思想。</p><h4 id="基本的计算方法思想的循环问题"><a href="#基本的计算方法思想的循环问题" class="headerlink" title="基本的计算方法思想的循环问题"></a>基本的计算方法思想的循环问题</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd22e57fa0?w=1928&amp;h=1074&amp;f=png&amp;s=92132" alt=""></p><p>如果按照顺序来计算每个页面的分数时，那么就会出现问题：以这种方式计算，它将无限循环，并且在循环中的页面得分在任何地方都会很高。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd36452959?w=958&amp;h=535&amp;f=gif&amp;s=147796" alt=""></p><p>循环的问题可以通过“随机游走模型”的计算方法来解决。</p><h3 id="随机游走模型"><a href="#随机游走模型" class="headerlink" title="随机游走模型"></a>随机游走模型</h3><p>以小猪佩奇浏览网页为例。</p><p>小猪佩奇开始访问「五分钟学算法」中有趣的页面，那么从这个左下角页面开始。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd3662dfe4?w=958&amp;h=535&amp;f=gif&amp;s=270716" alt=""></p><p>它们跟随一个链接并移动到另外的一个页面，看了一些之后，发现不敢兴趣了，这样就停止了浏览。</p><p>然后，又一天，它在小吴的推荐下，在完全不同的页面进行浏览，跟随一个链接并移动到另外的一个页面，一旦失去兴趣就停止浏览。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd39f892f5?w=958&amp;h=535&amp;f=gif&amp;s=182307" alt=""></p><p><strong>像这样，重复从某个页面开始浏览，移动几页后便停止的操作</strong>，如果从互联网空间一侧进行观察，就像网页浏览的人：重复移动页面几次后传送到一个完全不同的页面。</p><h3 id="量化随机游走模型"><a href="#量化随机游走模型" class="headerlink" title="量化随机游走模型"></a>量化随机游走模型</h3><p>假设 <code>1 - α</code> 代表选择当前页面中的一个链接的概率。</p><p> <code>α</code>代表该人将传送到其他页面的概率。</p><p> <img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd3adbd09d?w=958&amp;h=535&amp;f=gif&amp;s=178680" alt=""></p><p> 现在用 随机游走模型 处理上述的循环问题。</p><p> <img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd46b0fdd4?w=958&amp;h=535&amp;f=gif&amp;s=373034" alt=""></p><p> 如果总页面访问次数达到1000次之后，使用百分比进行表示：<strong>那么这个值就表示“在某个时间点查看页面的概率”</strong>。</p><p> <img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd489adc67?w=958&amp;h=535&amp;f=gif&amp;s=97953" alt=""></p><h3 id="更实用的计算方法"><a href="#更实用的计算方法" class="headerlink" title="更实用的计算方法"></a>更实用的计算方法</h3><p> 如图所示，现在来尝试计算复杂的链接网络中每个页面的分数。</p><p> <img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd70aafd4b?w=1914&amp;h=1076&amp;f=png&amp;s=100553" alt=""></p><p> 现在均匀设置分数，使总分加起来为 1 。而后根据网页浏览者的移动，来计算每个页面的概率。</p><blockquote><p>移动 n 次时出现在 A 中的概率表示未 <code>PAn</code>，移动 n 次时出现在 B 中的概率表示未 <code>PBn</code>。</p></blockquote><p> 举一个例子，在移动 1 次之后求在 A 的概率 <code>PA 1</code>。</p><p> <img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd71168fcb?w=958&amp;h=535&amp;f=gif&amp;s=149470" alt=""></p><p> 在 C 选择移动的概率是 <code>1-α</code>。</p><p> 其中，移动到 A 的一种场景是，C 中的佩奇选择了移动而不是传送。另外，这里选择了 A 而不是 B 作为目的地。<br> 并且，根据上面的 <code>当有多个网页的链接时，链接分数均匀分布</code> 这条规则，从 A 或 B 选择 A 的概率是 0.5 。</p><p> <img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd7238f422?w=958&amp;h=535&amp;f=gif&amp;s=149537" alt=""></p><p> 因此，从 C 移动到 A 的概率是 <code>PC0 ✖️ （1-α） ✖️ 0.5</code>。</p><p> <img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd74811ed7?w=958&amp;h=535&amp;f=gif&amp;s=255773" alt="A 被选为传送目标的概率是 0.25"></p><p>A 被选为传送目标的概率是 0.25 ，根据前面的理论：在 A、B、C、D 中小佩奇选择传送的概率为 <code>α</code>。因此，通过传送移动到 A 的概率为 <code>α ✖️ 0.25</code>。<br> 所以，移动一次后在 A 的概率为<br> <code>PA1 = PC0 ✖️ （ 1 - α ) ✖️ 0.5  +  α ✖️ 0.25</code></p><p> 其中 <code>PC0 = 0.25</code> ， <code>α = 0.15</code>，代入计算后 <code>PA1 = 0.14375</code>。</p><p> 这样，通过计算后 B 、 C 、D 页的概率也更新了。</p><p> <img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd7d493022?w=1916&amp;h=1070&amp;f=png&amp;s=102999" alt="B 、 C 、D 页的概率也更新了"></p><p>上面在移动 1 次之后这四个页面的概率更新情况，根据上述相同的方法计算 2 次后小佩奇浏览在每个页面的概率。</p><p> <img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd83fa09b0?w=1924&amp;h=1078&amp;f=png&amp;s=103117" alt="移动 2 次后"></p><p>同样的，经过大量的移动，在每个页面上的概率逐渐趋于固定值。当数值固定是，计算也就完成了。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16872fdd9f21920c?w=1930&amp;h=1088&amp;f=png&amp;s=122405" alt=""></p><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3><p>佩奇排名就是这样一种通过访问概率代替链接的权重来计算的机制。</p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> 新手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看动画轻松理解「Trie树」</title>
      <link href="/posts/cb9dd1de/"/>
      <url>/posts/cb9dd1de/</url>
      
        <content type="html"><![CDATA[<h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><blockquote><p>Trie这个名字取自“retrieval”，检索，因为Trie可以只用一个前缀便可以在一部字典中找到想要的单词。<br>虽然发音与「Tree」一致，但为了将这种 字典树 与 普通二叉树 以示区别，程序员小吴一般读「Trie」尾部会重读一声，可以理解为读「TreeE」。</p></blockquote><p>Trie 树，也叫“字典树”。顾名思义，它是一个<strong>树形结构</strong>。它是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。</p><p>此外 Trie 树也称前缀树（因为某节点的后代存在共同的前缀，比如pan是panda的前缀）。</p><p>它的key都为字符串，能做到高效查询和插入，时间复杂度为O(k)，k为字符串长度，缺点是如果大量字符串没有共同前缀时很耗内存。</p><p><strong>它的核心思想就是通过最大限度地减少无谓的字符串比较，使得查询高效率，即「用空间换时间」，再利用共同前缀来提高查询效率。</strong></p><h3 id="Trie树的特点"><a href="#Trie树的特点" class="headerlink" title="Trie树的特点"></a>Trie树的特点</h3><p>假设有 5 个字符串，它们分别是：code，cook，five，file，fat。现在需要在里面多次查找某个字符串是否存在。如果每次查找，都是拿要查找的字符串跟这 5 个字符串依次进行字符串匹配，那效率就比较低，有没有更高效的方法呢？</p><p>如果将这 5 个字符串组织成下图的结构，从肉眼上扫描过去感官上是不是比查找起来会更加迅速。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/2/1680c049b54e82cd?w=1922&amp;h=1074&amp;f=png&amp;s=102217" alt="Trie树样子"></p><p>通过上图，可以发现 Trie树 的三个特点：</p><ul><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串</li><li>每个节点的所有子节点包含的字符都不相同</li></ul><p>通过动画理解 Trie 树构造的过程。在构造过程中的每一步，都相当于往 Trie 树中插入一个字符串。当所有字符串都插入完成之后，Trie 树就构造好了。<br> <img src="https://user-gold-cdn.xitu.io/2019/1/2/1680c049b5365880?w=957&amp;h=536&amp;f=gif&amp;s=125312" alt=" Trie 树构造"></p><h3 id="Trie树的插入操作"><a href="#Trie树的插入操作" class="headerlink" title="Trie树的插入操作"></a>Trie树的插入操作</h3><p><img src="https://user-gold-cdn.xitu.io/2019/1/2/1680c049b51f4db2?w=957&amp;h=536&amp;f=gif&amp;s=223535" alt="Trie树的插入操作"></p><p>Trie树的插入操作很简单，其实就是将单词的每个字母逐一插入 Trie树。插入前先看字母对应的节点是否存在，存在则共享该节点，不存在则创建对应的节点。比如要插入新单词<code>cook</code>，就有下面几步：</p><ul><li>插入第一个字母 <code>c</code>，发现 <code>root</code> 节点下方存在子节点 <code>c</code>，则共享节点 <code>c</code></li><li>插入第二个字母 <code>o</code>，发现 <code>c</code> 节点下方存在子节点 <code>o</code>，则共享节点 <code>o</code></li><li>插入第三个字母 <code>o</code>，发现 <code>o</code> 节点下方不存在子节点 <code>o</code>，则创建子节点 <code>o</code></li><li>插入第三个字母 <code>k</code>，发现 <code>o</code> 节点下方不存在子节点 <code>k</code>，则创建子节点 <code>k</code></li><li>至此，单词 <code>cook</code> 中所有字母已被插入 Trie树 中，然后设置节点 <code>k</code> 中的标志位，标记路径 <code>root-&gt;c-&gt;o-&gt;o-&gt;k</code>这条路径上所有节点的字符可以组成一个单词<code>cook</code></li></ul><h3 id="Trie树的查询操作"><a href="#Trie树的查询操作" class="headerlink" title="Trie树的查询操作"></a>Trie树的查询操作</h3><p>在 Trie 树中查找一个字符串的时候，比如查找字符串 <code>code</code>，可以将要查找的字符串分割成单个的字符 c，o，d，e，然后从 Trie 树的根节点开始匹配。如图所示，绿色的路径就是在 Trie 树中匹配的路径。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/2/1680c049b57767ae?w=1928&amp;h=1084&amp;f=png&amp;s=149652" alt="code的匹配路径"></p><p>如果要查找的是字符串<code>cod</code>(鳕鱼)呢？还是可以用上面同样的方法，从根节点开始，沿着某条路径来匹配，如图所示，绿色的路径，是字符串<code>cod</code>匹配的路径。但是，路径的最后一个节点「d」并不是橙色的，并不是单词标志位，所以<code>cod</code>字符串不存在。也就是说，<code>cod</code>是某个字符串的前缀子串，但并不能完全匹配任何字符串。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/2/1680c049b7443080?w=1920&amp;h=1082&amp;f=png&amp;s=138065" alt="cod的匹配路径"></p><blockquote><p>程序员不要当一条咸鱼，要向 <code>cook</code> 靠拢：）</p></blockquote><h3 id="Trie树的删除操作"><a href="#Trie树的删除操作" class="headerlink" title="Trie树的删除操作"></a>Trie树的删除操作</h3><p>Trie树的删除操作与二叉树的删除操作有类似的地方，需要考虑删除的节点所处的位置，这里分三种情况进行分析：</p><h4 id="删除整个单词（比如hi）"><a href="#删除整个单词（比如hi）" class="headerlink" title="删除整个单词（比如hi）"></a>删除整个单词（比如<code>hi</code>）</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/2/1680c049b68802a6?w=957&amp;h=536&amp;f=gif&amp;s=177162" alt="删除整个单词"></p><ul><li>从根节点开始查找第一个字符<code>h</code></li><li>找到<code>h</code>子节点后，继续查找<code>h</code>的下一个子节点<code>i</code></li><li><code>i</code>是单词<code>hi</code>的标志位，将该标志位去掉</li><li><code>i</code>节点是<code>hi</code>的叶子节点，将其删除</li><li>删除后发现<code>h</code>节点为叶子节点，并且不是单词标志位，也将其删除</li><li>这样就完成了<code>hi</code>单词的删除操作</li></ul><h4 id="删除前缀单词（比如cod）"><a href="#删除前缀单词（比如cod）" class="headerlink" title="删除前缀单词（比如cod）"></a>删除前缀单词（比如<code>cod</code>）</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/2/1680c04a41644ab1?w=957&amp;h=536&amp;f=gif&amp;s=193343" alt="删除前缀单词"><br>这种方式删除比较简单。<br>只需要将<code>cod</code>单词整个字符串查找完后，<code>d</code>节点因为不是叶子节点，只需将其单词标志去掉即可。</p><h4 id="删除分支单词（比如cook）"><a href="#删除分支单词（比如cook）" class="headerlink" title="删除分支单词（比如cook）"></a>删除分支单词（比如<code>cook</code>）</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/2/1680c04a415421ef?w=957&amp;h=536&amp;f=gif&amp;s=173918" alt="删除分支单词"><br>与 <strong>删除整个单词</strong> 情况类似，区别点在于删除到 <code>cook</code> 的第一个 <code>o</code> 时，该节点为非叶子节点，停止删除，这样就完成<code>cook</code>字符串的删除操作。</p><h3 id="Trie树的应用"><a href="#Trie树的应用" class="headerlink" title="Trie树的应用"></a>Trie树的应用</h3><p>事实上 Trie树 在日常生活中的使用随处可见，比如这个：</p><p>具体来说就是经常用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。</p><h4 id="1-前缀匹配"><a href="#1-前缀匹配" class="headerlink" title="1. 前缀匹配"></a>1. 前缀匹配</h4><p>例如：找出一个字符串集合中所有以 <code>五分钟</code> 开头的字符串。我们只需要用所有字符串构造一个 trie树，然后输出以 五−&gt;分−&gt;钟 开头的路径上的关键字即可。</p><p>trie树前缀匹配常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/2/1680c04a4167a729?w=1430&amp;h=1210&amp;f=png&amp;s=392579" alt="google搜索"></p><h4 id="2-字符串检索"><a href="#2-字符串检索" class="headerlink" title="2. 字符串检索"></a>2. 字符串检索</h4><p>给出 N 个单词组成的熟词表，以及一篇全用小写英文书写的文章，按最早出现的顺序写出所有不在熟词表中的生词。</p><p>检索/查询功能是Trie树最原始的功能。给定一组字符串，查找某个字符串是否出现过，思路就是从根节点开始一个一个字符进行比较：</p><ul><li>如果沿路比较，发现不同的字符，则表示该字符串在集合中不存在。</li><li>如果所有的字符全部比较完并且全部相同，还需判断最后一个节点的标志位（标记该节点是否代表一个关键字）。</li></ul><h3 id="Trie树的局限性"><a href="#Trie树的局限性" class="headerlink" title="Trie树的局限性"></a>Trie树的局限性</h3><p>如前文所讲，Trie的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。</p><p>假设字符的种数有<code>m</code>个，有若干个长度为n的字符串构成了一个 Trie树 ，则每个节点的出度为 <code>m</code>（即每个节点的可能子节点数量为<code>m</code>），Trie树 的高度为<code>n</code>。很明显我们浪费了大量的空间来存储字符，此时Trie树的最坏空间复杂度为<code>O(m^n)</code>。也正由于每个节点的出度为<code>m</code>，所以我们能够沿着树的一个个分支高效的向下逐个字符的查询，而不是遍历所有的字符串来查询，此时Trie树的最坏时间复杂度为<code>O(n)</code>。</p><p>这正是空间换时间的体现，也是利用公共前缀降低查询时间开销的体现。</p>]]></content>
      
      
      <categories>
          
          <category> 高级算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看动画轻松理解「递归」与「动态规划」</title>
      <link href="/posts/ccd7f89d/"/>
      <url>/posts/ccd7f89d/</url>
      
        <content type="html"><![CDATA[<p>在学习「数据结构和算法」的过程中，因为人习惯了平铺直叙的思维方式，所以「递归」与「动态规划」这种带循环概念（绕来绕去）的往往是相对比较难以理解的两个抽象知识点。</p><p>程序员小吴打算使用动画的形式来帮助理解「递归」，然后通过「递归」的概念延伸至理解「动态规划」算法思想。</p><h3 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h3><p>先下定义：<strong>递归算法是一种直接或者间接调用自身函数或者方法的算法。</strong></p><p>通俗来说，递归算法的实质是把问题分解成规模缩小的同类问题的子问题，然后递归调用方法来表示问题的解。它有如下特点：</p><ul><li><ol><li>一个问题的解可以分解为几个子问题的解</li></ol></li><li><ol start="2"><li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li></ol></li><li><ol start="3"><li>存在递归终止条件，即必须有一个明确的递归结束条件，称之为递归出口</li></ol></li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d047ce29b?w=953&amp;h=537&amp;f=gif&amp;s=156148" alt="递归动画"></p><p>通过动画一个一个特点来进行分析。</p><h4 id="1-一个问题的解可以分解为几个子问题的解"><a href="#1-一个问题的解可以分解为几个子问题的解" class="headerlink" title="1.一个问题的解可以分解为几个子问题的解"></a>1.一个问题的解可以分解为几个子问题的解</h4><p>子问题就是相对与其前面的问题数据规模更小的问题。</p><p>在动图中①号问题（一块大区域）划分为②号问题，②号问题由两个子问题（两块中区域）组成。</p><h4 id="2-这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"><a href="#2-这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样" class="headerlink" title="2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"></a>2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</h4><p>「①号划分为②号」与「②号划分为③号」的逻辑是一致的，求解思路是一样的。</p><h4 id="3-存在递归终止条件，即存在递归出口"><a href="#3-存在递归终止条件，即存在递归出口" class="headerlink" title="3. 存在递归终止条件，即存在递归出口"></a>3. 存在递归终止条件，即存在递归出口</h4><p>把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。</p><p>①号划分为②号，②号划分为③号，③号划分为④号，划分到④号的时候每个区域只有一个不能划分的问题，这就表明存在递归终止条件。</p><h3 id="从递归的经典示例开始"><a href="#从递归的经典示例开始" class="headerlink" title="从递归的经典示例开始"></a>从递归的经典示例开始</h3><h4 id="一-数组求和"><a href="#一-数组求和" class="headerlink" title="一.数组求和"></a>一.数组求和</h4><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d04680364?w=953&amp;h=537&amp;f=gif&amp;s=170958" alt="数组求和"></p><pre><code>Sum(arr[0...n-1]) = arr[0] + Sum(arr[1...n-1])</code></pre><p>后面的 Sum 函数要解决的就是比前一个 Sum 更小的同一问题。</p><pre><code>Sum(arr[1...n-1]) = arr[1] + Sum(arr[2...n-1])</code></pre><p>以此类推，直到对一个空数组求和，空数组和为 0 ，此时变成了最基本的问题。</p><pre><code>Sum(arr[n-1...n-1] ) = arr[n-1] + Sum([])</code></pre><h4 id="二-汉诺塔问题"><a href="#二-汉诺塔问题" class="headerlink" title="二.汉诺塔问题"></a>二.汉诺塔问题</h4><p>汉诺塔（Hanoi Tower）问题也是一个经典的递归问题，该问题描述如下：</p><blockquote><p>汉诺塔问题：古代有一个梵塔，塔内有三个座A、B、C，A座上有64个盘子，盘子大小不等，大的在下，小的在上。有一个和尚想把这个盘子从A座移到B座，但每次只能允许移动一个盘子，并且在移动过程中，3个座上的盘子始终保持大盘在下，小盘在上。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d06ac04b2?w=953&amp;h=537&amp;f=gif&amp;s=129013" alt="两个盘子"></p><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d053ae4f6?w=953&amp;h=537&amp;f=gif&amp;s=191396" alt="三个盘子"></p><ul><li><p>①  如果只有 1 个盘子，则不需要利用 B 塔，直接将盘子从 A 移动到 C 。</p></li><li><p>② 如果有 2 个盘子，可以先将盘子 2 上的盘子 1 移动到 B ；将盘子 2 移动到 C ；将盘子 1 移动到 C 。这说明了：可以借助 B 将 2 个盘子从 A 移动到 C ，当然，也可以借助 C 将 2 个盘子从 A 移动到 B 。</p></li><li><p>③ 如果有 3 个盘子，那么根据 2 个盘子的结论，可以借助 C 将盘子 3 上的两个盘子从 A 移动到 B ；将盘子 3 从 A 移动到 C ，A 变成空座；借助 A 座，将 B 上的两个盘子移动到 C 。</p></li><li><p>④ 以此类推，上述的思路可以一直扩展到 n 个盘子的情况，将将较小的 n-1个盘子看做一个整体，也就是我们要求的子问题，以借助 B 塔为例，可以借助空塔 B 将盘子A上面的 n-1 个盘子从 A 移动到 B ；将A 最大的盘子移动到 C ， A 变成空塔；借助空塔 A ，将 B 塔上的 n-2 个盘子移动到 A，将 C 最大的盘子移动到 C， B 变成空塔。。。</p></li></ul><h4 id="三-爬台阶问题"><a href="#三-爬台阶问题" class="headerlink" title="三.爬台阶问题"></a>三.爬台阶问题</h4><p>问题描述：</p><blockquote><p> 一个人爬楼梯，每次只能爬1个或2个台阶，假设有n个台阶，那么这个人有多少种不同的爬楼梯方法？ </p></blockquote><p>先从简单的开始，以 4 个台阶为例，可以通过每次爬 1 个台阶爬完楼梯：</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d06bc802f?w=953&amp;h=537&amp;f=gif&amp;s=160386" alt="每次爬 1 个台阶"></p><p>可以通过先爬 2 个台阶，剩下的每次爬 1 个台阶爬完楼梯</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d06c90ce5?w=953&amp;h=537&amp;f=gif&amp;s=123221" alt="先爬 2 个台阶"></p><p>在这里，可以思考一下：可以根据第一步的走法把所有走法分为两类：</p><ul><li>① 第一类是第一步走了 1 个台阶</li><li>② 第二类是第一步走了 2 个台阶</li></ul><p>所以 n 个台阶的走法就等于先走 1 阶后，n-1 个台阶的走法 ，然后加上先走 2 阶后，n-2 个台阶的走法。</p><p>用公式表示就是：</p><blockquote><p><code>f(n) = f(n-1)+f(n-2)</code></p></blockquote><p>有了递推公式，递归代码基本上就完成了一半。那么接下来考虑递归终止条件。</p><p>当有一个台阶时，我们不需要再继续递归，就只有一种走法。</p><p>所以 <code>f(1)=1</code>。</p><p>通过用 <code>n = 2</code>，<code>n = 3</code> 这样比较小的数试验一下后发现这个递归终止条件还不足够。</p><p><code>n = 2</code> 时，<code>f(2) = f(1) + f(0)</code>。如果递归终止条件只有一个<code>f(1) = 1</code>，那 <code>f(2)</code> 就无法求解，递归无法结束。<br>所以除了 <code>f(1) = 1</code> 这一个递归终止条件外，还要有 <code>f(0) = 1</code>，表示走 0 个台阶有一种走法，从思维上以及动图上来看，这显得的有点不符合逻辑。所以为了便于理解，把 <code>f(2) = 2</code> 作为一种终止条件，表示走 2 个台阶，有两种走法，一步走完或者分两步来走。</p><p>总结如下：</p><ul><li>① 假设只有一个台阶，那么只有一种走法，那就是爬 1 个台阶</li><li>② 假设有两个个台阶，那么有两种走法，一步走完或者分两步来走</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d3cd8be6b?w=953&amp;h=537&amp;f=gif&amp;s=303733" alt="递归终止条件"></p><p>通过递归条件：</p><pre><code>f(1) = 1;f(2) = 2;f(n) = f(n-1)+f(n-2)</code></pre><p>很容易推导出递归代码：</p><pre><code>int f(int n) {  if (n == 1) return 1;  if (n == 2) return 2;  return f(n-1) + f(n-2);}</code></pre><p>通过上述三个示例，总结一下如何写递归代码：</p><ul><li>1.找到如何将大问题分解为小问题的规律</li><li>2.通过规律写出递推公式</li><li>3.通过递归公式的临界点推敲出终止条件</li><li>4.将递推公式和终止条件翻译成代码</li></ul><h3 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h3><p>介绍动态规划之前先介绍一下分治策略（Divide and Conquer）。</p><h4 id="分治策略"><a href="#分治策略" class="headerlink" title="分治策略"></a>分治策略</h4><p>将原问题分解为若干个规模较小但类似于原问题的子问题（<strong>Divide</strong>），「递归」的求解这些子问题（<strong>Conquer</strong>），然后再合并这些子问题的解来建立原问题的解。</p><p>因为在求解大问题时，需要递归的求小问题，因此一般用「递归」的方法实现，即自顶向下。</p><h4 id="动态规划（Dynamic-Programming）"><a href="#动态规划（Dynamic-Programming）" class="headerlink" title="动态规划（Dynamic Programming）"></a>动态规划（Dynamic Programming）</h4><p>动态规划其实和分治策略是类似的，也是将一个原问题分解为若干个规模较小的子问题，递归的求解这些子问题，然后合并子问题的解得到原问题的解。<br>区别在于这些子问题会有重叠，一个子问题在求解后，可能会再次求解，于是我们想到将这些子问题的<strong>解存储起来</strong>，当下次再次求解这个子问题时，直接拿过来就是。<br>其实就是说，动态规划所解决的问题是分治策略所解决问题的一个子集，只是这个子集更适合用动态规划来解决从而得到更小的运行时间。<br><strong>即用动态规划能解决的问题分治策略肯定能解决，只是运行时间长了</strong>。因此，分治策略一般用来解决子问题相互对立的问题，称为标准分治，而动态规划用来解决子问题重叠的问题。</p><p>与「分治策略」「动态规划」概念接近的还有「贪心算法」「回溯算法」，由于篇幅限制，程序员小吴就不在这进行展开，在后续的文章中将分别详细的介绍「贪心算法」、「回溯算法」、「分治算法」，敬请关注：）</p><p>将「动态规划」的概念关键点抽离出来描述就是这样的：</p><ul><li>1.动态规划法试图只解决每个子问题一次</li><li>2.一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 </li></ul><h3 id="从递归到动态规划"><a href="#从递归到动态规划" class="headerlink" title="从递归到动态规划"></a>从递归到动态规划</h3><p>还是以 <strong>爬台阶</strong> 为例，如果以递归的方式解决的话，那么这种方法的时间复杂度为O(2^n)，具体的计算可以查看笔者之前的文章 《冰与火之歌：时间复杂度与空间复杂度》。</p><blockquote><p>相同颜色代表着 爬台阶问题 在递归计算过程中重复计算的部分。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d3cf51362?w=1518&amp;h=858&amp;f=png&amp;s=86406" alt="爬台阶的时间复杂度"></p><p>通过图片可以发现一个现象，我们是 自顶向下 的进行递归运算，比如：<code>f(n)</code> 是<code>f(n-1)</code>与<code>f(n-2)</code>相加，<code>f(n-1)</code> 是<code>f(n-2)</code>与<code>f(n-3)</code>相加。</p><p>思考一下：如果反过来，采取自底向上，用迭代的方式进行推导会怎么样了？</p><p>下面通过表格来解释 <code>f(n)</code>自底向上的求解过程。</p><table><thead><tr><th style="text-align:left">台阶数</th><th style="text-align:center">1</th><th style="text-align:right">2</th><th style="text-align:right">3</th><th style="text-align:right">4</th><th style="text-align:right">5</th><th style="text-align:right">6</th><th style="text-align:right">7</th><th style="text-align:right">8</th><th style="text-align:right">9</th></tr></thead><tbody><tr><td style="text-align:left">走法数</td><td style="text-align:center">1</td><td style="text-align:right">2</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td></tr></tbody></table><p>表格的第一行代表了楼梯台阶的数目，第二行代表了若干台阶对应的走法数。<br>其中<code>f(1) = 1</code> 和 <code>f(2) = 2</code>是前面明确的结果。</p><p>第一次迭代，如果台阶数为 3 ，那么走法数为 3 ，通过 <code>f(3) = f(2) + f(1)</code>得来。</p><table><thead><tr><th style="text-align:left">台阶数</th><th style="text-align:center">1</th><th style="text-align:right">2</th><th style="text-align:right">3</th><th style="text-align:right">4</th><th style="text-align:right">5</th><th style="text-align:right">6</th><th style="text-align:right">7</th><th style="text-align:right">8</th><th style="text-align:right">9</th></tr></thead><tbody><tr><td style="text-align:left">走法数</td><td style="text-align:center">1</td><td style="text-align:right">2</td><td style="text-align:right">3</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td></tr></tbody></table><p>第二次迭代，如果台阶数为 4 ，那么走法数为 5 ，通过 <code>f(4) = f(3) + f(2)</code>得来。</p><table><thead><tr><th style="text-align:left">台阶数</th><th style="text-align:center">1</th><th style="text-align:right">2</th><th style="text-align:right">3</th><th style="text-align:right">4</th><th style="text-align:right">5</th><th style="text-align:right">6</th><th style="text-align:right">7</th><th style="text-align:right">8</th><th style="text-align:right">9</th></tr></thead><tbody><tr><td style="text-align:left">走法数</td><td style="text-align:center">1</td><td style="text-align:right">2</td><td style="text-align:right">3</td><td style="text-align:right">5</td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td><td style="text-align:right"></td></tr></tbody></table><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d3ded7651?w=953&amp;h=537&amp;f=gif&amp;s=71448" alt=""></p><p>由此可见，每一次迭代过程中，只需要保留之前的两个状态，就可以推到出新的状态。</p><blockquote><p>show me the code</p></blockquote><pre><code>int f(int n) {    if (n == 1) return 1;    if (n == 2) return 2;    // a 保存倒数第二个子状态数据，b 保存倒数第一个子状态数据， temp 保存当前状态的数据    int a = 1, b = 2;    int temp = a + b;    for (int i = 3; i &lt;= n; i++) {        temp = a + b;        a = b;        b = temp;     }    return temp; }</code></pre><p>程序从 <code>i = 3</code> 开始迭代，一直到 <code>i = n</code> 结束。每一次迭代，都会计算出多一级台阶的走法数量。迭代过程中只需保留两个临时变量 a 和 b ，分别代表了上一次和上上次迭代的结果。为了便于理解，引入了temp变量。temp代表了当前迭代的结果值。</p><p>看一看出，事实上并没有增加太多的代码，只是简单的进行了优化，时间复杂度便就降为O(n)，而空间复杂度也变为O(1)，这，就是「动态规划」的强大！</p><h3 id="详解动态规划"><a href="#详解动态规划" class="headerlink" title="详解动态规划"></a>详解动态规划</h3><p>「动态规划」中包含三个重要的概念：</p><ul><li>【最优子结构】</li><li>【边界】</li><li>【状态转移公式】</li></ul><p>在「 爬台阶问题 」中</p><blockquote><p><code>f(10) = f(9) + f(8)</code> 是【最优子结构】<br><code>f(1) 与 f(2)</code> 是【边界】<br><code>f(n) = f(n-1) + f(n-2)</code> 【状态转移公式】</p></blockquote><p>「 爬台阶问题 」 只是动态规划中相对简单的问题，因为它只有一个变化维度，如果涉及多个维度的话，那么问题就变得复杂多了。 </p><p><strong>难点就在于找出 「动态规划」中的这三个概念。</strong></p><p>比如「 国王和金矿问题 」。</p><h4 id="国王和金矿问题"><a href="#国王和金矿问题" class="headerlink" title="国王和金矿问题"></a>国王和金矿问题</h4><blockquote><p>有一个国家发现了 5 座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。参与挖矿工人的总数是 10 人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？<br><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d3e0c8a2a?w=1448&amp;h=284&amp;f=png&amp;s=27005" alt=" 5 座金矿"></p></blockquote><p><strong>找出 「动态规划」中的这三个概念</strong> </p><h5 id="国王和金矿问题中的【最优子结构】"><a href="#国王和金矿问题中的【最优子结构】" class="headerlink" title="国王和金矿问题中的【最优子结构】"></a>国王和金矿问题中的【最优子结构】</h5><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d3e263ca2?w=1918&amp;h=1080&amp;f=png&amp;s=126900" alt="国王和金矿问题中的【最优子结构】"></p><p>国王和金矿问题中的【最优子结构】有两个：</p><ul><li>① 4 金矿 10 工人的最优选择</li><li>② 4 金矿 （10 - 5） 工人的最优选择</li></ul><p>4 金矿的最优选择与 5 金矿的最优选择之间的关系是</p><p><code>MAX[（4 金矿 10 工人的挖金数量），（4 金矿 5 工人的挖金数量 + 第 5 座金矿的挖金数量）]</code></p><h5 id="国王和金矿问题中的【边界】"><a href="#国王和金矿问题中的【边界】" class="headerlink" title="国王和金矿问题中的【边界】"></a>国王和金矿问题中的【边界】</h5><p>国王和金矿问题中的【边界】 有两个：</p><ul><li>① 当只有 1 座金矿时，只能挖这座唯一的金矿，得到的黄金数量为该金矿的数量</li><li>② 当给定的工人数量不够挖 1 座金矿时，获取的黄金数量为 0 </li></ul><h5 id="国王和金矿问题中的【状态转移公式】"><a href="#国王和金矿问题中的【状态转移公式】" class="headerlink" title="国王和金矿问题中的【状态转移公式】"></a>国王和金矿问题中的【状态转移公式】</h5><p>我们把金矿数量设为 N，工人数设为 W，金矿的黄金量设为数组G[]，金矿的用工量设为数组P[]，得到【状态转移公式】：</p><ul><li><p>边界值：F(n,w) = 0    (n &lt;= 1, w &lt; p[0])</p></li><li><p><code>F(n,w) = g[0]   (n==1, w &gt;= p[0])</code></p></li><li><p>F(n,w) = F(n-1,w)    (n &gt; 1, w &lt; p[n-1]) </p></li><li><p><code>F(n,w) = max(F(n-1,w),  F(n-1,w-p[n-1]) + g[n-1])    (n &gt; 1, w &gt;= p[n-1])</code></p></li></ul><h3 id="国王和金矿问题中的【实现】"><a href="#国王和金矿问题中的【实现】" class="headerlink" title="国王和金矿问题中的【实现】"></a>国王和金矿问题中的【实现】</h3><p>先通过几幅动画来理解 「工人」 与 「金矿」 搭配的方式</p><h6 id="1-只挖第一座金矿"><a href="#1-只挖第一座金矿" class="headerlink" title="1.只挖第一座金矿"></a>1.只挖第一座金矿</h6><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d670b0774?w=957&amp;h=538&amp;f=gif&amp;s=318658" alt="只挖第一座金矿"></p><p>在只挖第一座金矿前面两个工人挖矿收益为 零，当有三个工人时，才开始产生收益为 200，而后即使增加再多的工人收益不变，因为只有一座金矿可挖。</p><h6 id="2-挖第一座与第二座金矿"><a href="#2-挖第一座与第二座金矿" class="headerlink" title="2.挖第一座与第二座金矿"></a>2.挖第一座与第二座金矿</h6><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d404376c8?w=957&amp;h=538&amp;f=gif&amp;s=586737" alt="挖第一座与第二座金矿"></p><p>在第一座与第二座金矿这种情况中，前面两个工人挖矿收益为 零，因为 W &lt; 3,所以F(N,W) = F(N-1,W) = 0。  </p><p>当有 三 个工人时，将其安排挖第 一 个金矿，开始产生收益为 200。</p><p>当有 四 个工人时，挖矿位置变化，将其安排挖第 二 个金矿，开始产生收益为 300。</p><p>当有 五、六 个工人时，由于多于 四 个工人的人数不足以去开挖第 一 座矿，因此收益还是为 300。</p><p>当有 七 个工人时，可以同时开采第 一 个和第 二 个金矿，开始产生收益为 500。</p><h6 id="3-挖前三座金矿"><a href="#3-挖前三座金矿" class="headerlink" title="3.挖前三座金矿"></a>3.挖前三座金矿</h6><p><strong>这是「国王和金矿」 问题中最重要的一个动画之一，可以多看几遍</strong><br><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d685f6826?w=957&amp;h=536&amp;f=gif&amp;s=543368" alt="挖前三座金矿"></p><h6 id="4-挖前四座金矿"><a href="#4-挖前四座金矿" class="headerlink" title="4.挖前四座金矿"></a>4.挖前四座金矿</h6><p><strong>这是「国王和金矿」 问题中最重要的一个动画之一，可以多看几遍</strong>    </p><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d6ef42679?w=957&amp;h=536&amp;f=gif&amp;s=329570" alt="挖前四座金矿"></p><h3 id="国王和金矿问题中的【规律】"><a href="#国王和金矿问题中的【规律】" class="headerlink" title="国王和金矿问题中的【规律】"></a>国王和金矿问题中的【规律】</h3><p>仔细观察上面的几组动画可以发现：</p><ul><li><p>对比「挖第一座与第二座金矿」和「挖前三座金矿」，在「挖前三座金矿」中，3 金矿 7 工人的挖矿收益，来自于 2 金矿 7 工人和  2 金矿 4 工人的结果，Max(500,300 + 350) = 650；</p></li><li><p>对比「挖前三座金矿」和「挖前四座金矿」，在「挖前四座金矿」中，4 金矿 10 工人的挖矿收益，来自于 3 金矿 10 工人和  3 金矿 5 工人的结果，Max(850,400 + 300) = 850；</p></li></ul><h3 id="国王和金矿问题中的【动态规划代码】"><a href="#国王和金矿问题中的【动态规划代码】" class="headerlink" title="国王和金矿问题中的【动态规划代码】"></a>国王和金矿问题中的【动态规划代码】</h3><pre><code>代码来源：https://www.cnblogs.com/SDJL/archive/2008/08/22/1274312.html//maxGold[i][j] 保存了i个人挖前j个金矿能够得到的最大金子数，等于 -1 时表示未知int maxGold[max_people][max_n];int GetMaxGold(int people, int mineNum){    int retMaxGold;                            //声明返回的最大金矿数量    //如果这个问题曾经计算过    if(maxGold[people][mineNum] != -1){        retMaxGold = maxGold[people][mineNum]; //获得保存起来的值    }else if(mineNum == 0) {                   //如果仅有一个金矿时 [ 对应动态规划中的&quot;边界&quot;]        if(people &gt;= peopleNeed[mineNum])      //当给出的人数足够开采这座金矿            retMaxGold = gold[mineNum];        //得到的最大值就是这座金矿的金子数        else                                   //否则这唯一的一座金矿也不能开采            retMaxGold = 0;                    //得到的最大值为 0 个金子    }else if(people &gt;= peopleNeed[mineNum])    // 如果人够开采这座金矿[对应动态规划中的&quot;最优子结构&quot;]    {        //考虑开采与不开采两种情况，取最大值        retMaxGold = max(                         GetMaxGold(people - peopleNeed[mineNum],mineNum - 1) + gold[mineNum],                         GetMaxGold(people,mineNum - 1)                         );    }else//否则给出的人不够开采这座金矿 [ 对应动态规划中的&quot;最优子结构&quot;]    {        retMaxGold = GetMaxGold(people,mineNum - 1);     //仅考虑不开采的情况        maxGold[people][mineNum] = retMaxGold;    }    return retMaxGold;}</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e8d9d6fea1634?w=2048&amp;h=1708&amp;f=png&amp;s=555294" alt="动态规划代码"></p>]]></content>
      
      
      <categories>
          
          <category> 高级算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道让你拍案叫绝的算法题</title>
      <link href="/posts/d9a29023/"/>
      <url>/posts/d9a29023/</url>
      
        <content type="html"><![CDATA[<p>这是一道看完答案会觉得很简单，但做之前很难想到答案的题目！！！</p><p>不信？</p><p>Let us go ！</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><p>输入: [2,2,1]<br>输出: 1</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><p>输入: [4,1,2,1,2]<br>输出: 4</p><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>根据题目描述，由于加上了时间复杂度必须是O(n)，并且空间复杂度为O(1)的条件，因此不能用排序方法，也不能使用map数据结构。</p><p>小吴想了一下午没想出来，答案是使用 <strong>位操作Bit Operation</strong> 来解此题。</p><p>将所有元素做异或运算，即a[1] ⊕  a[2] ⊕  a[3] ⊕ …⊕  a[n]，所得的结果就是那个只出现一次的数字，时间复杂度为O(n)。</p><h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><p>异或运算A ⊕  B的真值表如下：</p><table><thead><tr><th style="text-align:left">A</th><th style="text-align:center">B</th><th style="text-align:right">⊕</th></tr></thead><tbody><tr><td style="text-align:left">F</td><td style="text-align:center">F</td><td style="text-align:right">F</td></tr><tr><td style="text-align:left">F</td><td style="text-align:center">T</td><td style="text-align:right">T</td></tr><tr><td style="text-align:left">T</td><td style="text-align:center">F</td><td style="text-align:right">T</td></tr><tr><td style="text-align:left">T</td><td style="text-align:center">T</td><td style="text-align:right">F</td></tr></tbody></table><h3 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="https://user-gold-cdn.xitu.io/2019/1/16/168542e800a21633?w=959&amp;h=537&amp;f=gif&amp;s=456512" alt=""></p><h3 id="进阶版"><a href="#进阶版" class="headerlink" title="进阶版"></a>进阶版</h3><p>有一个 n 个元素的数组，除了两个数只出现一次外，其余元素都出现两次，让你找出这两个只出现一次的数分别是几，要求时间复杂度为 O(n) 且再开辟的内存空间固定(与 n 无关)。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例 :"></a>示例 :</h4><p>输入: [1,2,2,1,3,4]<br>输出: [3,4]</p><h3 id="题目再解析"><a href="#题目再解析" class="headerlink" title="题目再解析"></a>题目再解析</h3><p>根据前面找一个不同数的思路算法，在这里把所有元素都异或，那么得到的结果就是那两个只出现一次的元素异或的结果。</p><p>然后，因为这两个只出现一次的元素一定是不相同的，所以这两个元素的二进制形式肯定至少有某一位是不同的，即一个为 0 ，另一个为 1 ，现在需要找到这一位。</p><p>根据异或的性质 <code>任何一个数字异或它自己都等于 0</code>，得到这个数字二进制形式中任意一个为 1 的位都是我们要找的那一位。</p><p>再然后，以这一位是 1 还是 0 为标准，将数组的 n 个元素分成两部分。</p><ul><li><p>将这一位为 0 的所有元素做异或，得出的数就是只出现一次的数中的一个</p></li><li><p>将这一位为 1 的所有元素做异或，得出的数就是只出现一次的数中的另一个。</p></li></ul><p>这样就解出题目。忽略寻找不同位的过程，总共遍历数组两次，时间复杂度为O(n)。</p><h3 id="动画再演示"><a href="#动画再演示" class="headerlink" title="动画再演示"></a>动画再演示</h3><p><img src="https://user-gold-cdn.xitu.io/2019/1/16/168542e800e97866?w=958&amp;h=535&amp;f=gif&amp;s=413228" alt=""></p><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3><p>本题的基础版来源于 LeetCode 第 136 号问题：只出现一次的数字。虽然题目难度是 简单，但解法真的很巧妙。感兴趣的同学可以根据思路去回答一下：<a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/single-number/</a> 。</p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> 新手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是鸡尾酒排序和地精排序？</title>
      <link href="/posts/9a8663f9/"/>
      <url>/posts/9a8663f9/</url>
      
        <content type="html"><![CDATA[<p>奇葩排序第二弹：）</p><h3 id="从冒泡排序开始"><a href="#从冒泡排序开始" class="headerlink" title="从冒泡排序开始"></a>从冒泡排序开始</h3><p>先来看回顾一下冒泡排序的思想和原理。</p><h4 id="冒泡排序的思想"><a href="#冒泡排序的思想" class="headerlink" title="冒泡排序的思想"></a>冒泡排序的思想</h4><p>冒泡排序的每一个元素都可以像小气泡一样，根据自身大小，一点一点向着数组的一侧移动。</p><h4 id="冒泡排序算法的原理"><a href="#冒泡排序算法的原理" class="headerlink" title="冒泡排序算法的原理"></a>冒泡排序算法的原理</h4><ul><li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p></li><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p></li><li><p>针对所有的元素重复以上的步骤，除了最后一个。</p></li><li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p></li></ul><p>一般情况下，可以通过下面的动画理解冒泡排序。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a569b8f9419f?w=954&amp;h=537&amp;f=gif&amp;s=906068" alt="冒泡排序"></p><p>现在我们来看一组特殊数据如果使用冒泡排序会怎么样。</p><p>将无序数列：2，3，4，5，6，7，8，1，使用冒泡排序使其从小到大排序。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a569b9213adb?w=1706&amp;h=308&amp;f=png&amp;s=26112" alt="无序数列"></p><p>进行逐步分析：</p><ol><li>第一轮操作（ 8 和 1 交换 ）<br><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a569b8b5a9df?w=849&amp;h=316&amp;f=gif&amp;s=130463" alt="第一轮操作（ 8 和 1 交换 ）"></li><li>第二轮操作（ 7 和 1 交换 ）<br><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a569bb608e55?w=849&amp;h=316&amp;f=gif&amp;s=99952" alt="第二轮操作（ 7 和 1 交换 ）"></li><li>第三轮操作（ 6 和 1 交换 ）<br><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a569baff9449?w=849&amp;h=316&amp;f=gif&amp;s=100137" alt="第三轮操作（ 6 和 1 交换 ）"></li><li>第四轮操作（ 5 和 1 交换 ）<br><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a569b946b782?w=849&amp;h=316&amp;f=gif&amp;s=92676" alt="第四轮操作（ 5 和 1 交换 ）"></li><li>第五轮操作（ 4 和 1 交换 ）<br><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a569e9873cdc?w=849&amp;h=316&amp;f=gif&amp;s=74263" alt="第五轮操作（ 4 和 1 交换 ）"></li><li>第六轮操作（ 3 和 1 交换 ）<br><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a569ea5cd54e?w=849&amp;h=316&amp;f=gif&amp;s=68982" alt="第六轮操作（ 3 和 1 交换 ）"></li><li>第七轮操作（ 2 和 1 交换 ）<br><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a569ec41b088?w=849&amp;h=316&amp;f=gif&amp;s=52410" alt="第七轮操作（ 2 和 1 交换 ）"></li></ol><p>仔细观察上面的这组无序数列，实际上只有 1 的位置不在该在的位置，而 2 ，3 ，4 ，5 ，6 ，7 ，8 都已经有序了，结果使用冒泡排序，需要 <strong>折腾 7 次</strong> 才能将 1 归位。</p><h3 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a>鸡尾酒排序</h3><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a569ef8b3ade?w=277&amp;h=257&amp;f=gif&amp;s=900082" alt="鸡尾酒排序"></p><p>鸡尾酒排序，也就是定向冒泡排序，鸡尾酒搅拌排序，搅拌排序（也可以视作选择排序的一种变形），涟漪排序，来回排序或快乐小时排序，是冒泡排序的一种变形。</p><p><strong>此算法与冒泡排序的不同处在于排序时是以双向在序列中进行排序。</strong></p><p>排序过程：</p><ul><li>先对数组从左到右进行冒泡排序（升序），则最大的元素去到最右端</li><li>再对数组从右到左进行冒泡排序（降序），则最小的元素去到最左端</li><li>以此类推，依次改变冒泡的方向，并不断缩小未排序元素的范围，直到最后一个元素结束</li></ul><p><strong>Show Me The Animation</strong></p><ol><li>第一轮操作（ 8 和 1 交换 ）<br><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a569f211de41?w=849&amp;h=316&amp;f=gif&amp;s=137385" alt="第一轮操作（ 8 和 1 交换 ）"></li><li>第二轮操作 ( 从序列右边开始遍历 ）<br><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a052f9d04?w=849&amp;h=316&amp;f=gif&amp;s=238107" alt="第二轮操作 ( 从序列右边开始遍历 ）"></li><li>第三轮操作 ( 从左向右比较和交换 )<br><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a14d62bde?w=849&amp;h=316&amp;f=gif&amp;s=142025" alt="第三轮操作 ( 从左向右比较和交换 )"><br>在这一轮操作中，没有元素位置交换，证明已经有序，排序结束。</li></ol><p>对比 冒泡排序 ，鸡尾酒排序只需要 3 轮操作就可以完成排序。</p><h3 id="地精排序"><a href="#地精排序" class="headerlink" title="地精排序"></a>地精排序</h3><blockquote><p>Gnome 排序（地精排序），起初由 Hamid Sarbazi-Azad 于 2000 年提出，并被称为 <strong>stupid</strong> 排序，后来被 Dick Grune 描述并命名为 “地精排序” 。</p></blockquote><p>地精排序和插入排序类似，除了移动一个元素到最终的位置，是通过交换一系列的元素实现，就像冒泡排序一样。概念上十分简单，不需要嵌套循环。时间复杂度为O(n2)，但是如果初始数列基本有序，时间复杂度将降为O(n)。实际上 Gnome 算法可以和插入排序算法一样快。平均运行时间为O(n^2)。</p><p>将无序数列：6，2，4，1，5，使用地精排序使其从小到大排序。</p><p>通过设计标识 i = 0 ，然后从头开始判断，什么时候 ( i &lt; 4 ) 不成立,什么时候排序结束。</p><p>这里的核心点就是 <strong>如何控制 i 的值</strong>。</p><h4 id="第一轮操作「i-0」"><a href="#第一轮操作「i-0」" class="headerlink" title="第一轮操作「i = 0」"></a>第一轮操作「i = 0」</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a2dd5946a?w=849&amp;h=284&amp;f=gif&amp;s=22189" alt=""></p><p>先让 i 自增 1 ，达到值为 1 才开始比较 ：</p><p>交换前 [ 6 2 4 1 ] 『 <strong>i = 0</strong> 』</p><p>交换后 [ 6 2 4 1 ] 『 <strong>i = 1</strong> 』</p><h4 id="第二轮操作「i-1」"><a href="#第二轮操作「i-1」" class="headerlink" title="第二轮操作「i = 1」"></a>第二轮操作「i = 1」</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a2f974af7?w=849&amp;h=284&amp;f=gif&amp;s=60337" alt=""></p><p>比较 6 和 2 ，发生交换，<strong>只要发生交换 i 就减 1</strong> 。</p><p>交换前 [ 6 2 4 1 ]『 i = 1 』</p><p>交换后 [ 2 6 4 1 ]『 i = 0 』</p><h4 id="第三轮操作「i-0」"><a href="#第三轮操作「i-0」" class="headerlink" title="第三轮操作「i = 0」"></a>第三轮操作「i = 0」</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a472e0671?w=849&amp;h=284&amp;f=gif&amp;s=35838" alt=""></p><p>i 变成 0 了，啥也不干，自增变成 1 再说。</p><p>交换前 [ 2 6 4 1 ]『 i = 0 』</p><p>交换后 [ 2 6 4 1 ]『 i = 1 』</p><h4 id="第四轮操作「i-1」"><a href="#第四轮操作「i-1」" class="headerlink" title="第四轮操作「i = 1」"></a>第四轮操作「i = 1」</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a45323fb0?w=849&amp;h=284&amp;f=gif&amp;s=39303" alt=""></p><p>比较 2 和 6 ，不交换，<strong>只要不要换就自增 1</strong>。</p><p>交换前 [ 2 6 4 1 ]『 i = 1 』</p><p>交换后 [ 2 6 4 1 ]『 i = 2 』</p><h4 id="第五轮操作「i-2」"><a href="#第五轮操作「i-2」" class="headerlink" title="第五轮操作「i = 2」"></a>第五轮操作「i = 2」</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a4aeb364c?w=849&amp;h=284&amp;f=gif&amp;s=58413" alt=""></p><p>比较 6 和 4 ，发生交换，<strong>只要发生交换 i 就减 1</strong> 。</p><p>交换前 [ 2 6 4 1 ]『 i = 2 』</p><p>交换后 [ 2 4 6 1 ]『 i = 1 』</p><h4 id="第六轮操作「i-1」"><a href="#第六轮操作「i-1」" class="headerlink" title="第六轮操作「i = 1」"></a>第六轮操作「i = 1」</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a59238d49?w=849&amp;h=284&amp;f=gif&amp;s=34234" alt=""></p><p>比较 2 和 4 ，不交换，<strong>只要不要换就自增 1</strong> 。</p><p>交换前 [ 2 6 4 1 ]『 i = 1 』</p><p>交换后 [ 2 4 6 1 ]『 i = 2 』</p><h4 id="第七轮操作「i-2」"><a href="#第七轮操作「i-2」" class="headerlink" title="第七轮操作「i = 2」"></a>第七轮操作「i = 2」</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a69973a0b?w=849&amp;h=284&amp;f=gif&amp;s=37032" alt=""></p><p>比较 4 和 6 ，不交换，<strong>只要不要换就自增 1</strong> 。</p><p>交换前 [ 2 4 6 1 ]『 i = 2 』</p><p>交换后 [ 2 4 6 1 ]『 i = 3 』</p><h4 id="第八轮操作「i-3」"><a href="#第八轮操作「i-3」" class="headerlink" title="第八轮操作「i = 3」"></a>第八轮操作「i = 3」</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a6a5948ac?w=849&amp;h=284&amp;f=gif&amp;s=58152" alt=""></p><p>比较 6 和 1 ，发生交换，<strong>只要发生交换 i 就减 1</strong> 。</p><p>交换前 [ 2 4 6 1 ]『 i = 3 』</p><p>交换后 [ 2 4 1 6 ]『 i = 2 』</p><h4 id="第九轮操作「i-2」"><a href="#第九轮操作「i-2」" class="headerlink" title="第九轮操作「i = 2」"></a>第九轮操作「i = 2」</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a6f54f0f3?w=849&amp;h=284&amp;f=gif&amp;s=56016" alt=""></p><p>比较 4 和 1 ，发生交换，<strong>只要发生交换 i 就减 1</strong> 。</p><p>交换前 [ 2 4 1 6 ]『 i = 2 』</p><p>交换后 [ 2 1 4 6 ]『 i = 1 』</p><h4 id="第十轮操作「i-1」"><a href="#第十轮操作「i-1」" class="headerlink" title="第十轮操作「i = 1」"></a>第十轮操作「i = 1」</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a70ad5a94?w=849&amp;h=284&amp;f=gif&amp;s=57170" alt=""></p><p>比较 2 和 1 ，发生交换，<strong>只要发生交换 i 就减 1</strong> 。</p><p>交换前 [ 2 1 4 6 ]『 i = 1 』</p><p>交换后 [ 1 2 4 6 ]『 i = 0 』</p><h4 id="第十一轮操作「i-0」"><a href="#第十一轮操作「i-0」" class="headerlink" title="第十一轮操作「i = 0」"></a>第十一轮操作「i = 0」</h4><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683a56a7089a4da?w=849&amp;h=284&amp;f=gif&amp;s=86734" alt=""></p><p>啥也不干，先让 i 自增1，达到值为 1 才开始真正的比较。   </p><p>『 i = 1 』时，比较 1 和 2 ，不交换，只要不交换就自增 1 。<br>『 i = 2 』时，比较 2 和 4 ，不交换，只要不交换就自增 1 。<br>『 i = 3 』时，比较 4 和 6 ，不交换，只要不交换就自增 1 。<br>『 i = 4 』时，表达式 （ i &lt; n ) 不成立，排序结束。  </p><p>顺序输出为 [ 1 2 4 6 ]。</p><h5 id="地精排序算法代码"><a href="#地精排序算法代码" class="headerlink" title="地精排序算法代码"></a>地精排序算法代码</h5><pre><code>template &lt;class T&gt;void gnome_sort_1(T data[], int n, bool comparator(T, T)){    int i = 1;    while (i &lt; n){       if (i &gt; 0 &amp;&amp; comparator(data[i], data[i-1])){           swap(data[i], data[i-1]);           i--;       }else{           i++;       }    }}</code></pre><p>这种地精排序算法还有很多优化的空间，这里小吴就不展开来讲了。</p><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3><p>鸡尾酒排序和地精排序虽然被程序员小吴归为奇葩排序一类，但是它们还是有一定的使用场景的。</p><ul><li>在「大部分元素有序」的情况下，使用鸡尾酒排序可以减少排序的回合数。</li><li>地精排序最著名的特点是代码只有一层循环，在「大部分元素有序」的情况下，可以减少排序回合数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 高级算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是散列表</title>
      <link href="/posts/5e0d3e1b/"/>
      <url>/posts/5e0d3e1b/</url>
      
        <content type="html"><![CDATA[<h1 id="【算法动画】：什么是散列表"><a href="#【算法动画】：什么是散列表" class="headerlink" title="【算法动画】：什么是散列表"></a>【算法动画】：什么是散列表</h1><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p><h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>散列函数，顾名思义，它是一个函数。如果把它定义成 <strong>hash(key)</strong> ，其中 key 表示元素的键值，则 <strong>hash(key)</strong> 的值表示经过散列函数计算得到的散列值。</p><p>散列函数的特点：</p><h4 id="1-确定性"><a href="#1-确定性" class="headerlink" title="1.确定性"></a>1.确定性</h4><p>如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的。</p><h4 id="2-散列碰撞（collision）"><a href="#2-散列碰撞（collision）" class="headerlink" title="2.散列碰撞（collision）"></a>2.散列碰撞（collision）</h4><p>散列函数的输入和输出不是唯一对应关系的，如果两个散列值相同，两个输入值很可能是相同的，但也可能不同。</p><h4 id="3-不可逆性"><a href="#3-不可逆性" class="headerlink" title="3.不可逆性"></a>3.不可逆性</h4><p>一个哈希值对应无数个明文，理论上你并不知道哪个是。</p><blockquote><p>“船长，如果一样东西你知道在哪里，还算不算丢了。”</p></blockquote><blockquote><p>“不算。”</p></blockquote><blockquote><p>“好的，那您的酒壶没有丢。”</p></blockquote><h4 id="4-混淆特性"><a href="#4-混淆特性" class="headerlink" title="4.混淆特性"></a>4.混淆特性</h4><p>输入一些数据计算出散列值，然后部分改变输入值，一个具有强混淆特性的散列函数会产生一个完全不同的散列值。</p><h3 id="常见的散列函数"><a href="#常见的散列函数" class="headerlink" title="常见的散列函数"></a>常见的散列函数</h3><h4 id="1-MD5"><a href="#1-MD5" class="headerlink" title="1. MD5"></a>1. MD5</h4><p><strong>MD5</strong> 即 Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一，主流编程语言普遍已有 <strong>MD5</strong> 实现。</p><p>将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，<strong>MD5</strong> 的前身有 MD2 、MD3 和 MD4 。</p><p><strong>MD5</strong> 是输入不定长度信息，输出固定长度 128-bits 的算法。经过程序流程，生成四个32位数据，最后联合起来成为一个 128-bits 散列。</p><p>基本方式为，求余、取余、调整长度、与链接变量进行循环运算，得出结果。</p><p><strong>MD5</strong> 计算广泛应用于错误检查。在一些 BitTorrent 下载中，软件通过计算 MD5 来检验下载到的碎片的完整性。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/7/16825d390f3b1755?w=960&amp;h=536&amp;f=gif&amp;s=50918" alt=" MD5 校验"></p><h4 id="2-SHA-1"><a href="#2-SHA-1" class="headerlink" title="2. SHA-1"></a>2. SHA-1</h4><p>SHA-1（英语：Secure Hash Algorithm 1，中文名：安全散列算法1）是一种密码散列函数，SHA-1可以生成一个被称为消息摘要的160位（20字节）散列值，散列值通常的呈现形式为40个十六进制数。</p><p>SHA-1 曾经在许多安全协议中广为使用，包括TLS和SSL、PGP、SSH、S/MIME和IPsec，曾被视为是MD5的后继者。</p><h3 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h3><p>理想中的一个散列函数，希望达到 </p><blockquote><p>如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)</p></blockquote><p>这种效果，然而在真实的情况下，要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的，即使是 <strong>MD5</strong> 或者 由美国国家安全局设计的 <strong>SHA-1</strong> 算法也无法实现。</p><p><strong>事实上，再好的散列函数都无法避免散列冲突。</strong></p><p>为什么呢？</p><p>这涉及到数学中比较好理解的一个原理：抽屉原理。</p><p>抽屉原理：桌上有十个苹果，要把这十个苹果放到九个抽屉里，无论怎样放，我们会发现至少会有一个抽屉里面至少放两个苹果。这一现象就是我们所说的“抽屉原理”。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/7/16825d390fb8193d?w=952&amp;h=539&amp;f=gif&amp;s=113143" alt="抽屉原理"></p><p>对于散列表而言，无论设置的存储区域（n）有多大，当需要存储的数据大于 n 时，那么必然会存在哈希值相同的情况。这就是所谓的<strong>散列冲突</strong>。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/7/16825d390fce0635?w=960&amp;h=536&amp;f=gif&amp;s=75709" alt="散列冲突"></p><p>那应该如何解决散列冲突问题呢？</p><p>常用的散列冲突解决方法有两类，开放寻址法（open addressing）和链表法（chaining）。</p><h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><blockquote><p>定义：将散列函数扩展定义成探查序列，即每个关键字有一个探查序列h(k,0)、h(k,1)、…、h(k,m-1)，这个探查序列一定是0….m-1的一个排列（一定要包含散列表全部的下标，不然可能会发生虽然散列表没满，但是元素不能插入的情况），如果给定一个关键字k，首先会看h(k,0)是否为空，如果为空，则插入；如果不为空，则看h(k,1)是否为空，以此类推。</p></blockquote><p>开放寻址法是一种解决碰撞的方法，对于开放寻址冲突解决方法，比较经典的有线性探测方法（Linear Probing）、二次探测（Quadratic probing）和 双重散列（Double hashing）等方法。</p><p><strong>线性探测方法</strong></p><p><img src="https://user-gold-cdn.xitu.io/2019/1/7/16825d390f52d29d?w=952&amp;h=539&amp;f=gif&amp;s=110979" alt="开放寻址法之线性探测方法"></p><p>当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p><p>以上图为例，散列表的大小为 8 ，黄色区域表示空闲位置，橙色区域表示已经存储了数据。目前散列表中已经存储了 4 个元素。此时元素 7777777  经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。</p><p>于是按顺序地往后一个一个找，看有没有空闲的位置，此时，运气很好正巧在下一个位置就有空闲位置，将其插入，完成了数据存储。</p><p>线性探测法一个很大的弊端就是当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，需要从头到尾探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。 </p><p><img src="https://user-gold-cdn.xitu.io/2019/1/7/16825d39107d1894?w=952&amp;h=539&amp;f=gif&amp;s=231211" alt="开放寻址法之线性探测方法的弊端"></p><p><strong>二次探测方法</strong></p><p>二次探测是二次方探测法的简称。顾名思义，使用二次探测进行探测的步长变成了原来的“二次方”，也就是说，它探测的下标序列为 <code>hash(key)+0</code>，<code>hash(key)+1^2</code>或<code>[hash(key)-1^2]</code>，<code>hash(key)+2^2</code>或<code>[hash(key)-2^2]</code>。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/7/16825d3910b39490?w=960&amp;h=536&amp;f=gif&amp;s=126340" alt="二次探测方法"></p><p>以上图为例，散列表的大小为 8 ，黄色区域表示空闲位置，橙色区域表示已经存储了数据。目前散列表中已经存储了 7 个元素。此时元素 7777777  经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。</p><p>按照<strong>二次探测方法</strong>的操作，有冲突就先 + 1^2，8 这个位置有值，冲突；变为 - 1^2，6 这个位置有值，还是有冲突；于是 - 2^2， 3 这个位置是空闲的，插入。</p><p><strong>双重散列方法</strong></p><p>所谓双重散列，意思就是不仅要使用一个散列函数，而是使用一组散列函数 <code>hash1(key)</code>，<code>hash2(key)</code>，<code>hash3(key)</code>。。。。。。先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/7/16825d393a80c3e7?w=960&amp;h=536&amp;f=gif&amp;s=130065" alt="双重散列方法"></p><p>以上图为例，散列表的大小为 8 ，黄色区域表示空闲位置，橙色区域表示已经存储了数据。目前散列表中已经存储了 7 个元素。此时元素 7777777  经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。</p><p>此时，再将数据进行一次哈希算法处理，经过另外的 Hash 算法之后，被散列到位置下标为 3 的位置，完成操作。</p><p>事实上，不管采用哪种探测方法，只要当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，需要尽可能保证散列表中有一定比例的空闲槽位。</p><p>一般使用<strong>加载因子</strong>（load factor）来表示空位的多少。</p><p><strong>加载因子</strong>是表示 Hsah 表中元素的填满的程度，若加载因子越大，则填满的元素越多,这样的好处是：空间利用率高了,但冲突的机会加大了。反之,加载因子越小,填满的元素越少,好处是冲突的机会减小了，但空间浪费多了。</p><h4 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h4><p>链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。如下动图所示，在散列表中，每个位置对应一条链表，所有散列值相同的元素都放到相同位置对应的链表中。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/7/16825d393a9cd43d?w=952&amp;h=539&amp;f=gif&amp;s=155331" alt="链表法"></p>]]></content>
      
      
      <categories>
          
          <category> 高级算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动画 </tag>
            
            <tag> 散列表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看动画理解「链表」实现LRU缓存淘汰算法</title>
      <link href="/posts/f5f29cad/"/>
      <url>/posts/f5f29cad/</url>
      
        <content type="html"><![CDATA[<p>前几节学习了「链表」、「时间与空间复杂度」的概念，本节将结合「循环链表」、「双向链表」与 「用空间换时间的设计思想」来设计一个很有意思的缓存淘汰策略：LRU缓存淘汰算法。</p><p><img src="http://upload-images.jianshu.io/upload_images/1940317-68c9e41fd4b0ef90?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三种最常见的链表结构"></p><h3 id="循环链表的概念"><a href="#循环链表的概念" class="headerlink" title="循环链表的概念"></a>循环链表的概念</h3><p>如上图所示：单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。</p><p>因此<strong>循环链表是一种特殊的单链表。</strong>它跟单链表唯一的区别就在于尾结点。它像一个环一样首尾相连，所以叫作「循环链表」。</p><h3 id="循环链表的特点"><a href="#循环链表的特点" class="headerlink" title="循环链表的特点"></a>循环链表的特点</h3><p>和单链表相比，循环链表的优点是从链尾到链头比较方便，当要处理的数据具有环型结构特点时，适合采用循环链表。</p><h3 id="双向链表概念"><a href="#双向链表概念" class="headerlink" title="双向链表概念"></a>双向链表概念</h3><p>双向链表也叫双链表，是链表的一种，它的链接方向是双向的，它的每个数据结点中都包含有两个指针，分别指向直接后继和直接前驱。</p><p>所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p><p>双向链表的数据结构中，会有两个比较重要的参数： <code>pre</code> 和 <code>next</code> 。</p><ul><li><code>pre</code> 指向前一个数据结构</li><li><code>next</code> 指向下一个数据结构</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1940317-259b92057bd8e0db?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单链表与双链表的对比"></p><h3 id="双向链表的特点"><a href="#双向链表的特点" class="headerlink" title="双向链表的特点"></a>双向链表的特点</h3><ul><li><p>与单链表对比，双链表需要多一个指针用于指向前驱节点，因此如果存储同样多的数据，双向链表要比单链表占用更多的内存空间</p></li><li><p>双链表的插入和删除需要同时维护 next 和 prev 两个指针。</p></li><li><p>双链表中的元素访问需要通过顺序访问，支持双向遍历，这就是双向链表操作的灵活性根本</p></li></ul><h3 id="双向链表的基本操作"><a href="#双向链表的基本操作" class="headerlink" title="双向链表的基本操作"></a>双向链表的基本操作</h3><h4 id="1-添加元素。"><a href="#1-添加元素。" class="headerlink" title="1.添加元素。"></a>1.添加元素。</h4><p>与单向链表相对比双向链表可以在 O(1) 时间复杂度搞定，而单向链表需要 O(n) 的时间复杂度。</p><p>双向链表的添加元素包括头插法和尾插法。<br><img src="http://upload-images.jianshu.io/upload_images/1940317-24711ed983f9482b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="头插法和尾插法"></p><p><strong>头插法：</strong>将链表的左边称为链表头部，右边称为链表尾部。头插法是将右边固定，每次新增的元素都在左边头部增加。</p><p><strong>尾插法：</strong>将链表的左边称为链表头部，右边称为链表尾部。尾插法是将左边固定，每次新增都在链表的右边最尾部。</p><h4 id="2-查询元素"><a href="#2-查询元素" class="headerlink" title="2.查询元素"></a>2.查询元素</h4><p><img src="http://upload-images.jianshu.io/upload_images/1940317-8a8215da4597d9ed?imageMogr2/auto-orient/strip" alt="查询元素"></p><p>双向链表的灵活处就是<strong>知道链表中的一个元素结构就可以向左或者向右开始遍历查找需要的元素结构</strong>。因此对于一个有序链表，双向链表的按值查询的效率比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</p><h4 id="3-删除元素"><a href="#3-删除元素" class="headerlink" title="3.删除元素"></a>3.删除元素</h4><p>在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：</p><ul><li><p>删除结点中“值等于某个给定值”的结点</p></li><li><p>删除给定指针指向的结点</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1940317-cc0552cc91316155?imageMogr2/auto-orient/strip" alt="删除元素"></p><p>对于双向链表来说，双向链表中的结点已经保存了前驱结点的指针，删除时不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度。</p><h3 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h3><p><img src="http://upload-images.jianshu.io/upload_images/1940317-8ccbb5571edeefae?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="双向循环链表"></p><p>如图所示，双向循环链表的概念很好理解：「双向链表」 + 「循环链表」的组合。</p><h3 id="缓存淘汰策略"><a href="#缓存淘汰策略" class="headerlink" title="缓存淘汰策略"></a>缓存淘汰策略</h3><p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。</p><p>缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。</p><p>在各个语言的第三方框架中都大量使用到了 LRU 缓存策略。程序员小吴接触到的有Java中的 「 Mybatis 」，iOS中的 「YYCache」与「Lottie」等。</p><h4 id="LRU缓存淘汰算法"><a href="#LRU缓存淘汰算法" class="headerlink" title="LRU缓存淘汰算法"></a>LRU缓存淘汰算法</h4><p>LRU是最近最少使用策略的缩写，是根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p><p><img src="http://upload-images.jianshu.io/upload_images/1940317-f9f489649bb5a632?imageMogr2/auto-orient/strip" alt="LRU概念"></p><h3 id="链表实现LRU"><a href="#链表实现LRU" class="headerlink" title="链表实现LRU"></a>链表实现LRU</h3><p>将Cache的所有位置都用双链表连接起来，当一个位置被命中之后，通过调整链表的指向，将该位置调整到链表头的位置，新加入的Cache直接加到链表头中。</p><p>这样，在多次进行Cache操作后，最近被命中的，就会被向链表头方向移动，而没有命中的，而想链表后面移动，链表尾则表示最近最少使用的Cache。</p><p>当需要替换内容时候，链表的最后位置就是最少被命中的位置，我们只需要淘汰链表最后的部分即可。</p><h3 id="链表实现LRU动画演示"><a href="#链表实现LRU动画演示" class="headerlink" title="链表实现LRU动画演示"></a>链表实现LRU动画演示</h3><ol><li>如果此数据之前已经被缓存在链表中了，通过遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。</li><li><p>如果此数据没有在缓存链表中，可以分为两种情况：</p><ul><li>如果此时缓存未满，则将此结点直接插入到链表的头部；</li><li>如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1940317-fd0d9116ed986c7a?imageMogr2/auto-orient/strip" alt="链表实现LRU"></p></li></ol><p>通过动图可以发现，如果缓存空间足够大，那么存储的数据也就足够多，通过缓存中命中数据的概率就越大，也就提高了代码的执行速度。这就是<strong>空间换时间的设计思想</strong>。</p><p>对于程序开发来说，时间复杂度和空间复杂度是可以相互转化的。说通俗一点，就是：</p><ul><li><p>对于执行的慢的程序，可以通过消耗内存（即构造新的数据结构）来进行优化；</p></li><li><p>而消耗内存的程序，可以通过消耗时间来降低内存的消耗。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 高级算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>准备下次编程面试前你应该知道的数据结构</title>
      <link href="/posts/27410/"/>
      <url>/posts/27410/</url>
      
        <content type="html"><![CDATA[<blockquote><p>国外 IT 教育学院 Educative.io 创始人 Fahim ul Haq 写过一篇过万赞的文章<a href="https://medium.freecodecamp.org/the-top-data-structures-you-should-know-for-your-next-coding-interview-36af0831f5e3" target="_blank" rel="noopener">《The top data structures you should know for your next coding interview》</a>,总结了<strong>程序员面试中需要掌握的 8 种数据结构知识</strong>。</p></blockquote><blockquote><p>Fahim ul Haq 曾在 Facebook 和微软任职，面试过不少程序员，所以这篇文章还是值得参考的。以下内容编译自他的这篇《准备下次编程面试前你应该知道的数据结构》：</p></blockquote><p>瑞典计算机科学家 Niklaus Wirth 在 1976 年写了一本书，叫作《Algorithms + Data Structures = Programs》（算法+数据结构=程序）。</p><p>即便在 40 年后的今天，这条等式仍然成立。这也是为何程序员求职者应该向面试官展示出已经透彻理解了数据结构知识。</p><p>几乎所有的面试问题都要求求职者表现出已经熟练掌握数据结构，不管你是刚毕业的应届生还是工作了多年的老手，都是这样。</p><p>有时，面试问题会明确提到数据结构，比如“给定一个二叉树”；有时则比较含蓄，比如“我们想追踪和每位作者相关的书籍数量。”</p><p>学习数据结构知识很有必要，哪怕你只是想找份比现在的工作更好的一份差事。我们首先了解数据结构的基本知识。</p><p><strong>什么是数据结构？</strong></p><p>简单说，数据结构就是一个容器，以某种特定的布局存储数据。这个“布局”使得数据结构在某些操作上非常高效，在另一些操作上则不那么高效。你的目标就是理解数据结构，这样就能为手头的问题选择最优的数据结构。</p><p><strong>为什么我们需要数据结构？</strong></p><p>由于数据结构用来以有组织的形式存储数据，而且数据是计算机科学中最重要的实体，因此数据结构的真正价值显而易见。</p><p>无论你解决什么问题，你都必须以这种或那种方式处理数据比如员工的工资，股票价格，购物清单，甚至简单的电话簿等等。</p><p>根据不同的场景，数据需要以特定格式存储。目前有一些数据结构可以满足我们以不同格式存储数据的需求。</p><p><strong>常用的数据结构</strong></p><p>我们首先列出最常用的数据结构，然后再挨个讲解：</p><ul><li>数组</li><li>堆栈</li><li>队列</li><li>链表</li><li>树</li><li>图</li><li>字典树</li><li>哈希表</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是一种最简单和最广泛使用的数据结构，其它数据结构比如堆栈和队列都源自数组。</p><p>下图是一个大小为 4 的简单数组，包含几个元素（  1  ,  2  ,  3，4）。</p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/16a096ac9282164c94c642f8e8d68961.png" alt=""></p><p>每个数据元素会被分配一个正的数值，叫作“索引”，它对应该元素在数组中的位置。大部分编程语言都将初始索引定义为 0.</p><p>以下是两种数组：</p><ul><li>一维数组（如上所示）</li><li>多维数组（数组的数组）</li></ul><p>数组的基本操作：</p><ul><li>Insert——在给定索引位置插入一个元素</li><li>Get——返回给定索引位置的元素</li><li>Delete——删除给定索引位置的元素</li><li>Size——获取数组内所有元素的总数</li></ul><p><strong>常问的数组面试问题</strong>：</p><ul><li>找到数组中第二小的元素</li><li>找到数组中第一个没有重复的整数</li><li>合并两个分类数组</li><li>重新排列数组中的正值和负值</li></ul><h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><p>我们都熟悉很有名的撤销（Undo）选项，它几乎存在每个应用程序中。有没有想过它是如何工作的？其思路就是，按照最后的状态排列在先的顺序将工作的先前状态（限于特定数字）存储在内存中。这只用数组是无法实现的，因此堆栈就有了用武之地。</p><p>可以把堆栈看作一堆垂直排列的书籍。为了获得位于中间位置的书，你需要拿掉放在它上面的所有书籍。这就是 LIFO（后进先出）方法的工作原理。</p><p>这是一个包含三个数据元素（1,2 和 3）的堆栈图像，其中3位于顶部，首先把它删除：</p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/8418f560a659ff24cb90ded2ca238b59.png" alt=""></p><p><strong>堆栈的基本操作</strong>：</p><ul><li>Push——在顶部插入元素</li><li>Pop—— 从堆栈中删除后返回顶部元素</li><li>isEmpty——如果堆栈为空，则返回 true</li><li>Top ——返回顶部元素，但不从堆栈中删除</li></ul><p><strong>常见的堆栈面试问题</strong>：</p><ul><li>使用堆栈计算后缀表达式</li><li>对堆栈中的值进行排序</li><li>检查表达式中的括号是否平衡</li></ul><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>与堆栈类似，队列是另一种线性数据结构，以顺序方式存储元素。堆栈和队列之间唯一的显着区别是，队列不是使用 LIFO 方法，而是应用 FIFO 方法，这是 First in First Out（先入先出）的缩写。</p><p>队列的完美现实例子：一列人在售票亭等候。如果有新人来，他们是从末尾加入队列，而不是在开头——站在前面的人将先买到票然后离开队列。</p><p>下图是一个包含四个数据元素（1,2,3 和 4）的队列，其中 1 位于顶部，首先把它删除：</p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/f70ab2adc32c9d5c7468401231f60c87.png" alt=""></p><p><strong>队列的基本操作</strong>：</p><ul><li>Enqueue() —— 向队列末尾插入元素</li><li>Dequeue() —— 从队列头部移除元素</li><li>isEmpty() —— 如果队列为空，则返回 true</li><li>Top() —— 返回队列的第一个元素</li></ul><p><strong>常问的队列面试问题</strong>：</p><ul><li>使用队列来实现堆栈</li><li>颠倒队列中前 k 个元素的顺序</li><li>使用队列生成从 1 到 n 的二进制数</li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是另一个重要的线性数据结构，刚一看可能看起来像数组，但在内存分配，内部结构以及如何执行插入和删除的基本操作方面有所不同。</p><p>链表就像一个节点链，其中每个节点包含数据和指向链中后续节点的指针等信息。有一个头指针，指向链表的第一个元素，如果列表是空的，那么它只指向 null 或不指向任何内容。</p><p>链表用于实现文件系统，哈希表和邻接表。下图是链表内部结构的直观展示：<br><img src="https://diycode.b0.upaiyun.com/photo/2019/c9d4e6282fe39203b7743e22b3781db5.png" alt=""></p><p><strong>下面是几种类型的链表</strong>：</p><ul><li>单链表（单向）</li><li>双链表（双向）</li></ul><p><strong>链表的基本操作</strong>：</p><ul><li>InsertAtEnd —— 在链表末尾插入指定元素</li><li>InsertAtHead —— 在链表头部插入指定元素</li><li>Delete —— 从链表中删除指定元素</li><li>DeleteAtHead —— 删除链表的第一个元素</li><li>Search —— 返回链表中的指定元素</li><li>isEmpty —— 如果链表为空，返回 true</li></ul><p><strong>常问的链表面试问题</strong>：</p><ul><li>翻转列表</li><li>检测链表中的循环</li><li>返回链表中倒数第 n 个节点</li><li>移除链表中的重复值</li></ul><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>图就是一组节点，以网络的形式互相连接。节点也被称为顶点（vertices）。一对（x,y）就叫做一个边，表示顶点 x 和顶点 y 相连。一个边可能包含权重/成本，显示从顶点 x 到 y 所需的成本。</p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/6bb75406664d92441a25b97125a59379.png" alt=""></p><p><strong>图的类型</strong>：</p><ul><li>无向图</li><li>有向图</li></ul><p>在编程语言中，图可以表示为两种形式：</p><ul><li>邻接矩阵</li><li>邻接列表</li></ul><p>常见的图遍历算法：</p><ul><li>广度优先搜索</li><li>深度优先搜索</li></ul><p>常问的图面试问题：</p><ul><li>实现广度优先搜索和深度优先搜索</li><li>检查一个图是否为树</li><li>计算一张图中的边的数量</li><li>找到两个顶点之间的最短路径</li></ul><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树是一种层级数据结构，包含了连接它们的顶点（节点）和边。树和图很相似，但二者有个很大的不同点，即树中没有循环。</p><p>树广泛应用在人工智能和复杂的算法中，为解决各种问题提供高效的存储机制。</p><p>下图是一个简单的树，以及在树型数据结构中所用的基本术语：<br><img src="https://diycode.b0.upaiyun.com/photo/2019/c96436682691e8e6df6636b6ec47510a.png" alt=""></p><p>下面是几种类型的树：</p><ul><li>N 叉树</li><li>平衡树</li><li>二叉树</li><li>二叉搜索树</li><li>平衡二叉树</li><li>红黑树</li><li>2-3 树</li></ul><p>其中，二叉树和二叉搜索树是最常用的树。</p><p><strong>常问的树面试问题</strong>：</p><ul><li>找到一个二叉树的高度</li><li>找到一个二叉搜索树中第 k 个最大值</li><li>找到距离根部“k”个距离的节点</li><li>找到一个二叉树中给定节点的祖先（ancestors）</li></ul><h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><p>字典树，也叫“前缀树”，是一种树形结构，在解决字符串相关问题中非常高效。其提供非常快速的检索功能，常用于搜索字典中的单词，为搜索引擎提供自动搜索建议，甚至能用于IP路由选择。<br>下面展示了“top”“thus”和“their”这三个词是如何存储在字典树中的：</p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/ad4396ac395523f511669768cedb52cd.png" alt=""></p><p>这些单词以从上到下的方式存储，其中绿色节点“p”，“s”和“r”分别表示“top”，“thus”和“their”的末尾。</p><p><strong>常见的字典树面试问题</strong>：</p><ul><li>计算字典树中的总字数</li><li>打印存储在字典树中的所有单词</li><li>使用字典树对数组的元素进行排序</li><li>使用字典树从字典中形成单词</li><li>构建一个T9字典</li></ul><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>#### </p><p>散列是一个用于唯一标识对象并在一些预先计算的唯一索引（称为“密钥”）存储每个对象的过程。因此，对象以“键值”对的形式存储，这些项的集合被称为“字典”。可以使用该键值搜索每个对象。有多种不同的基于哈希的数据结构，但最常用的数据结构是哈希表。</p><p>哈希表通常使用数组实现。</p><p>哈希数据结构的性能取决于以下三个因素：</p><ul><li>哈希函数</li><li>哈希表的大小</li><li>碰撞处理方法</li></ul><p>下图展示了如何在数组中映射哈希。该数组的索引是通过哈希函数计算的。</p><p><img src="https://diycode.b0.upaiyun.com/photo/2019/3d952413d8deb2bb715420c4848c1571.png" alt=""></p><p><strong>常问的哈希面试问题</strong>：</p><ul><li>找到数组中的对称对</li><li>追踪遍历的完整路径</li><li>查看一个数组是否为另一个数组的子集</li><li>检查给定数组是否不相交</li></ul><p>以上就是你在准备编程面试前需要掌握的8种数据结构。</p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第167号问题：Two Sum II</title>
      <link href="/posts/f772505c/"/>
      <url>/posts/f772505c/</url>
      
        <content type="html"><![CDATA[<p>leetcode上第167号问题：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">Two Sum II</a></p><blockquote><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p></blockquote><blockquote><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p></blockquote><blockquote><p>说明:</p></blockquote><blockquote><ul><li>返回的下标值（index1 和 index2）不是从零开始的。</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ul></blockquote><blockquote><p>示例:</p></blockquote><blockquote><p>输入: numbers = [2, 7, 11, 15], target = 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>初始化左指针left指向数组起始，初始化右指针right指向数组结尾。</p><p>根据<strong>已排序</strong>这个特性，</p><ul><li><p>（1）如果numbers[left]与numbers[right]的和tmp小于target，说明应该增加tmp,因此left右移指向一个较大的值。</p></li><li><p>（2）如果tmp大于target，说明应该减小tmp,因此right左移指向一个较小的值。</p></li><li><p>（3）tmp等于target，则找到，返回left+1和right+1。（注意以1为起始下标）</p></li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzl02exvalg30np0cpjsz.gif" alt="Two sum"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 对撞指针// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {        int l = 0, r = numbers.size() - 1;        while(l &lt; r){            if(numbers[l] + numbers[r] == target){                int res[2] = {l+1, r+1};                return vector&lt;int&gt;(res, res+2);            }            else if(numbers[l] + numbers[r] &lt; target)                l ++;            else // numbers[l] + numbers[r] &gt; target                r --;        }    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第75号问题：Sort Colors</title>
      <link href="/posts/fe46b16f/"/>
      <url>/posts/fe46b16f/</url>
      
        <content type="html"><![CDATA[<p>leetcode上第75号问题：<a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">Sort Colors</a></p><blockquote><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p></blockquote><blockquote><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p></blockquote><blockquote><p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p></blockquote><blockquote><p>示例:</p></blockquote><blockquote><p>输入: [2,0,2,1,1,0]</p></blockquote><blockquote><p>输出: [0,0,1,1,2,2]</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>结合三路快排partition思路的应用，设定两个索引，一个从左往右滑动<code>zero</code>，一个从右往左滑动<code>two</code>，遍历<code>nums</code>，当<code>nums[i]</code>的值为1时，<code>i++</code>；当<code>nums[i]</code>的值为2时，<code>two</code>的值先减1，而后交换<code>nums[i]</code>与<code>nums[two]</code>，此时在观察<code>nums[i]</code>的值；当<code>nums[i]</code>的值为0时，<code>zero++</code>，而后交换<code>nums[i]</code>与<code>nums[zero]</code>，<code>i++</code>;当 <code>i = two</code>时，结束循环。</p><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzl014a9kug30np0cp42x.gif" alt="Sort Colors"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 三路快速排序的思想// 对整个数组只遍历了一遍// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    void sortColors(vector&lt;int&gt; &amp;nums) {        int zero = -1;          // [0...zero] == 0        int two = nums.size();  // [two...n-1] == 2        for(int i = 0 ; i &lt; two ; ){            if(nums[i] == 1){                 i ++;            }else if (nums[i] == 2){                 two--;                 swap( nums[i] , nums[two]);            }else{ // nums[i] == 0                 zero++;                 swap(nums[zero] , nums[i]);                 i++;            }        }    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分治 </tag>
            
            <tag> 快速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第20 号问题：有效的括号</title>
      <link href="/posts/37d84b80/"/>
      <url>/posts/37d84b80/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第20 号问题：<strong><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">有效的括号</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p></blockquote><blockquote><p>有效字符串需满足：</p></blockquote><blockquote><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。    </p></blockquote><blockquote><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4></blockquote><blockquote><p>输入: “()”<br>输出: true</p></blockquote><blockquote><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4></blockquote><blockquote><p>输入: “()[]{}”<br>输出: true</p></blockquote><blockquote><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a>示例 3:</h4></blockquote><blockquote><p>输入: “(]”<br>输出: false</p></blockquote><blockquote><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例 4:"></a>示例 4:</h4></blockquote><blockquote><p>输入: “([)]”<br>输出: false   </p></blockquote><blockquote><h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例 5:"></a>示例 5:</h4></blockquote><blockquote><p>输入: “{[]}”<br>输出: true   </p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题让我们验证输入的字符串是否为括号字符串，包括大括号，中括号和小括号。</p><p>这里我们使用<strong>栈</strong>。</p><ul><li>遍历输入字符串</li><li>如果当前字符为左半边括号时，则将其压入栈中</li><li>如果遇到右半边括号时，<strong>分类讨论：</strong></li><li>1）如栈不为空且为对应的左半边括号，则取出栈顶元素，继续循环  </li><li>2）若此时栈为空，则直接返回false</li><li>3）若不为对应的左半边括号，反之返回false</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzzpkrjng30qo0f0n2n.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkzzqlgmij30u014awmf.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 1 号问题：Two Sum</title>
      <link href="/posts/fc90665e/"/>
      <url>/posts/fc90665e/</url>
      
        <content type="html"><![CDATA[<p>leetcode上第1号问题：<a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">Two Sum</a></p><blockquote><p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p></blockquote><blockquote><p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p></blockquote><blockquote><p>示例:</p></blockquote><blockquote><p>给定 nums = [2, 7, 11, 15], target = 9</p></blockquote><blockquote><p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用查找表来解决该问题。</p><blockquote><p>设置一个map容器record用来记录元素的值与索引</p><p>遍历数组nums</p><ul><li>每次遍历时使用临时变量complement用来保存目标值与当前值的差值</li><li>在此次遍历中查找record，查看是否有与complement一致的值，如果查找成功则返回查找值的索引值与当前变量的值i</li><li>如果未找到，则在record保存该元素与索引值i</li></ul></blockquote><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkzyntxibg30nn0dd458.gif" alt="Two Sum"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 1. Two Sum// https://leetcode.com/problems/two-sum/description/// 时间复杂度：O(n)// 空间复杂度：O(n)class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        unordered_map&lt;int,int&gt; record;        for(int i = 0 ; i &lt; nums.size() ; i ++){            int complement = target - nums[i];            if(record.find(complement) != record.end()){                int res[] = {i, record[complement]};                return vector&lt;int&gt;(res, res + 2);            }            record[nums[i]] = i;        }    }};</code></pre><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkzymcdnzj31nx0u0q5l.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查找表 </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第24号问题：Swap Nodes in Pairs</title>
      <link href="/posts/4988/"/>
      <url>/posts/4988/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第24号问题：<strong><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">Swap Nodes in Pairs</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p></blockquote><blockquote><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4></blockquote><blockquote><p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. </p><h4 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h4></blockquote><blockquote><ul><li>你的算法只能使用常数的额外空间。    </li><li>你<strong>不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</li></ul></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>该题属于基本的链表操作题。</p><ul><li>设置一个虚拟头结点<code>dummyHead</code></li><li>设置需要交换的两个节点分别为<code>node1</code>、<code>node2</code>，同时设置<code>node2</code>的下一个节点<code>next</code></li></ul><h5 id="在这一轮操作中"><a href="#在这一轮操作中" class="headerlink" title="在这一轮操作中"></a>在这一轮操作中</h5><ul><li>将<code>node2</code>节点的next设置为<code>node1</code>节点</li><li>将<code>node1</code>节点的next设置为<code>next</code>节点</li><li>将<code>dummyHead</code>节点的next设置为<code>node2</code></li><li>结束本轮操作</li></ul><p>接下来的每轮操作都按照上述进行。</p><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkzyet4u8g30qk0evqbw.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><pre><code>// 24. Swap Nodes in Pairs// https://leetcode.com/problems/swap-nodes-in-pairs/description/// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    ListNode* swapPairs(ListNode* head) {        ListNode* dummyHead = new ListNode(0);        dummyHead-&gt;next = head;        ListNode* p = dummyHead;        while(p-&gt;next &amp;&amp; p-&gt;next-&gt;next){            ListNode* node1 = p-&gt;next;            ListNode* node2 = node1-&gt;next;            ListNode* next = node2-&gt;next;            node2-&gt;next = node1;            node1-&gt;next = next;            p-&gt;next = node2;            p = node1;        }        ListNode* retHead = dummyHead-&gt;next;        delete dummyHead;        return retHead;    }};</code></pre><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkzyg6vkrj31ss0u0die.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 节点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第344号问题：Reverse String</title>
      <link href="/posts/cb301f5a/"/>
      <url>/posts/cb301f5a/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzwvxg08j311i0hot9w.jpg" alt=""></p><p>LeetCode上第344号问题：<strong><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">Reverse String</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>编写一个函数，其作用是将输入的字符串反转过来。</p></blockquote><blockquote><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h5></blockquote><blockquote><p>输入: “hello”<br>输出: “olleh”   </p></blockquote><blockquote><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h5></blockquote><blockquote><p>输入: “A man, a plan, a canal: Panama”<br>输出: “amanaP :lanac a ,nalp a ,nam A”</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接从两头往中间走，同时交换两边的字符即可</p><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkzwxdigqg30qm0ep0xp.gif" alt="动画演示"></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><h4 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h4><pre><code>// 344. Reverse String// https://leetcode.com/problems/reverse-string/description/// Two Pointers// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    string reverseString(string s) {        int i = 0, j = s.size() - 1;        while(i &lt; j){            swap(s[i], s[j]);            i ++;            j --;        }        return s;    }};</code></pre><h4 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h4><pre><code>// 344. Reverse String// https://leetcode.com/problems/reverse-string/description/// Two Pointers// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    string reverseString(string s) {         int left = 0, right = s.size() - 1;        while (left &lt; right) {           char t = s[left];            s[left++] = s[right];           s[right--] = t;        }       return s;   }};</code></pre><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzwzp763j313u0h6mxq.jpg" alt="执行结果"></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 反转 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第206号问题：Reverse Linked List</title>
      <link href="/posts/10709e63/"/>
      <url>/posts/10709e63/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzvypae1j311m0g6gms.jpg" alt=""></p><p>LeetCode上第206号问题：<strong><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">Reverse Linked List</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>反转一个单链表。</p></blockquote><blockquote><h5 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h5></blockquote><blockquote><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><h5 id="进阶"><a href="#进阶" class="headerlink" title="进阶:"></a>进阶:</h5><p>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>设置三个节点<code>pre</code>、<code>cur</code>、<code>next</code></p><ul><li>（1）每次查看<code>cur</code>节点是否为<code>NULL</code>，如果是，则结束循环，获得结果</li><li>（2）如果<code>cur</code>节点不是为<code>NULL</code>，则先设置临时变量<code>next</code>为<code>cur</code>的下一个节点</li><li>（3）让<code>cur</code>的下一个节点变成指向<code>pre</code>，而后<code>pre</code>移动<code>cur</code>，<code>cur</code>移动到<code>next</code></li><li>（4）重复（1）（2）（3）</li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzw15rnng30nj0d9wqe.gif" alt="动画演示"></p><h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><h5 id="迭代的方式处理"><a href="#迭代的方式处理" class="headerlink" title="迭代的方式处理"></a>迭代的方式处理</h5><pre><code>// 206. Reverse Linked List// https://leetcode.com/problems/reverse-linked-list/description/// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    ListNode* reverseList(ListNode* head) {        ListNode* pre = NULL;        ListNode* cur = head;        while(cur != NULL){            ListNode* next = cur-&gt;next;            cur-&gt;next = pre;            pre = cur;            cur = next;        }        return pre;    }};</code></pre><h5 id="递归的方式处理"><a href="#递归的方式处理" class="headerlink" title="递归的方式处理"></a>递归的方式处理</h5><pre><code>// 206. Reverse Linked List// https://leetcode.com/problems/reverse-linked-list/description///// 递归的方式反转链表// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    ListNode* reverseList(ListNode* head) {        // 递归终止条件        if(head == NULL || head-&gt;next == NULL)            return head;        ListNode* rhead = reverseList(head-&gt;next);        // head-&gt;next此刻指向head后面的链表的尾节点        // head-&gt;next-&gt;next = head把head节点放在了尾部        head-&gt;next-&gt;next = head;        head-&gt;next = NULL;        return rhead;    }};</code></pre><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzw3k5wkj31sn0u0gnx.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 反转 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第92号问题：Reverse Linked List II</title>
      <link href="/posts/970ebf8d/"/>
      <url>/posts/970ebf8d/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第92号问题：<strong><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">Reverse Linked List II</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p></blockquote><blockquote><h5 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h5><p>1 ≤ m ≤ n ≤ 链表长度。</p></blockquote><blockquote><h5 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h5></blockquote><blockquote><p><strong>输入</strong>: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4.<br><strong>输出</strong>: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong><a href="https://xiaozhuanlan.com/topic/7513064892" target="_blank" rel="noopener">Reverse Linked List</a></strong>的延伸题。</p><p>可以考虑取出需要反转的这一小段链表，反转完后再插入到原先的链表中。</p><p><strong>以本题为例：</strong></p><p>变换的是2,3,4这三个点，那么我们可以先取出2，用front指针指向2，然后当取出3的时候，我们把3加到2的前面，把front指针前移到3，依次类推，到4后停止，这样我们得到一个新链表4-&gt;3-&gt;2, front指针指向4。</p><p>对于原链表来说，<strong>有两个点的位置很重要</strong>，需要用指针记录下来，分别是1和5，把新链表插入的时候需要这两个点的位置。</p><ul><li>用pre指针记录1的位置</li><li>当4结点被取走后，5的位置需要记下来</li><li>这样我们就可以把倒置后的那一小段链表加入到原链表中</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzvp0nnyg30qk0ev4bt.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzvpvd7xj30vw0u0q82.jpg" alt=""></p><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkzvrexmqj31ss0u00vf.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第19号问题：Remove Nth Node From End of List</title>
      <link href="/posts/160c6ff6/"/>
      <url>/posts/160c6ff6/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第19号问题：<strong><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">Remove Nth Node From End of List</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p></blockquote><blockquote><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4></blockquote><blockquote><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</p></blockquote><blockquote><p>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5</p><h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4></blockquote><blockquote><p>给定的 n 保证是有效的。</p></blockquote><blockquote><h4 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h4></blockquote><blockquote><p>你能尝试使用一趟扫描实现吗？</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>采取双重遍历肯定是可以解决问题的，但题目要求我们一次遍历解决问题，那我们的思路得发散一下。</p><p>我们可以设想假设设定了双指针<code>p</code>和<code>q</code>的话，当<code>q</code>指向末尾的<code>NULL</code>，<code>p</code>与<code>q</code>之间相隔的元素个数为<code>n</code>时，那么删除掉<code>p</code>的下一个指针就完成了要求。</p><ul><li>设置虚拟节点<code>dummyHead</code>指向<code>head</code></li><li>设定双指针<code>p</code>和<code>q</code>，初始都指向虚拟节点<code>dummyHead</code></li><li>移动<code>q</code>，直到<code>p</code>与<code>q</code>之间相隔的元素个数为<code>n</code></li><li>同时移动<code>p</code>与<code>q</code>，直到<code>q</code>指向的为<code>NULL</code></li><li>将<code>p</code>的下一个节点指向下下个节点</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkzv25jlbg30qn0ezajr.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkzv3cllbj30u012d760.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第203号问题：Remove Linked List Elements</title>
      <link href="/posts/5c7d04c/"/>
      <url>/posts/5c7d04c/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzs7u2a6j31iu0mutbi.jpg" alt=""></p><p>LeetCode上第203号问题：<strong><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">Remove Linked List Elements</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>删除链表中等于给定值 val 的所有节点。</p></blockquote><blockquote><h5 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h5></blockquote><blockquote><p>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6<br>输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>主要考察了基本的链表遍历和设置指针的知识点。</p><p>定义一个虚拟头节点<code>dummyHead</code>，遍历查看原链表，遇到与给定值相同的元素，将该元素的前后两个节点连接起来，然后删除该元素即可。</p><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzs3cu9jg30qo0f0107.gif" alt="动画演示"></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><h4 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h4><pre><code>// 203. Remove Linked List Elements// https://leetcode.com/problems/remove-linked-list-elements/description/// 使用虚拟头结点// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    ListNode* removeElements(ListNode* head, int val) {        // 创建虚拟头结点        ListNode* dummyHead = new ListNode(0);        dummyHead-&gt;next = head;        ListNode* cur = dummyHead;        while(cur-&gt;next != NULL){            if(cur-&gt;next-&gt;val == val){                ListNode* delNode = cur-&gt;next;                cur-&gt;next = delNode-&gt;next;                delete delNode;            }            else                cur = cur-&gt;next;        }        ListNode* retNode = dummyHead-&gt;next;        delete dummyHead;        return retNode;    }};</code></pre><h4 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h4><p>用递归来解。</p><p>通过递归调用到链表末尾，然后回来，需要删的元素，将链表next指针指向下一个元素即可。</p><pre><code>class Solution {public:    ListNode* removeElements(ListNode* head, int val) {        if (!head) return NULL;        head-&gt;next = removeElements(head-&gt;next, val);        return head-&gt;val == val ? head-&gt;next : head;    }};</code></pre><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkzs66gunj31ri0u0773.jpg" alt="执行结果"></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第86号问题：Partition List</title>
      <link href="/posts/8dd6b93/"/>
      <url>/posts/8dd6b93/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第86号问题：<strong><a href="https://leetcode-cn.com/problems/partition-list/" target="_blank" rel="noopener">Partition List</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p></blockquote><blockquote><p>你应当保留两个分区中每个节点的初始相对位置。</p></blockquote><blockquote><h5 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h5></blockquote><blockquote><p>输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题要求我们划分链表，把所有小于给定值的节点都移到前面，大于该值的节点顺序不变，相当于一个局部排序的问题。</p><ul><li>设定两个虚拟节点，<code>dummyHead1</code>用来保存小于于该值的链表，<code>dummyHead2</code>来保存大于等于该值的链表</li><li>遍历整个原始链表，将小于该值的放于<code>dummyHead1</code>中，其余的放置在<code>dummyHead2</code>中</li><li>遍历结束后，将<code>dummyHead2</code>插入到<code>dummyHead1</code>后面</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181104095701.gif" alt="动画演示"></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181106090835.png" alt=""></p><h2 id="欢迎关注"><a href="#欢迎关注" class="headerlink" title="欢迎关注"></a>欢迎关注</h2><p>我们会在公众号（<strong>菠了个菜</strong>）每天早上8点30分准时推送一条LeetCode上的算法题目，并给出该题目的动画解析以及参考答案，每篇文章阅读时长为五分钟左右。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分治 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 328 号问题：Odd Even Linked List</title>
      <link href="/posts/770f47b8/"/>
      <url>/posts/770f47b8/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第328号问题：<strong><a href="https://leetcode-cn.com/problems/odd-even-linked-list/" target="_blank" rel="noopener">Odd Even Linked List</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p></blockquote><blockquote><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p></blockquote><blockquote><p><strong>示例 1:</strong></p></blockquote><blockquote><p><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br><strong>输出:</strong> 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</p><p><strong>示例 2:</strong></p></blockquote><blockquote><p><strong>输入:</strong> 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL<br><strong>输出:</strong> 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</p><p><strong>说明:</strong></p></blockquote><blockquote><ul><li>应当保持奇数节点和偶数节点的相对顺序。</li><li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li></ul></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题给了我们一个链表，让我们分开奇偶节点，所有奇节点在前，偶节点在后。</p><ul><li>设定两个虚拟节点，<code>dummyHead1</code>用来保存奇节点，<code>dummyHead2</code>来保存偶节点；</li><li>遍历整个原始链表，将奇节点放于<code>dummyHead1</code>中，其余的放置在<code>dummyHead2</code>中</li><li>遍历结束后，将<code>dummyHead2</code>插入到<code>dummyHead1</code>后面</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzqr3h93g30qk0ewwo3.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzqncct3j30u00ygwmm.jpg" alt=""></p><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkzqplqhmj31sl0u0mzs.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 节点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 3 号问题：Longest Substring Without Repeating Characters</title>
      <link href="/posts/50715/"/>
      <url>/posts/50715/</url>
      
        <content type="html"><![CDATA[<p>leetcode上第3号问题：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">Longest Substring Without Repeating Characters</a></p><blockquote><p>给定一个字符串，找出不含有重复字符的最长子串的长度。</p></blockquote><blockquote><p>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 无重复字符的最长子串是 “abc”，其长度为 3。</p></blockquote><blockquote><p>示例 2:<br>输入: “bbbbb”<br>输出: 1.<br>解释: 无重复字符的最长子串是 “b”，其长度为 1。   </p></blockquote><blockquote><p>示例 3:<br>输入: “pwwkew”<br>输出: 3<br>解释: 无重复字符的最长子串是 “wke”，其长度为 3。<br>请注意，答案必须是一个子串，”pwke” 是一个子序列 而不是子串。</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>建立一个256位大小的整型数组freg，用来建立字符和其出现位置之间的映射。</p><p>维护一个滑动窗口，窗口内的都是没有重复的字符，去尽可能的扩大窗口的大小，窗口不停的向右滑动。</p><ul><li>（1）如果当前遍历到的字符从未出现过，那么直接扩大右边界；</li><li>（2）如果当前遍历到的字符出现过，则缩小窗口（左边索引向右移动），然后继续观察当前遍历到的字符；</li><li>（3）重复（1）（2），直到左边索引无法再移动；</li><li>（4）维护一个结果res，每次用出现过的窗口大小来更新结果res，最后返回res获取结果。</li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzpqfp11g30no0dbjvw.gif" alt="Longest"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 3. Longest Substring Without Repeating Characters// https://leetcode.com/problems/longest-substring-without-repeating-characters/description///// 滑动窗口// 时间复杂度: O(len(s))// 空间复杂度: O(len(charset))class Solution {public:    int lengthOfLongestSubstring(string s) {        int freq[256] = {0};        int l = 0, r = -1; //滑动窗口为s[l...r]        int res = 0;        // 整个循环从 l == 0; r == -1 这个空窗口开始        // 到l == s.size(); r == s.size()-1 这个空窗口截止        // 在每次循环里逐渐改变窗口, 维护freq, 并记录当前窗口中是否找到了一个新的最优值        while(l &lt; s.size()){            if(r + 1 &lt; s.size() &amp;&amp; freq[s[r+1]] == 0){                r++;                freq[s[r]]++;            }else {   //r已经到头 || freq[s[r+1]] == 1                freq[s[l]]--;                l++;            }            res = max(res, r-l+1);        }        return res;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第  349 号问题：Intersection of Two Arrays</title>
      <link href="/posts/6b380d52/"/>
      <url>/posts/6b380d52/</url>
      
        <content type="html"><![CDATA[<p>leetcode上第 349 号问题：<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">Intersection of Two Arrays</a></p><blockquote><p>给定两个数组，编写一个函数来计算它们的交集。</p></blockquote><blockquote><p>示例 1:<br>输入: nums1 = [1,2,2,1], nums2 = [2,2]<br>输出: [2]  </p><p>示例 2:<br>输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>输出: [9,4]</p><p>说明:  </p><ul><li>输出结果中的每个元素一定是唯一的。   </li><li>我们可以不考虑输出结果的顺序。</li></ul></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>容器类<a href="https://zh.cppreference.com/w/cpp/container/set" target="_blank" rel="noopener">set</a>的使用。</p><ul><li>遍历num1，通过set容器record存储num1的元素</li><li>遍历num2，在record中查找是否有相同的元素，如果有，用set容器resultSet进行存储</li><li>将resultSet转换为vector类型</li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzoct4m6g30nk0dbq67.gif" alt="Intersection of Two Arrays"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 349. Intersection of Two Arrays// https://leetcode.com/problems/intersection-of-two-arrays/description/// 时间复杂度: O(nlogn)// 空间复杂度: O(n)class Solution {public:    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        set&lt;int&gt; record;        for( int i = 0 ; i &lt; nums1.size() ; i ++ ){            record.insert(nums1[i]);        }        set&lt;int&gt; resultSet;        for( int i = 0 ; i &lt; nums2.size() ; i ++ ){            if(record.find(nums2[i]) != record.end()){                resultSet.insert(nums2[i]);            }        }        vector&lt;int&gt; resultVector;        for(set&lt;int&gt;::iterator iter = resultSet.begin(); iter != resultSet.end(); iter ++ ){            resultVector.push_back(*iter);        }        return resultVector;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> set </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 350 号问题：Intersection of Two Arrays II</title>
      <link href="/posts/52620/"/>
      <url>/posts/52620/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzmzoiovj31nk0lq76o.jpg" alt=""></p><p>leetcode上第350号问题：<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">Intersection of Two Arrays II</a></p><blockquote><p>给定两个数组，编写一个函数来计算它们的交集。</p></blockquote><blockquote><p>示例 1:<br>输入: nums1 = [1,2,2,1], nums2 = [2,2]<br>输出: [2,2]</p><p>示例 2:<br>输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>输出: [4,9]</p></blockquote><blockquote><p>说明：</p></blockquote><blockquote><ul><li>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。</li><li>我们可以不考虑输出结果的顺序。</li></ul></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>容器类<a href="https://zh.cppreference.com/w/cpp/container/map" target="_blank" rel="noopener">map</a>的使用。</p><ul><li>遍历num1，通过map容器record存储num1的元素与频率</li><li>遍历num2，在record中查找是否有相同的元素（该元素的存储频率大于0），如果有，用map容器resultVector进行存储，同时该元素的频率减一</li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzmwhgg2g30mi0cqac4.gif" alt=""></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 350. Intersection of Two Arrays II// https://leetcode.com/problems/intersection-of-two-arrays-ii/description/// 时间复杂度: O(nlogn)// 空间复杂度: O(n)class Solution {public:    vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        map&lt;int, int&gt; record;        for(int i = 0 ; i &lt; nums1.size() ; i ++){             record[nums1[i]] += 1;        }        vector&lt;int&gt; resultVector;        for(int i = 0 ; i &lt; nums2.size() ; i ++){            if(record[nums2[i]] &gt; 0){                resultVector.push_back(nums2[i]);                record[nums2[i]] --;            }        }        return resultVector;    }};</code></pre><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzmwek5eg30mi0cqac4.gif" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 150 号问题：逆波兰表达式求值</title>
      <link href="/posts/dfbd1df8/"/>
      <url>/posts/dfbd1df8/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第150号问题：<strong><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">逆波兰表达式求值</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>根据逆波兰表示法，求表达式的值。</p></blockquote><blockquote><p>有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p></blockquote><blockquote><h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5></blockquote><blockquote><p>整数除法只保留整数部分。<br>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。   </p><h5 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h5></blockquote><blockquote><p>输入: [“2”, “1”, “+”, “3”, “<em>“]<br>输出: 9<br>解释: ((2 + 1) </em> 3) = 9   </p><h5 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h5></blockquote><blockquote><p>输入: [“4”, “13”, “5”, “/“, “+”]<br>输出: 6<br>解释: (4 + (13 / 5)) = 6   </p><h5 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h5></blockquote><blockquote><p>输入: [“10”, “6”, “9”, “3”, “+”, “-11”, “<em>“, “/“, “</em>“, “17”, “+”, “5”, “+”]<br>输出: 22<br>解释:<br>  ((10 <em> (6 / ((9 + 3) </em> -11))) + 17) + 5<br>= ((10 <em> (6 / (12 </em> -11))) + 17) + 5<br>= ((10 <em> (6 / -132)) + 17) + 5<br>= ((10 </em> 0) + 17) + 5<br>= (0 + 17) + 5<br>= 17 + 5<br>= 22   </p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用数据结构<code>栈</code>来解决这个问题。</p><ul><li>从前往后遍历数组</li><li>遇到数字则压入栈中</li><li>遇到符号，则把栈顶的两个数字拿出来运算，把结果再压入栈中</li><li>遍历完整个数组，栈顶数字即为最终答案</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong><br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzntpqf2g30qx0f4485.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkznqdhk8j30u00wedha.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 237 号问题：Delete Node in a Linked List</title>
      <link href="/posts/497f8fc8/"/>
      <url>/posts/497f8fc8/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第237号问题：<strong><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">Delete Node in a Linked List</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p></blockquote><blockquote><p>现有一个链表 – head = [4,5,1,9]，它可以表示为:</p></blockquote><blockquote><pre><code>4 -&gt; 5 -&gt; 1 -&gt; 9##### 示例 1:</code></pre></blockquote><blockquote><p><strong>输入:</strong> head = [4,5,1,9], node = 5<br><strong>输出:</strong> [4,1,9]<br><strong>解释:</strong> 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt;  9.</p><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h5></blockquote><blockquote><p><strong>输入:</strong> head = [4,5,1,9], node = 1<br><strong>输出:</strong> [4,5,9]<br><strong>解释:</strong> 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.     </p><h5 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h5></blockquote><blockquote><ul><li>链表至少包含两个节点。    </li><li>链表中所有节点的值都是唯一的。     </li><li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。     </li><li>不要从你的函数中返回任何结果。          </li></ul></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>此题注意的点是没有给我们链表的起点，只给我们了一个要删的节点，与以往处理的情况稍许不同。</p><p><strong>这道题的处理方法是先把当前节点的值用下一个节点的值覆盖，然后我们删除下一个节点即可</strong></p><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181105171450.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181105171512.png" alt=""></p><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181105171613.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 219号问题：Contains Duplicate II</title>
      <link href="/posts/15122/"/>
      <url>/posts/15122/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzkn0d3cj316e0jywgm.jpg" alt="Contains Duplicate II"></p><p>leetcode上第219号问题：<a href="https://leetcode.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">Contains Duplicate II</a></p><blockquote><p>给出⼀个整形数组nums和⼀个整数k，是否存在索引i和j，使得nums[i] == nums[j] 且i和j之间的差不超过k</p><p>Example 1:<br>Input: nums = [1,2,3,1], k = 3<br>Output: true. </p><p>Example 2:<br>Input: nums = [1,0,1,1], k = 1<br>Output: true  </p><p>Example 3:<br>Input: nums = [1,2,3,1,2,3], k = 2<br>Output: false</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>考虑用滑动窗口与查找表来解决。</p><ul><li>设置查找表<code>record</code>，用来保存每次遍历时插入的元素，<code>record</code>的最大长度为<code>k</code></li><li>遍历数组<code>nums</code>，每次遍历的时候在<code>record</code>查找是否存在相同的元素，如果存在则返回<code>true</code>，遍历结束</li><li>如果此次遍历在<code>record</code>未查找到，则将该元素插入到<code>record</code>中，而后查看<code>record</code>的长度是否为<code>k + 1</code></li><li>如果此时<code>record</code>的长度是否为<code>k + 1</code>，则删减<code>record</code>的元素，该元素的值为<code>nums[i - k]</code></li><li>如果遍历完整个数组<code>nums</code>未查找到则返回<code>false</code></li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzkiqibwg30qn0er46k.gif" alt="动画演示"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 219. Contains Duplicate II// https://leetcode.com/problems/contains-duplicate-ii/description/// 时间复杂度: O(n)// 空间复杂度: O(k)class Solution {public:    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) {        if(nums.size() &lt;= 1)  return false;        if(k &lt;= 0)  return false;        unordered_set&lt;int&gt; record;        for(int i = 0 ; i &lt; nums.size() ; i ++){            if(record.find(nums[i]) != record.end()){                return true;            }            record.insert(nums[i]);            // 保持record中最多有k个元素            // 因为在下一次循环中会添加一个新元素,使得总共考虑k+1个元素            if(record.size() == k + 1){                record.erase(nums[i - k]);            }        }        return false;    }};</code></pre><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzkgtfhdj31sa0u0acp.jpg" alt="执行结果"></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 查找表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 199 号问题：二叉树的右视图</title>
      <link href="/posts/44435/"/>
      <url>/posts/44435/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第 199 号问题：<strong><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">二叉树的右视图</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p></blockquote><blockquote><p>示例:</p></blockquote><blockquote><p>输入: [1,2,3,null,5,null,4]<br>输出: [1, 3, 4]<br>解释:</p></blockquote><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181115113435.png" alt=""></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>与之前<a href="https://xiaozhuanlan.com/topic/8579460312" target="_blank" rel="noopener">二叉树的层次遍历</a>类似的，该问题需要用到<strong>队列</strong>,</p><ul><li>建立一个queue</li><li>遍历每层的节点时，把下一层的节点都存入到queue中</li><li>每当开始新一层节点的遍历之前，先把新一层最后一个节点值存到结果中</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzk3w6l8g30qg0esn4u.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkzk592lzj30y20u0dh3.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 144 号问题：二叉树的前序遍历</title>
      <link href="/posts/55906/"/>
      <url>/posts/55906/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第 144 号问题：<strong><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">二叉树的前序遍历</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个二叉树，返回它的 前序 遍历。</p></blockquote><blockquote><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4></blockquote><blockquote><p><strong>输入:</strong> [1,null,2,3]  </p></blockquote><p> <img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181109101353.png" alt="">   </p><blockquote><p><strong>输出:</strong> [1,2,3]<br><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用<strong>栈(Stack)</strong>的思路来处理问题。</p><p>前序遍历的顺序为<strong>根-左-右</strong>，具体算法为：</p><ul><li>把根节点push到栈中</li><li>循环检测栈是否为空，若不空，则取出栈顶元素，保存其值</li><li>看其右子节点是否存在，若存在则push到栈中</li><li>看其左子节点，若存在，则push到栈中。</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzj5lp54g30qp0ey48h.gif" alt="动画演示"></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkzj84jmxj30y20u0qc5.jpg" alt="参考代码"></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 102 号问题：二叉树的层次遍历</title>
      <link href="/posts/23450/"/>
      <url>/posts/23450/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第102 号问题：<strong><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层次遍历</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p></blockquote><blockquote><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p></blockquote><blockquote><p> <img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181112084143.png" alt=""></p><p>返回其层次遍历结果：</p></blockquote><blockquote><p>[<br>   [3],<br>   [9,20],<br>   [15,7]<br>]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>该问题需要用到<strong>队列</strong></p><ul><li>建立一个queue</li><li>先把根节点放进去，这时候找根节点的左右两个子节点</li><li>去掉根节点，此时queue里的元素就是下一层的所有节点</li><li>用for循环遍历，将结果存到一个一维向量里</li><li>遍历完之后再把这个一维向量存到二维向量里</li><li>以此类推，可以完成层序遍历</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzexxrigg30qp0ey12m.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkzgwok70j30u0107whf.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 145 号问题：二叉树的后序遍历</title>
      <link href="/posts/16505/"/>
      <url>/posts/16505/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第145 号问题：<strong><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/description/" target="_blank" rel="noopener">二叉树的后序遍历</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个二叉树，返回它的 后序 遍历。</p></blockquote><blockquote><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4></blockquote><blockquote><p><strong>输入:</strong> [1,null,2,3]  </p></blockquote><p> <img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181109101353.png" alt="">   </p><blockquote><p><strong>输出:</strong> [3,2,1]<br><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用<strong>栈(Stack)</strong>的思路来处理问题。</p><p>后序遍历的顺序为<strong>左-右-根</strong>，具体算法为：</p><ul><li>先将根结点压入栈，然后定义一个辅助结点head</li><li>while循环的条件是栈不为空</li><li>在循环中，首先将栈顶结点t取出来</li><li>如果栈顶结点没有左右子结点，或者其左子结点是head，或者其右子结点是head的情况下。我们将栈顶结点值加入结果res中，并将栈顶元素移出栈，然后将head指向栈顶元素</li><li>否则的话就看如果右子结点不为空，将其加入栈</li><li>再看左子结点不为空的话，就加入栈</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong><br><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkzifir92g30qp0ey49p.gif" alt="后序遍历"></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkzigsvjaj31bf0u00yz.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 94 号问题：二叉树的中序遍历</title>
      <link href="/posts/5619/"/>
      <url>/posts/5619/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第 94 号问题：<strong><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个二叉树，返回它的 中序 遍历。</p></blockquote><blockquote><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4></blockquote><blockquote><p><strong>输入:</strong> [1,null,2,3]  </p></blockquote><p> <img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181109101353.png" alt="">   </p><blockquote><p><strong>输出:</strong> [1,3,2]<br><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用<strong>栈(Stack)</strong>的思路来处理问题。</p><p>中序遍历的顺序为<strong>左-根-右</strong>，具体算法为：</p><ul><li>从根节点开始，先将根节点压入栈</li><li>然后再将其所有左子结点压入栈，取出栈顶节点，保存节点值</li><li>再将当前指针移到其右子节点上，若存在右子节点，则在下次循环时又可将其所有左子结点压入栈中</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><strong>动画演示GIF有点大，请稍微等待一下加载显示^_^</strong></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkxkmfacog30qp0eywoh.gif" alt="动画演示"></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkxkq7y97j30u00u17db.jpg" alt="参考代码"></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 中序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 2 号问题：两个数字相加</title>
      <link href="/posts/54060/"/>
      <url>/posts/54060/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第 2 号问题：<strong><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">两个数字相加</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p></blockquote><blockquote><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p></blockquote><blockquote><h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5></blockquote><blockquote><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>设立一个表示进位的变量<code>carried</code>，建立一个新链表，把输入的两个链表从头往后同时处理，每两个相加，将结果加上<code>carried</code>后的值作为一个新节点到新链表后面。</p><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkxjfcatug30qh0eon5c.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkxjhpat9j30ub0u0n4r.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 上第 26 号问题：删除排序数组中的重复项</title>
      <link href="/posts/46534/"/>
      <url>/posts/46534/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第26 号问题：<strong><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">删除排序数组中的重复项</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><blockquote><p>给定数组 nums = [1,1,2], </p></blockquote><blockquote><p>函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </p></blockquote><blockquote><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><blockquote><p>给定 nums = [0,0,1,1,1,2,2,3,3,4],</p></blockquote><blockquote><p>函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</p></blockquote><blockquote><p>你不需要考虑数组中超出新长度后面的元素。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用快慢指针来记录遍历的坐标。</p><ul><li>开始时这两个指针都指向第一个数字</li><li>如果两个指针指的数字相同，则快指针向前走一步</li><li>如果不同，则两个指针都向前走一步</li><li>当快指针走完整个数组后，慢指针当前的坐标加1就是数组中不同数字的个数</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzkxjo8a76g30qg0esju1.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkxjmqk58j30xo0tktci.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 上第 454 号问题：4Sum II</title>
      <link href="/posts/48182/"/>
      <url>/posts/48182/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 上第 454 号问题：<strong><a href="https://leetcode-cn.com/problems/4sum-ii/" target="_blank" rel="noopener">4Sum II</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] &gt; + B[j] + C[k] + D[l] = 0。</p></blockquote><blockquote><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。</p></blockquote><blockquote><p><em>例如:</em></p></blockquote><blockquote><p>输入:<br>A = [ 1, 2]<br>B = [-2,-1]<br>C = [-1, 2]<br>D = [ 0, 2] </p></blockquote><blockquote><p>输出:<br>2 </p><p>解释:<br>两个元组如下:       </p><ol><li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0  </li><li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</li></ol></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>与<a href="https://xiaozhuanlan.com/topic/7923618450" target="_blank" rel="noopener">Two Sum</a>类似，需要用哈希表来解决问题。</p><ul><li>把A和B的两两之和都求出来，在哈希表中建立两数之和与其出现次数之间的映射</li><li>遍历C和D中任意两个数之和，只要看哈希表存不存在这两数之和的相反数就行了</li></ul><p>##动画演示</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkxffnjo7g30np0dbadt.gif" alt="4Sum II"></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><pre><code>// 454. 4Sum II// https://leetcode.com/problems/4sum-ii/description/// 时间复杂度: O(n^2)// 空间复杂度: O(n^2)class Solution {public:    int fourSumCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) {        unordered_map&lt;int,int&gt; hashtable;        for(int i = 0 ; i &lt; A.size() ; i ++){            for(int j = 0 ; j &lt; B.size() ; j ++){                 hashtable[A[i]+B[j]] += 1;            }        }        int res = 0;        for(int i = 0 ; i &lt; C.size() ; i ++){            for(int j = 0 ; j &lt; D.size() ; j ++){                if(hashtable.find(-C[i]-D[j]) != hashtable.end()){                    res += hashtable[-C[i]-D[j]];                }            }        }        return res;    }};</code></pre><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzkxfhd78yj313c0i5wfd.jpg" alt="执行结果"></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 447 号问题：Number of Boomerangs</title>
      <link href="/posts/32213/"/>
      <url>/posts/32213/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第 447 号问题：<a href="https://leetcode-cn.com/problems/number-of-boomerangs/" target="_blank" rel="noopener">Number of Boomerangs</a></p><blockquote><p>给定平面上 n 对不同的点，“回旋镖” 是由点表示的元组 (i, j, k) ，其中 i 和 j 之间的距离和 &gt; i 和 k 之间的距离相等（需要考虑元组的顺序）。</p></blockquote><blockquote><p>找到所有回旋镖的数量。你可以假设 n 最大为 500，所有点的坐标在闭区间 [-10000, 10000] 中。</p></blockquote><blockquote><p>示例:</p></blockquote><blockquote><p>输入:<br>[[0,0],[1,0],[2,0]]   </p></blockquote><blockquote><p>输出:<br>2</p></blockquote><blockquote><p>解释:<br>两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>n最大为500，可以使用时间复杂度为 O(n^2)的算法。</p><ul><li>遍历所有的点，让每个点作为一个锚点</li><li>然后再遍历其他的点，统计和锚点距离相等的点有多少个</li><li>然后分别带入n(n-1)计算结果并累加到res中</li></ul><h5 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h5><h6 id="Tip1"><a href="#Tip1" class="headerlink" title="Tip1"></a>Tip1</h6><ul><li>如果有一个点a，还有两个点b和c，如果ab和ac之间的距离相等，那么就有两种排列方法abc和acb；</li><li>如果有三个点b，c，d都分别和a之间的距离相等，那么有六种排列方法，abc, acb, acd, adc, abd, adb；</li><li>如果有n个点和点a距离相等，那么排列方式为n(n-1)。</li></ul><h6 id="Tip2"><a href="#Tip2" class="headerlink" title="Tip2"></a>Tip2</h6><ul><li>计算距离时不进行开根运算, 以保证精度；</li><li>只有当n大于等于2时，res值才会真正增加，因为当n=1时，增加量为<code>1*(1-1)=0</code>。</li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkx8sx3zlg30qn0estfw.gif" alt=""></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>// 447. Number of Boomerangs// https://leetcode.com/problems/number-of-boomerangs/description/// 时间复杂度: O(n^2)// 空间复杂度: O(n)class Solution {public:    int numberOfBoomerangs(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) {        int res = 0;        for( int i = 0 ; i &lt; points.size() ; i ++ ){            // record中存储 点i 到所有其他点的距离出现的频次            unordered_map&lt;int, int&gt; record;            for(int j = 0 ; j &lt; points.size() ; j ++){                if(j != i){                    // 计算距离时不进行开根运算, 以保证精度                    record[dis(points[i], points[j])] += 1;                }            }            for(unordered_map&lt;int, int&gt;::iterator iter = record.begin() ; iter != record.end() ; iter ++){                res += (iter-&gt;second) * (iter-&gt;second - 1);            }        }        return res;    }private:    int dis(const pair&lt;int,int&gt; &amp;pa, const pair&lt;int,int&gt; &amp;pb){        return (pa.first - pb.first) * (pa.first - pb.first) +               (pa.second - pb.second) * (pa.second - pb.second);    }};</code></pre><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181030113403.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 元祖 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode上第 103 号问题：二叉树的锯齿形层次遍历</title>
      <link href="/posts/37190/"/>
      <url>/posts/37190/</url>
      
        <content type="html"><![CDATA[<p>LeetCode上第103 号问题：<strong><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">二叉树的锯齿形层次遍历</a></strong></p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p></blockquote><blockquote><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p></blockquote><blockquote><p> <img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181112084143.png" alt=""></p><p>返回其层次遍历结果：</p></blockquote><blockquote><p>[<br>   [3],<br>   [20,9],<br>   [15,7]<br>]</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>该问题需要用到<strong>队列</strong>，与之前的<a href="https://xiaozhuanlan.com/topic/8579460312" target="_blank" rel="noopener">二叉树的层次遍历</a>类似，不同点在于在偶数层需要翻转一下。</p><ul><li>建立一个queue</li><li>先把根节点放进去，这时候找根节点的左右两个子节点</li><li>去掉根节点，此时queue里的元素就是下一层的所有节点</li><li>循环遍历，将结果存到一个一维向量里</li><li>遍历完之后再把这个一维向量存到二维向量里</li><li>如果该层为偶数层，则reverse翻转一下</li><li>以此类推，可以完成层序遍历</li></ul><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzkx5g05uxg30qg0esgy0.gif" alt=""></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzkx56go9ij30xa0u0wgi.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始搭建一个酷炫免费的个人博客</title>
      <link href="/posts/6993/"/>
      <url>/posts/6993/</url>
      
        <content type="html"><![CDATA[<h1 id="【新手向】从零开始搭建一个酷炫免费的个人博客"><a href="#【新手向】从零开始搭建一个酷炫免费的个人博客" class="headerlink" title="【新手向】从零开始搭建一个酷炫免费的个人博客"></a>【新手向】从零开始搭建一个酷炫免费的个人博客</h1><p>由于公众号的文章不易后续整理阅读，于是小吴昨天上午花了半个小时使用 GitHub + Hexo 搭建了一下个人博客，打算将公众号的文章搬过去，支持关键字搜索、分类标签功能。效果是下面这样子的👇</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk130ii6qg313l0ixx6q.gif" alt=""></p><p>结果后台好多小伙伴挺好奇博客是怎么搭建的，实际上这个挺简单的，小吴就从零开始分享一波如何搭建一个酷炫免费的个人博客吧，如果已经有博客的小伙伴可以留言一波网站地址：）</p><h3 id="GitHub创建个人仓库"><a href="#GitHub创建个人仓库" class="headerlink" title="GitHub创建个人仓库"></a>GitHub创建个人仓库</h3><p>登录到 GitHub ，如果没有 GitHub 帐号，请使用你的邮箱注册 GitHub 帐号：<a href="https://github.com/join?source=header-home" target="_blank" rel="noopener">https://github.com/join?source=header-home</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk21xjx8gj31420myn1f.jpg" alt="注册"></p><p>登录成功之后，点击 GitHub 中的 New repository 创建新仓库，仓库名应该为：<strong>用户名</strong> .github.io 。这里<strong>用户名</strong>使用你的 GitHub 帐号名称代替，这是固定写法。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzk2601f8kg313l0ixqca.gif" alt="创建新仓库"></p><p>ps: 因为我已经注册了同名仓库，因此第二次创建时会报错。</p><p>我的仓库名为👇：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk29gwq48j30fu03igls.jpg" alt="仓库名"></p><h3 id="Git管理"><a href="#Git管理" class="headerlink" title="Git管理"></a>Git管理</h3><p>Git 是目前世界上最先进的分布式版本控制系统（没有之一）。这是使用 Git 的目的是为了将我们的网站从本地提交上服务器（GitHub）上面去。我认为 Git 操作是程序员应该具备的一个基本操作，具体的 Git 操作细节可以查看廖雪峰的教程，讲的十分详细 <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk2hsewy8j313r0k0n5i.jpg" alt=""></p><p>安装好 Git 后，只需要进行下面的配置即可。</p><h4 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h4><p>在终端进行操作，设置 user.name 和 user.email 配置信息，我这里设置为全局。</p><pre class=" language-java"><code class="language-java">git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>name <span class="token string">"你的GitHub用户名"</span>git config <span class="token operator">--</span>global user<span class="token punctuation">.</span>email <span class="token string">"你的GitHub注册邮箱"</span></code></pre><h4 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h4><p>通过注册的邮箱生成 ssh 密钥文件：</p><pre class=" language-bash"><code class="language-bash">ssh-keygen -t rsa -C <span class="token string">"你的GitHub注册邮箱"</span></code></pre><p>然后直接三个回车即可，默认不需要设置密码。最后得到了两个文件：<code>id_rsa</code>和<code>id_rsa.pub</code>。</p><h4 id="拷贝密钥"><a href="#拷贝密钥" class="headerlink" title="拷贝密钥"></a>拷贝密钥</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk2vog35vj30mw0f2mzq.jpg" alt="拷贝密钥"></p><p>打开 <code>id_rsa.pub 文件</code>，将里面的内容全部复制。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzk2xjwnthj30tv0b5dh4.jpg" alt="内容全部复制"></p><h4 id="粘贴到GitHub"><a href="#粘贴到GitHub" class="headerlink" title="粘贴到GitHub"></a>粘贴到GitHub</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzk36z40lzj313s0k1n08.jpg" alt="GitHub SSh"></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk376rh7yj313r0ketbj.jpg" alt="添加新的 SSH"></p><h4 id="测试GitHub-SSH"><a href="#测试GitHub-SSH" class="headerlink" title="测试GitHub SSH"></a>测试GitHub SSH</h4><p>添加好 <code>SSH Key</code>后，进行测试。</p><pre><code>ssh -T git@github.com</code></pre><p>你将会看到：</p><pre><code>The authenticity of host &#39;github.com (207.97.227.239)&#39; can&#39;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)?</code></pre><p>选择 <code>yes</code></p><pre><code>Hi MisterBooo! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk3bfd4wzj30i10213yk.jpg" alt="ssh -T"></p><p>如果看到<code>Hi</code>后面是你的用户名，就说明成功了。</p><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>Hexo 基于 Node.js，因此需要先安装 Node.js，你可以在这里进行对应电脑版本的下载：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzk3ecq45aj313u0jkju0.jpg" alt="Node.js下载"></p><p>你也可以通过命令行进行安装：</p><p>cURL:</p><pre><code>$ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</code></pre><p>Wget:</p><pre><code>$ wget -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh | sh</code></pre><p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p><pre><code>$ nvm install stable</code></pre><h3 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h3><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><pre><code>$ npm install -g hexo-cli</code></pre><h3 id="Hexo使用"><a href="#Hexo使用" class="headerlink" title="Hexo使用"></a>Hexo使用</h3><p>安装好 Hexo 后，马上就能使用了。首先初始化博客，输入：</p><pre><code>$ hexo init myBlog</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk3pvt34mj319f0u0qcz.jpg" alt=""></p><p>接下来，进入文件夹 <code>myBlog</code>,输入</p><pre><code>$ hexo s</code></pre><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk3s50l94j30hy054t96.jpg" alt=""></p><p>然后，打开浏览器输入地址：</p><pre><code>localhost:4000</code></pre><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk3te442qj313t0n1gxs.jpg" alt="hexo网站"></p><p>执行到这里事实上博客就已经搭建好了，接下来就是去完善它。</p><p>注意：下面的命令都是在 <code>myBlog</code>文件里进行操作的。</p><h3 id="添加文章"><a href="#添加文章" class="headerlink" title="添加文章"></a>添加文章</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk7dls02rj31840kiaco.jpg" alt="添加文章"></p><h4 id="1-直接导入文章"><a href="#1-直接导入文章" class="headerlink" title="1.直接导入文章"></a>1.直接导入文章</h4><p>你可以将你平时写的文章直接导入到 <code>_posts</code>  文件夹里，注意文章类型得是 <code>md</code>格式。</p><h4 id="2-写新文章"><a href="#2-写新文章" class="headerlink" title="2.写新文章"></a>2.写新文章</h4><p>你可以执行下列命令来创建一篇新文章。</p><pre><code>$ hexo new [layout] &lt;title&gt;</code></pre><p>你可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fzk7hoiy3ij30z6042q3w.jpg" alt="写新文章"></p><p>这样在 <code>_posts</code>  文件夹里也生成了一篇新的文章。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzk7j5ffx5j316c0ewmzp.jpg" alt="新的文章"></p><h3 id="生成网页"><a href="#生成网页" class="headerlink" title="生成网页"></a>生成网页</h3><p>使用 Hexo 生成静态文件快速而且简单。</p><pre><code>$ hexo generate</code></pre><p>你也可以简写成</p><pre><code>$ hexo g</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk7n3i1jyj318d0u0wpf.jpg" alt="生成文章"></p><h3 id="启动服务预览文章"><a href="#启动服务预览文章" class="headerlink" title="启动服务预览文章"></a>启动服务预览文章</h3><p>输入以下命令以启动服务器，你的网站会在 <code>http://localhost:4000</code> 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，无须重启服务器。</p><pre><code>$ hexo server</code></pre><p>你也可以简写成</p><pre><code>$ hexo s</code></pre><p>如果你想要更改端口，或是在执行时遇到了 <code>EADDRINUSE</code> 错误，可以在执行时使用 <code>-p</code> 选项指定其他端口，如下：</p><pre><code>$ hexo server -p 5000</code></pre><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzk7pthinwj315606kdhh.jpg" alt="查看文章"></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzk7rs1dp8j31iy0u0e81.jpg" alt="网站"></p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><pre><code>hexo new &quot;我的博客文章&quot; #新建文章</code></pre><pre><code>hexo generate #生成网页</code></pre><pre><code>hexo server #启动服务预览</code></pre><p>这三个命令依次就是新建一篇博客文章、生成网页、在本地预览的操作。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>Hexo 提供了快速方便的一键部署功能，只需一条命令就能将网站部署到服务器上。</p><pre><code>$ hexo deploy</code></pre><p>你也可以简写成</p><pre><code>$ hexo d</code></pre><p>在开始之前，必须先在 <code>_config.yml</code> 中修改参数，一个正确的部署配置中至少要有 <code>type</code> 参数，例如：</p><pre><code>deploy:  type: git</code></pre><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk7w0wzlyj30mk0eetae.jpg" alt="config"></p><p>在<code>_config.yml</code>中进行修改。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fzk7xrf4smj30y40u00yx.jpg" alt=""></p><p>这一步的目的是将 Hexo 与 GitHub 进行关联。</p><p>配置好后通过</p><pre><code>$ hexo d</code></pre><p>命令，稍等片刻，网站就已经部署好了，可以在浏览器输入<code>你的GitHub名称.github.io</code>，这样一个免费的博客就已经搭建好了。</p><h3 id="Hexo-主题"><a href="#Hexo-主题" class="headerlink" title="Hexo 主题"></a>Hexo 主题</h3><p>hexo 默认的主题可能显得有点呆板，你可以在 <a href="https://hexo.io/themes/index.html" target="_blank" rel="noopener">https://hexo.io/themes/index.html</a>进行主题的挑选更换。将下好的主题安放在<code>themes</code>文件夹内，同时在<code>_config.yml</code>中进行主题修改就好了。</p><p>经过一个小时的主题筛选，我选择了<code>hexo-theme-matery</code> 这款主题。通过<a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/" target="_blank" rel="noopener">https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/</a>文档说明，经过简单的配置，效果就出来了！</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzk9f1968uj30yk0jmtb2.jpg" alt=""></p><p>一般大佬们提供的主题都会提供文档说明，按照说明进行简单的设置就能拥有一个酷炫的页面了。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fzk130ii6qg313l0ixx6q.gif" alt=""></p><h3 id="Markdown-写作"><a href="#Markdown-写作" class="headerlink" title="Markdown 写作"></a>Markdown 写作</h3><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><p>世面上支持 Markdown 语法的编辑器不胜枚举，选择起来十分困难，小吴在这里推荐 Typora 这款 Markdown 写作软件。</p><p> Typora 是一款免费的 MD 编辑器，它是优雅简洁与强大开放的完美结合体。</p><p>官网直达 <a href="https://typora.io" target="_blank" rel="noopener">https://typora.io</a></p><h4 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h4><p>选择 Typora 一个最主要的原因是它对图片的良好支持。</p><p>在 Mac 上安装好 iPic 后 ，并在设置中将图片插入修改为 通过 iPic 上传 ，快捷键是 control + command + i ，就可以十分快捷优雅地完成图片插入。强调一点：图床使用默认的微博图床即可，建议不要折腾。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzk9r3q6toj30s40rwh1u.jpg" alt=""></p><p>这样，每次写作时，将图片拖入到 Typora 里，图片就能自动上传到图床上。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>申请 GitHub 账号</p></li><li><p>在 GitHub 上创建仓库</p></li><li><p>配备 Git ，同时将 SSH Key 提交到 GitHub 上</p></li><li><p>安装 Node.js</p></li><li><p>安装 Hexo</p></li><li><p>安装 Hexo 主题</p></li><li><p>使用 Markdown 软件写文章</p></li></ul><p>希望这篇文章能帮到想写博客却还没付诸行动的人，毕竟拥有一个免费且酷炫的博客还是挺简单还挺好玩的：）</p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> 新手 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode上第 75 号问题： Two Sum II</title>
      <link href="/posts/34840/"/>
      <url>/posts/34840/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/10/29/166bdc86b1885e65?w=2294&amp;h=1412&amp;f=png&amp;s=261824" alt=""><br>leetcode上第75号问题：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">Two Sum II</a></p><blockquote><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p></blockquote><blockquote><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p></blockquote><blockquote><p>说明:</p></blockquote><blockquote><ul><li>返回的下标值（index1 和 index2）不是从零开始的。</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ul></blockquote><blockquote><p>示例:</p></blockquote><blockquote><p>输入: numbers = [2, 7, 11, 15], target = 9<br>输出: [1,2]<br>解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>初始化左指针left指向数组起始，初始化右指针right指向数组结尾。</p><p>根据<strong>已排序</strong>这个特性，</p><ul><li><p>（1）如果numbers[left]与numbers[right]的和tmp小于target，说明应该增加tmp,因此left右移指向一个较大的值。</p></li><li><p>（2）如果tmp大于target，说明应该减小tmp,因此right左移指向一个较小的值。</p></li><li><p>（3）tmp等于target，则找到，返回left+1和right+1。（注意以1为起始下标）</p></li></ul><h4 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h4><p><img src="https://user-gold-cdn.xitu.io/2018/10/29/166bdc5dfb63ea8d?w=853&amp;h=457&amp;f=gif&amp;s=69203" alt=""></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对撞指针</span><span class="token comment" spellcheck="true">// 时间复杂度: O(n)</span><span class="token comment" spellcheck="true">// 空间复杂度: O(1)</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">twoSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> numbers<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> res<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>l<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> res<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>numbers<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+</span> numbers<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span>                l <span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token comment" spellcheck="true">// numbers[l] + numbers[r] > target</span>                r <span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode上第 283 号问题： Move Zeros</title>
      <link href="/posts/5847/"/>
      <url>/posts/5847/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669facb3a2bb86e?w=1240&amp;h=574&amp;f=png&amp;s=228428" alt="Move Zeros"><br>leetcode上第283号问题：<a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">Move Zeros</a></p><blockquote><p>给定一个数组nums，写一个函数，将数组中所有的0挪到数组的末尾，⽽维持其他所有非0元素的相对位置。<br>举例: nums = [0, 1, 0, 3, 12]，函数运⾏后结果为[1, 3, 12, 0, 0]</p></blockquote><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>思路：创建一个临时数组nonZeroElements，遍历nums，将nums中非0元素赋值到nonZeroElements中，而后按顺序将nonZeroElements赋值到nums上，未遍历的元素置0；</p><p>动画如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669facb3a048c12?w=420&amp;h=203&amp;f=gif&amp;s=60758" alt="image"></p><p>代码如下：</p><pre><code>// 时间复杂度: O(n)// 空间复杂度: O(n)class Solution {public:    void moveZeroes(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; nonZeroElements;        // 将vec中所有非0元素放入nonZeroElements中        for(int i = 0 ; i &lt; nums.size() ; i ++)            if(nums[i])                nonZeroElements.push_back(nums[i]);        // 将nonZeroElements中的所有元素依次放入到nums开始的位置        for(int i = 0 ; i &lt; nonZeroElements.size() ; i ++)            nums[i] = nonZeroElements[i];        // 将nums剩余的位置放置为0        for(int i = nonZeroElements.size() ; i &lt; nums.size() ; i ++)            nums[i] = 0;    }};</code></pre><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>思路：设定一个临时变量k=0，遍历数组nums，将非零元素移动到nums[k]位置，同时k++，而后将【k,….nums.size()】中的元素置零。</p><p>动画如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669facb3a3f2742?w=744&amp;h=418&amp;f=gif&amp;s=104124" alt="image"></p><p>代码如下：</p><pre><code>// 原地(in place)解决该问题// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    void moveZeroes(vector&lt;int&gt;&amp; nums) {        int k = 0; // nums中, [0...k)的元素均为非0元素        // 遍历到第i个元素后,保证[0...i]中所有非0元素        // 都按照顺序排列在[0...k)中        for(int i = 0 ; i &lt; nums.size() ; i ++)            if(nums[i])                nums[k++] = nums[i];        // 将nums剩余的位置放置为0        for(int i = k ; i &lt; nums.size() ; i ++)            nums[i] = 0;    }};</code></pre><h3 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h3><p>思路：设定一个临时变量k=0，遍历数组nums，将非零元素与之前的零元素进行交换，维护变量k的值。</p><p>动画如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/23/1669facb3a1f570c?w=744&amp;h=418&amp;f=gif&amp;s=92514" alt="image"></p><p>代码如下：</p><pre><code>// 原地(in place)解决该问题// 时间复杂度: O(n)// 空间复杂度: O(1)class Solution {public:    void moveZeroes(vector&lt;int&gt;&amp; nums) {        int k = 0; // nums中, [0...k)的元素均为非0元素        // 遍历到第i个元素后,保证[0...i]中所有非0元素        // 都按照顺序排列在[0...k)中        // 同时, [k...i] 为 0        for(int i = 0 ; i &lt; nums.size() ; i ++)            if(nums[i])                if(k != i)                    swap(nums[k++] , nums[i]);                else                    k ++;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示桶排序</title>
      <link href="/posts/19338/"/>
      <url>/posts/19338/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解桶排序"><a href="#【图解数据结构】-一组动画彻底理解桶排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解桶排序"></a>【图解数据结构】 一组动画彻底理解桶排序</h1><p>由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 —–《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。</p><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序(Bucket sort)是一种基于计数的排序算法（<strong>计数排序</strong>可参考上节的内容），工作的原理是将数据分到有限数量的桶子里，然后每个桶再分别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>设置固定数量的空桶。</p></li><li><p>把数据放到对应的桶中。</p></li><li><p>对每个不为空的桶中数据进行排序。</p></li><li><p>拼接不为空的桶中数据，得到结果。</p></li></ol><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/29/1675ceff66c00fe7?w=955&amp;h=539&amp;f=gif&amp;s=1026397" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，设置固定数量的空桶，在这里为了方便演示，设置桶的数量为 5 个空桶</p></li><li><p>遍历整个数列，找到最大值为 56 ，最小值为 2 ，每个桶的范围为 （ 56 - 2 + 1 ）/ 5 = 11</p></li><li><p>再次遍历整个数列，按照公式 floor((数字 – 最小值) / 11) 将数字放到对应的桶中</p></li><li><p>比如，数字 7 代入公式 floor((7 – 2) / 11) = 0 放入 0 号桶</p></li><li><p>数字 12 代入公式 floor((12 – 2) / 11) = 0 放入 0 号桶</p></li><li><p>数字 56 代入公式 floor((56 – 2) / 11) = 4 放入 4 号桶</p></li><li><p>当向同一个索引的桶，第二次插入数据时，判断桶中已存在的数字与新插入数字的大小，按照左到右，从小到大的顺序插入（可以使用前面讲解的<strong>插入排序</strong>）实现</p></li><li><p>比如，插入数字 19 时， 1 号桶中已经有数字 23 ，在这里使用插入排序，让 19 排在 23 前面</p></li><li><p>遍历完整个数列后，合并非空的桶，按从左到右的顺序合并0，1，2，3，4桶。</p></li><li><p>这样就完成了 <strong>桶排序</strong></p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/29/1675ceff669fd15d?w=1864&amp;h=2122&amp;f=png&amp;s=80844" alt=""></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/29/1675ceff66c62d33?w=2016&amp;h=3272&amp;f=png&amp;s=170854" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/29/1675ceff66b31247?w=2048&amp;h=2260&amp;f=png&amp;s=131496" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 桶排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示快速排序</title>
      <link href="/posts/19819/"/>
      <url>/posts/19819/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解快速排序"><a href="#【图解数据结构】-一组动画彻底理解快速排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解快速排序"></a>【图解数据结构】 一组动画彻底理解快速排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 —–《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>从数列中挑出一个元素，称为 “基准”（pivot）;</p></li><li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p></li><li><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p></li></ol><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e00a0d10d84d?w=950&amp;h=534&amp;f=gif&amp;s=492246" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，操作数列中的所有数字</p></li><li><p>在所有数字中选择一个数字作为排序的基准（pivot）, pivot 通常是随机选择的，在这里为了演示方便，我们选择最右边的数字作为 pivot</p></li><li><p>选取好 pivot 后，在操作数列中选择最左边的数字标记为 左标记 ，最右边的数字标记为 右标记</p></li><li><p>将左边的标记向右移动</p></li><li><p>当 左标记 达到超过 pivot 的数字时，停止移动</p></li><li><p>在这里，8 &gt; 6 ,所以停止移动</p></li><li><p>然后将右边的标记向左移动</p></li><li><p>当 右标记 达到小于 pivot 的数字时，停止移动</p></li><li><p>在这里，4 &gt; 6 ,所以停止移动</p></li><li><p>当左右标记停止时，更改标记的数字</p></li><li><p>因此，左标记 的作用是找到一个大于 pivot 的数字，右标记 的作用是找到一个小于 pivot 的数字</p></li><li><p>通过交换数字，可以在数列的左边收集小于 pivot 的数字集合，右边收集大于 pivot 的数字集合</p></li><li><p>交换之后，继续移动 左标记</p></li><li><p>在这里，9 &gt; 6 ,所以停止移动</p></li><li><p>然后将右边的标记向左移动</p></li><li><p>当 右标记 碰撞到 左标记 时也停止移动</p></li><li><p>如果左右侧的标记停止时，并且都在同一个位置，将这个数字和 pivot 的数字交换</p></li><li><p>这就完成了第一次操作</p></li><li><p>小于 6 的都在 6 的左侧，大于 6 的都在 6 的右侧</p></li><li><p>然后递归对这分成的两部分都执行同样的操作</p></li><li><p>完成 快速排序</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e00a0dc023d8?w=1392&amp;h=1524&amp;f=png&amp;s=68959" alt="C++代码实现"></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e00a0cb5d352?w=1668&amp;h=2214&amp;f=png&amp;s=109067" alt="Java代码实现"></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e00a0c058ac5?w=1756&amp;h=1432&amp;f=png&amp;s=74882" alt="Python代码实现"></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/1673e00a0e6e21b7?w=1572&amp;h=2950&amp;f=png&amp;s=139434" alt="JavaScript代码实现"></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示基数排序</title>
      <link href="/posts/56526/"/>
      <url>/posts/56526/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解基数排序"><a href="#【图解数据结构】-一组动画彻底理解基数排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解基数排序"></a>【图解数据结构】 一组动画彻底理解基数排序</h1><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序 (Radix Sort) 是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。基数排序的发明可以追溯到 1887 年赫尔曼·何乐礼在打孔卡片制表机 (Tabulation Machine)上的贡献。</p><p>基数排序法会使用到桶 (Bucket)，顾名思义，通过将要比较的位（个位、十位、百位…），将要排序的元素分配至 0~9 个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其它的比较性排序法。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零</p></li><li><p>从最低位开始，依次进行一次排序</p></li><li><p>从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列</p></li></ol><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p>动画演示GIF加载有点慢，请稍等片刻^_^<br><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181128114235.gif" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>基数排序的方式可以采用 LSD (Least sgnificant digital) 或 MSD (Most sgnificant digital)</p></li><li><p>在本例中使用的是 <strong>LSD</strong></p></li><li><p>首先创建编号 0 ， 1 ，2 ，3 ，4 ，5 ， 6 ，7 ，8 ，9 这 10 个桶 </p></li><li><p>遍历整个数列，查看数字的个位数，按照先后顺序存放在对应编号的桶中</p></li><li><p>比如 321 个位数 为 1 ，存放在编号 1 桶中</p></li><li><p>数字 1 个位数 为 1 ，存放在编号 1 桶中，同时存放在 321 上面 </p></li><li><p>遍历完整个数列的个位数，将数字存放在桶中后，按照编号顺序取出数字，先放入桶中的数字先取出</p></li><li><p>然后依次遍历整个数列的十位数，按照上述个位数的操作整理数列</p></li><li><p>依次遍历整个数列的百位数，按照上述个位数的操作整理数列</p></li><li><p>这样就完成了 <strong>基数排序</strong></p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181128123735.png" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181128123743.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 基数排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示选择排序</title>
      <link href="/posts/43330/"/>
      <url>/posts/43330/</url>
      
        <content type="html"><![CDATA[<p># </p><h1 id="【图解数据结构】-一组动画演示选择排序"><a href="#【图解数据结构】-一组动画演示选择排序" class="headerlink" title="【图解数据结构】 一组动画演示选择排序"></a>【图解数据结构】 一组动画演示选择排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 —–《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</p></li><li><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p></li><li><p>重复第二步，直到所有元素均排序完毕。</p></li></ol><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/16738f0f5824e2d8?w=955&amp;h=538&amp;f=gif&amp;s=346690" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>线性搜索数列并找到最小值，此时找到了为 2</p></li><li><p>将最小值替换为数列中左端的数字，即将 2 与 4 进行交换</p></li><li><p>此时 2 已经排序好</p></li><li><p>继续线性搜索剩余数列找到最小值，此时找到了 3</p></li><li><p>将最小值替换为数列中左端的数字，即将 3 与 4 进行交换</p></li><li><p>此时 2 与 3 已经排序好</p></li><li><p>继续线性搜索剩余数列找到最小值，此时找到了 4</p></li><li><p>如果最小值已经在左端，那么不执行任何操作，所以此时不做任何处理</p></li><li><p>此时 2 、 3  、 4 已经排序好</p></li><li><p>重复相同操作，直到所有数字都被排序</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/16738f0eff237d54?w=1148&amp;h=972&amp;f=png&amp;s=36827" alt=""></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/16738f0f0a65d4cf?w=1668&amp;h=1708&amp;f=png&amp;s=75701" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/16738f0ef955a299?w=1604&amp;h=1110&amp;f=png&amp;s=51471" alt=""></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/22/16738f0f0156b4cc?w=1452&amp;h=880&amp;f=png&amp;s=44413" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 选择排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一组动画演示归并排序</title>
      <link href="/posts/7604/"/>
      <url>/posts/7604/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画演示归并排序"><a href="#【图解数据结构】-一组动画演示归并排序" class="headerlink" title="【图解数据结构】 一组动画演示归并排序"></a>【图解数据结构】 一组动画演示归并排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 —–《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。</p><h2 id="归并排序（Merge-sort"><a href="#归并排序（Merge-sort" class="headerlink" title="归并排序（Merge sort"></a>归并排序（Merge sort</h2><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ul><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li><li>自下而上的迭代；</li></ul><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p></li><li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p></li><li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p></li><li><p>重复步骤 3 直到某一指针达到序列尾；</p></li><li><p>将另一序列剩下的所有元素直接复制到合并序列尾。</p></li></ol><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16733b1a9c74ce50?w=955&amp;h=538&amp;f=gif&amp;s=586156" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，将数字分割成两片区域</p></li><li><p>将数字分割成两片区域</p></li><li><p>。。。。。。</p></li><li><p>直到每片区域只有一个元素</p></li><li><p>分割完成</p></li><li><p>接下来，将分割的每片区域进行合并组合</p></li><li><p>合并时，按照数字的升序移动，使得合并后的数字在组内按升序排列</p></li><li><p>当合并包含多个数字的组时，比较开头的数字，移动其中较小的数字</p></li><li><p>比如在动画中，比较开头的 4 和 3 </p></li><li><p>其中 4 大于 3， 因此移动 3</p></li><li><p>按照同样的逻辑去比较该列剩余的头数</p></li><li><p>4 小于 7 ，所以移动 4</p></li><li><p>。。。。。。</p></li><li><p>递归的重复组的合并操作，直到所有数字都在一个组中。</p></li><li><p>完成 归并排序 啦~</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16733b1a9c8f7fff?w=1832&amp;h=1708&amp;f=png&amp;s=85502" alt="C++代码实现"></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16733b1a9db220c7?w=1668&amp;h=2444&amp;f=png&amp;s=128379" alt="Java代码实现"></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16733b1a9dd4b5f7?w=1322&amp;h=1294&amp;f=png&amp;s=64894" alt="Python代码实现"></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/21/16733b1a9dcea382?w=1344&amp;h=1800&amp;f=png&amp;s=76855" alt="JavaScript代码实现"></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示冒泡排序</title>
      <link href="/posts/13239/"/>
      <url>/posts/13239/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画演示冒泡排序"><a href="#【图解数据结构】-一组动画演示冒泡排序" class="headerlink" title="【图解数据结构】 一组动画演示冒泡排序"></a>【图解数据结构】 一组动画演示冒泡排序</h1><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p></li><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p></li><li><p>针对所有的元素重复以上的步骤，除了最后一个。</p></li><li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p></li></ol><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181119200024.gif" alt="五分钟学算法之冒泡排序"></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>将天平放在序列的右端，并比较天平左右的数字</p></li><li><p>在这种情况下我们比较 3 和 8 </p></li><li><p>比较后如果右边的数字较小，则被交换</p></li><li><p>因为 8 大于 3 ，所以数字不用交换</p></li><li><p>比较完成后，将天平向左移动一个位置，比较数字</p></li><li><p>因为 3 大于 2 ，所以数字不用交换</p></li><li><p>比较完成后，逐一移动天平，比较数字</p></li><li><p>此时 2 小于 4 ，所以左右的数字互相交换</p></li><li><p>重复同样的操作，直到天平移动到左端</p></li><li><p>。。。。。。</p></li><li><p>天平到达左端</p></li><li><p>经过上述的操作，数列中最小的数字已经移动到左端</p></li><li><p>将天平返回右端</p></li><li><p>重复相同的操作，直到所有数字都被排序</p></li><li><p>。。。。。。</p></li><li><p>吐完泡泡了</p></li></ol><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181119201851.png" alt=""></p><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181119201910.png" alt=""></p><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181119201417.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 冒泡排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示希尔排序</title>
      <link href="/posts/23853/"/>
      <url>/posts/23853/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解希尔排序"><a href="#【图解数据结构】-一组动画彻底理解希尔排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解希尔排序"></a>【图解数据结构】 一组动画彻底理解希尔排序</h1><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</p></li><li><p>按增量序列个数 k，对序列进行 k 趟排序；</p></li><li><p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p></li></ol><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，选择增量 gap = 10/2 ，缩小增量继续以 gap = gap/2 的方式</p></li><li><p>初始增量为 gap = 10/2 = 5，整个数组分成了 5 组</p></li><li><p>按颜色划分为【 8 , 3 】，【 9 , 5 】，【 1 , 4 】，【 7 , 6 】，【 2 , 0 】</p></li><li><p>对这分开的 5 组分别使用上节所讲的插入排序</p></li><li><p>结果可以发现，这五组中的相对小元素都被调到前面了</p></li><li><p>缩小增量 gap = 5/2 = 2，整个数组分成了 2 组</p></li><li><p>【 3 , 1 , 0 , 9 , 7  】，【 5 , 6 , 8 , 4 , 2  】</p></li><li><p>对这分开的 2 组分别使用上节所讲的插入排序</p></li><li><p>此时整个数组的有序性是很明显的</p></li><li><p>再缩小增量 gap = 2/2 = 1，整个数组分成了 1 组</p></li><li><p>【 0, 2 , 1 , 4 , 3 , 5 , 7 , 6 , 9 , 0  】</p></li><li><p>此时，只需要对以上数列进行简单的微调，不需要大量的移动操作即可完成整个数组的排序</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674859d8e945f1a?w=1280&amp;h=1037&amp;f=png&amp;s=167873" alt=""></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674859d8dda4858?w=1280&amp;h=1275&amp;f=png&amp;s=248791" alt=""></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674859d902e21b0?w=1128&amp;h=1110&amp;f=png&amp;s=53723" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674859d8e52ee54?w=1280&amp;h=934&amp;f=png&amp;s=185891" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 希尔排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示堆排序</title>
      <link href="/posts/29807/"/>
      <url>/posts/29807/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解堆排序"><a href="#【图解数据结构】-一组动画彻底理解堆排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解堆排序"></a>【图解数据结构】 一组动画彻底理解堆排序</h1><h2 id="预备知识：堆结构"><a href="#预备知识：堆结构" class="headerlink" title="预备知识：堆结构"></a>预备知识：堆结构</h2><p>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p><h4 id="大顶堆"><a href="#大顶堆" class="headerlink" title="大顶堆"></a>大顶堆</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181125194044.png" alt=""></p><h4 id="小顶堆"><a href="#小顶堆" class="headerlink" title="小顶堆"></a>小顶堆</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181125194056.png" alt=""></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序（Heapsort）是指利用堆这种数据结构（后面的【图解数据结构】内容会讲解分析）所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ul><li><p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p></li><li><p>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p></li></ul><p>堆排序的平均时间复杂度为 Ο(nlogn)。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>创建一个堆 H[0……n-1]；</p></li><li><p>把堆首（最大值）和堆尾互换；</p></li><li><p>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</p></li><li><p>重复步骤 2，直到堆的尺寸为 1。</p></li></ol><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181125191942.gif" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，将所有的数字存储在堆中</p></li><li><p>按大顶堆构建堆，其中大顶堆的一个特性是数据将被从大到小取出，将取出的数字按照相反的顺序进行排列，数字就完成了排序</p></li><li><p>在这里数字 5 先入堆</p></li><li><p>数字 2 入堆</p></li><li><p>数字 7 入堆， 7 此时是最后一个节点，与最后一个非叶子节点（也就是数字 5 ）进行比较，由于 7 大于 5 ，所以 7 和 5 交互</p></li><li><p>按照上述的操作将所有数字入堆，然后从左到右，从上到下进行调整，构造出大顶堆</p></li><li><p>入堆完成之后，将堆顶元素取出，将末尾元素置于堆顶，重新调整结构，使其满足堆定义</p></li><li><p>堆顶元素数字 7 取出，末尾元素数字 4 置于堆顶，为了维护好大顶堆的定义，最后一个非叶子节点数字 5 与 4 比较，而后交换两个数字的位置</p></li><li><p>反复执行调整+交换步骤，直到整个序列有序</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="Go代码实现"><a href="#Go代码实现" class="headerlink" title="Go代码实现"></a>Go代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126100338.png" alt=""></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126100347.png" alt=""></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126100353.png" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126100358.png" alt=""></p><p>如果你是iOS开发者，可以在GitHub上 <a href="https://github.com/MisterBooo/Play-With-Sort-OC" target="_blank" rel="noopener">https://github.com/MisterBooo/Play-With-Sort-OC</a> 获取更直观可调试运行的源码。</p><p>你可以在公众号 <strong>五分钟学算法</strong> 获取更多排序内容。</p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆排序 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示插入排序</title>
      <link href="/posts/42319/"/>
      <url>/posts/42319/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画演示插入排序"><a href="#【图解数据结构】-一组动画演示插入排序" class="headerlink" title="【图解数据结构】 一组动画演示插入排序"></a>【图解数据结构】 一组动画演示插入排序</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于LeetCode上的算法题很多涉及到一些基础的数据结构，为了更好的理解后续更新的一些复杂题目的动画，推出一个新系列 —–《图解数据结构》，主要使用动画来描述常见的数据结构和算法。本系列包括十大排序、堆、队列、树、并查集、图等等大概几十篇。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p></li><li><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）。</p></li></ol><p>来源：<a href="https://github.com/hustcc/JS-Sorting-Algorithm" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm</a></p><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181120164938.gif" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>一开始左端数字已经排序，数字 5 不动</p></li><li><p>然后，取出剩余未操作的左端数字 3 </p></li><li><p>将其与已经操作的左侧数字相比较</p></li><li><p>如果左边的数字较大，则交换两个数字</p></li><li><p>这种情况下，由于 5 大于 3 ，所以交换两个数字</p></li><li><p>重复此操作，直到出现一个较小的数字或者数字到达左端</p></li><li><p>数字 3 已经完成排序</p></li><li><p>接下来，和之前一样取出剩余未操作的左端数字 4  </p></li><li><p>与其相邻的左边数字进行比较</p></li><li><p>这种情况下，由于 5 大于 4 ，所以交换两个数字</p></li><li><p>继续操作，由于 3 小于 4 ，即出现了更小的数字，所以 4 停止移动</p></li><li><p>数字 4 已经完成排序</p></li><li><p>重复相同的操作，直到所有的数字完成排序</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h4><p><img src="http://upload-images.jianshu.io/upload_images/1940317-ce2bac560fc4620a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="http://upload-images.jianshu.io/upload_images/1940317-e29b04076de62c3a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="http://upload-images.jianshu.io/upload_images/1940317-25d430ac861b8bdd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="http://upload-images.jianshu.io/upload_images/1940317-575eb47403e08c3f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 插入排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【图解数据结构】 一组动画演示计数排序</title>
      <link href="/posts/33704/"/>
      <url>/posts/33704/</url>
      
        <content type="html"><![CDATA[<h1 id="【图解数据结构】-一组动画彻底理解计数排序"><a href="#【图解数据结构】-一组动画彻底理解计数排序" class="headerlink" title="【图解数据结构】 一组动画彻底理解计数排序"></a>【图解数据结构】 一组动画彻底理解计数排序</h1><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序是一种非基于比较的排序算法，其空间复杂度和时间复杂度均为O(n+k)，其中k是整数的范围。基于比较的排序算法时间复杂度最小是O(nlogn)的。该算法于1954年由 Harold H. Seward 提出。</p><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有<strong>确定范围的整数</strong>。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li><p>花O(n)的时间扫描一下整个序列 A，获取最小值 min 和最大值 max</p></li><li><p>开辟一块新的空间创建新的数组 B，长度为 ( max - min + 1)</p></li><li><p>数组 B 中 index 的元素记录的值是 A 中某元素出现的次数</p></li><li><p>最后输出目标整数序列，具体的逻辑是遍历数组 B，输出相应元素以及对应的个数</p></li></ol><h2 id="算法演示"><a href="#算法演示" class="headerlink" title="算法演示"></a>算法演示</h2><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126190814.gif" alt=""></p><h2 id="排序动画过程解释"><a href="#排序动画过程解释" class="headerlink" title="排序动画过程解释"></a>排序动画过程解释</h2><ol><li><p>首先，扫描一下整个序列</p></li><li><p>获得最小值为 2 ，最大值为 7</p></li><li><p>新建数组包含 2~7 的元素</p></li><li><p>再次扫描序列，将序列的值放置在新建数组中</p></li><li><p>扫描数字 5，数组中 index 为 3 的值为 5，次数为 1</p></li><li><p>扫描数字 3，数组中 index 为 1 的值为 3，次数为 1</p></li><li><p>扫描数字 4，数组中 index 为 2 的值为 4，次数为 1</p></li><li><p>扫描数字 7，数组中 index 为 5 的值为 7，次数为 1</p></li><li><p>扫描数字 2，数组中 index 为 0 的值为 2，次数为 1</p></li><li><p>扫描数字 4，数组中 index 为 2 的值为 4，次数为 2</p></li><li><p>扫描数字 3，数组中 index 为 1 的值为 3，次数为 2</p></li><li><p>按照这种节奏，扫描结束后，新建数组中存放了整个序列以及每个数字出现的次数</p></li><li><p>最后输出目标整数序列</p></li><li><p>输出数字 2，同时数组中 index 为 0 的值为 2 的元素次数变为 0</p></li><li><p>输出数字 3，同时数组中 index 为 1 的值为 3 的元素次数变为 1</p></li><li><p>同样的操作，整个序列就完全输出了</p></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了更好的让读者用自己熟悉的编程语言来理解动画，笔者将贴出多种编程语言的参考代码，代码全部来源于网上。</p><h4 id="Go代码实现"><a href="#Go代码实现" class="headerlink" title="Go代码实现"></a>Go代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126191921.png" alt=""></p><h4 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126191936.png" alt=""></p><h4 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126191943.png" alt=""></p><h4 id="JavaScript代码实现"><a href="#JavaScript代码实现" class="headerlink" title="JavaScript代码实现"></a>JavaScript代码实现</h4><p><img src="https://bucket-1257126549.cos.ap-guangzhou.myqcloud.com/20181126191949.png" alt=""></p><p>如果你是iOS开发者，可以在GitHub上 <a href="https://github.com/MisterBooo/Play-With-Sort-OC" target="_blank" rel="noopener">https://github.com/MisterBooo/Play-With-Sort-OC</a> 获取更直观可调试运行的源码。</p>]]></content>
      
      
      <categories>
          
          <category> 十大经典排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 计数排序 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
